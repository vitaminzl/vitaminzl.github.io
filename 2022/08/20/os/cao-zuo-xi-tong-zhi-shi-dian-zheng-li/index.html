

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/image/cat.png">
  <link rel="icon" href="/image/cat.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="vitaminzl">
  <meta name="keywords" content="">
  
    <meta name="description" content="Pintos  环境篇  WSL: Ubuntu18.04 Windows Subsystem for Linux（简称WSL）是一个在Windows 10上能够运行原生Linux二进制可执行文件（ELF格式）的兼容层。它是由微软与Canonical公司合作开发，其目标是使纯正的Ubuntu、Debian等映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。[h">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统知识整理">
<meta property="og:url" content="http://vitaminzl.com/2022/08/20/os/cao-zuo-xi-tong-zhi-shi-dian-zheng-li/index.html">
<meta property="og:site_name" content="闲渔">
<meta property="og:description" content="Pintos  环境篇  WSL: Ubuntu18.04 Windows Subsystem for Linux（简称WSL）是一个在Windows 10上能够运行原生Linux二进制可执行文件（ELF格式）的兼容层。它是由微软与Canonical公司合作开发，其目标是使纯正的Ubuntu、Debian等映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。[h">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-20T04:00:00.000Z">
<meta property="article:modified_time" content="2022-09-01T15:14:12.647Z">
<meta property="article:author" content="vitaminzl">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>操作系统知识整理 - 闲渔</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"vitaminzl.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="闲渔" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>闲渔</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/image/snow-small.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="操作系统知识整理"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-20 12:00" pubdate>
          2022年8月20日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          77k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          322 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">操作系统知识整理</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="pintos"><a class="markdownIt-Anchor" href="#pintos"></a> Pintos</h1>
<h2 id="环境篇"><a class="markdownIt-Anchor" href="#环境篇"></a> 环境篇</h2>
<h3 id="wsl-ubuntu1804"><a class="markdownIt-Anchor" href="#wsl-ubuntu1804"></a> WSL: Ubuntu18.04</h3>
<p>Windows Subsystem for Linux（简称WSL）是一个在Windows 10上能够运行原生Linux二进制可执行文件（ELF格式）的兼容层。它是由微软与Canonical公司合作开发，其目标是使纯正的Ubuntu、Debian等映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。[<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/wsl/20359185?fr=aladdin#reference-%5B1%5D-21058117-wrap">https://baike.baidu.com/item/wsl/20359185?fr=aladdin#reference-[1]-21058117-wrap</a>]。</p>
<p>安装步骤：可直接使用windows自带软件商城，搜索Ubuntu18.04安装即可。如果不想装到c盘，可参考文章https://blog.csdn.net/tiandiren111/article/details/121026761。<strong>不建议使用图形化界面，尝试使用命令行界面，或许有意想不到的惊喜。</strong></p>
<h3 id="配置pintos"><a class="markdownIt-Anchor" href="#配置pintos"></a> 配置Pintos</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/geeeeeker/article/details/108104466%EF%BC%88%E5%8E%9F%E6%96%87%E4%B8%AD9%E3%80%8110%E3%80%8111%E6%98%AF%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E7%94%9A%E8%87%B3%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%89%E5%8F%AF%E8%83%BD%E8%BF%98%E9%9C%80%E8%A6%81%E5%AE%89%E8%A3%85gdb%E3%80%81git%E3%80%81vim%E7%AD%89%E5%B7%A5%E5%85%B7%EF%BC%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%BC%BA%E5%95%A5%E8%A1%A5%E5%95%A5%E5%B0%B1%E8%A1%8C%E4%BA%86%EF%BC%88%E5%8D%B3%E7%94%A8sudo">https://blog.csdn.net/geeeeeker/article/details/108104466（原文中9、10、11是不必要的甚至错误的）可能还需要安装gdb、git、vim等工具，过程中缺啥补啥就行了（即用sudo</a> apt-get install xxx来安装）。</p>
<ol>
<li>在终端运行<code>sudo apt-get install qemu</code></li>
<li>从<a target="_blank" rel="noopener" href="https://pintos-os.org/cgi-bin/gitweb.cgi?p=pintos-anon;a=summary">git公共库</a>获得最新Pintos，下载.tar .gz到你自己的目录并解压。</li>
<li><code>/utils/pintos-gdb</code>用vim打开，编辑<code>GDBMACROS</code>变量，将你自己的Pintos完整路径赋给该变量。</li>
<li>用vim打开Makefile并将<code>LOADLIBES</code>变量名编辑为<code>LDLIBS</code></li>
<li>在<code>/src/utils</code>中输入<code>make</code>来编译utils</li>
<li>编辑<code>/src/threads/Make.vars</code>（第7行）：更改<code>bochs</code>为<code>qemu</code></li>
<li>在<code>/src/threads</code>并运行来编译线程目录<code>make</code></li>
<li>编辑<code>/utils/pintos</code>（第103行）：替换<code>bochs</code>为<code>qemu</code></li>
<li>打开<code>~/.bashrc</code>并添加<code>export PATH=/home/.../pintos/src/utils:$PATH</code>到最后一行。</li>
<li>重新打开终端输入<code>source ~/.bashrc</code>并运行</li>
<li>进入src/threads/，make一下</li>
<li>然后cd build，输入<code>pintos run alarm-multiple</code>，（运行完后ctrl+c手动终止掉）。如果运行界面如下，大概率是配置成功了。以下将介绍如何测试。</li>
</ol>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/config_run.png)</p>
<h3 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h3>
<p>比如想要对thread这个project的测试点进行测试，进入…/src/threads/build目录，执行make check即可。每次测试前，<strong>需先make clean</strong>，再make check。但使用我写的脚本（参考工具篇的shell script）进行测试是不需要这样的（因为脚本帮你做了）。总之最后会输出如下的信息（这是已经完成部分test的图，以实际为准）。</p>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/first_test.png)</p>
<p>由于上述配置只使用了qemu，而由于qemu只支持real time的原因，thread项目make check<strong>需要的时间很久</strong>，大概要二十分钟左右，这是正常现象。当然，你可以安装bochs虚拟机，对pintos进行配置，可以大大提高thread这一project的check速度。不过在我的wsl上没有配置成功，在虚拟机上成功了，具体原因未知。但本人更喜欢在wsl上编写代码、测试，因此没有记录虚拟机的配置过程，如有需要，可参考https://www.cnblogs.com/crayygy/p/ubuntu-pintos.html。</p>
<p>当然如果想自己写测试脚本，可以参考工具篇shell scipt。</p>
<h2 id="工具篇"><a class="markdownIt-Anchor" href="#工具篇"></a> 工具篇</h2>
<p>”工欲善其事，必先利其器“，花点时间学习一些工具的使用，可能会有意想不到的惊喜。</p>
<h3 id="git"><a class="markdownIt-Anchor" href="#git"></a> Git</h3>
<p>Git（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 也是[Linus Torvalds](<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Linus">https://baike.baidu.com/item/Linus</a> Torvalds/9336769)为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。[<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/GIT/12647237?fr=aladdin">https://baike.baidu.com/item/GIT/12647237?fr=aladdin</a>]</p>
<p>具体用法不细说啦，需要一点学习成本。但请相信，这点学习成本是值得的，当然在本项目也是<strong>必需</strong>的。推荐学习廖雪峰的git教程：<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496%E3%80%82">https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496。</a></p>
<h3 id="tmux"><a class="markdownIt-Anchor" href="#tmux"></a> Tmux</h3>
<p>使用方法参考：<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2019/10/tmux.html">http://www.ruanyifeng.com/blog/2019/10/tmux.html</a></p>
<p>tmux可以让会话和终端窗口分离。如下图</p>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/tmux_show.png)</p>
<p>同一个终端窗口可以分屏为2个会话，你可以一侧编辑代码，一边测试。同时，方便的快捷键，可以让你不再依赖鼠标，提高工作效率。</p>
<p>配合GDB使用更佳。</p>
<h3 id="gdb"><a class="markdownIt-Anchor" href="#gdb"></a> GDB</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=0zO-8EwecP0&amp;t=620s">https://www.youtube.com/watch?v=0zO-8EwecP0&amp;t=620s</a></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">在一个会话中输入如下命令，xxxx表示你要测试的任务名</span><br>pintos --gdb -- run xxxx<br><span class="hljs-meta"># </span><span class="language-bash">在另一个会话中输入，注意要进入build目录执行</span><br>pintos-gdb --tui<br></code></pre></td></tr></tbody></table></figure>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/gdb_tmux.png)</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">在右侧会话中输入</span><br>pintos-gdb --tui<br><span class="hljs-meta"># </span><span class="language-bash">然后输入</span><br>file kernel.o<br><span class="hljs-meta"># </span><span class="language-bash">然后根据提示输入y即可</span><br></code></pre></td></tr></tbody></table></figure>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/gdb_running.png)</p>
<p>然后就需要参照gdb的使用方法了，如加入断点</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm"># 在sema_down处添加断电<br>b sema_down<br># 继续执行至断点处<br>c<br># 下一步, 进入函数<br>s<br># 下一步，不进入函数<br>n<br># 杀死程序<br>kill<br># 等等<br># 可参照网上的一些gdb教程<br># 如https://baijiahao.baidu.com/s?id=1675872273223193511&amp;wfr=spider&amp;for=pc等等<br></code></pre></td></tr></tbody></table></figure>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/gdb_running2.png)</p>
<h3 id="understand"><a class="markdownIt-Anchor" href="#understand"></a> Understand</h3>
<p>Understand是一款静态代码分析工具，界面如下图所示：</p>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/understand_ui.png)</p>
<p>我比较喜欢的功能是它可以画出函数之间的调用图。</p>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/understand_call.png)</p>
<p>还有这样的蝴蝶图。</p>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/understand_butterfly.png)</p>
<p>推荐使用它对代码进行分析。</p>
<h3 id="shell-script"><a class="markdownIt-Anchor" href="#shell-script"></a> Shell script</h3>
<p>使用shell编写一些脚本，可以个性化地完成一些你所想的工作。如果想要使用如下脚本，只需将missions数组中写入所需要测试的任务名即可。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">unset missions<br>missions=(alarm-single alarm-multiple alarm-simultaneous alarm-priority alarm-zero alarm-negative) # task list<br>if [[ $1 = "m" ]]<br>then<br>	cnt=0<br>	for i in ${missions[*]}<br>	do<br>		echo $cnt:$i<br>		let "cnt++"<br>	done	<br>else<br><span class="hljs-meta">	# </span><span class="language-bash">compute number of missions</span><br>	((num=${#missions[@]}-1)) <br>	if [[ $1 &amp;&amp; $1 != "v" &amp;&amp; $1 -le $num &amp;&amp; $1 -ge 0 ]]<br>		then m=${missions[$1]}; unset missions; missions=($m)<br>	fi<br><span class="hljs-meta">	# </span><span class="language-bash">execute instructions</span>	<br>	(cd build<br>	for i in ${missions[*]}<br>	do<br>	echo ------------------------------------------------------------<br>	echo "			$i			"<br>	echo ------------------------------------------------------------<br>	rm -f tests/threads/${i}.output<br>	unset op<br>	if [[ $1 = 'v' || $2 = 'v' ]]<br>	then op='VERBOSE=1'<br>	fi<br>	make tests/threads/${i}.result $op<br>	done)<br>fi<br><br></code></pre></td></tr></tbody></table></figure>
<p>使用方法：</p>
<p>比如上述脚本，missions数组中存的是thread的task1的任务列表，我将脚本复制到task1文件中。</p>
<p>执行</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">. task1<br></code></pre></td></tr></tbody></table></figure>
<p>那么它只会执行thread中alarm部分的测试。</p>
<p>如果想要输出详细信息则执行</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">. task1 v<br></code></pre></td></tr></tbody></table></figure>
<p>如果想要执行某一个任务，可以先执行</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">. task1 m<br></code></pre></td></tr></tbody></table></figure>
<p>则会输出一个任务列表，每个任务都有一个编号</p>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/task_list.png)</p>
<p>比如想要单独测试任务3: alarm-priority，则只需执行</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">. task1 3<br><span class="hljs-meta"># </span><span class="language-bash">或者</span><br>. task1 3 v<br><span class="hljs-meta"># </span><span class="language-bash">表示输出第三个任务的详细信息</span><br></code></pre></td></tr></tbody></table></figure>
<h2 id="结构篇"><a class="markdownIt-Anchor" href="#结构篇"></a> 结构篇</h2>
<h3 id="主要模块分析"><a class="markdownIt-Anchor" href="#主要模块分析"></a> 主要模块分析</h3>
<p>参考：Pintos官方手册的Appendix部分</p>
<h3 id="补充知识"><a class="markdownIt-Anchor" href="#补充知识"></a> 补充知识</h3>
<h4 id="c语言的面向对象"><a class="markdownIt-Anchor" href="#c语言的面向对象"></a> C语言的面向对象</h4>
<p>C语言中没有class，但是也可以使用一些技巧来达到面向对象编程的目的。如：pintos的list.h中有这样一串代码，它表示，输入list_elem的地址，再输入宿主结构，以及list_elem类型成员在宿主中的名字，就可以获得宿主的地址。这样就能实现使用通过list_elem来访问宿主结构体的目的啦。 如此一来，只需要实现一个list的代码，就能够使得所有类型的struct都能去使用它。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* offset表示某成员在TYPE中的偏移地址 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *) 0)-&gt;MEMBER)</span><br><span class="hljs-comment">/* Converts pointer to list element LIST_ELEM into a pointer to</span><br><span class="hljs-comment">   the structure that LIST_ELEM is embedded inside.  Supply the</span><br><span class="hljs-comment">   name of the outer structure STRUCT and the member name MEMBER</span><br><span class="hljs-comment">   of the list element.  See the big comment at the top of the</span><br><span class="hljs-comment">   file for an example. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_entry(LIST_ELEM, STRUCT, MEMBER)           \</span><br><span class="hljs-meta">        ((STRUCT *) ((uint8_t *) &amp;(LIST_ELEM)-&gt;next     \</span><br><span class="hljs-meta">                     - offsetof (STRUCT, MEMBER.next)))</span><br></code></pre></td></tr></tbody></table></figure>
<h4 id="内联汇编"><a class="markdownIt-Anchor" href="#内联汇编"></a> 内联汇编</h4>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1782e14a076">https://www.jianshu.com/p/1782e14a076</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/taek/archive/2012/02/05/2338838.html">https://www.cnblogs.com/taek/archive/2012/02/05/2338838.html</a></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">asm</span> ( assembler template<br>        : output operands                <span class="hljs-comment">/* optional */</span><br>        : input operands                 <span class="hljs-comment">/* optional */</span><br>        : <span class="hljs-built_in">list</span> of clobbered registers    <span class="hljs-comment">/* optional */</span><br>);<br></code></pre></td></tr></tbody></table></figure>
<p>Eamples</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>, b;<br><span class="hljs-keyword">asm</span> ( <span class="hljs-string">"movl %1, %%eax;movl %%eax, %0;"</span><br>          :<span class="hljs-string">"=r"</span>(b)           	<span class="hljs-comment">/* output */</span><br>          :<span class="hljs-string">"r"</span>(a)              	<span class="hljs-comment">/* input */</span><br>          :<span class="hljs-string">"%eax"</span>         		<span class="hljs-comment">/* clobbered register */</span><br>);<br></code></pre></td></tr></tbody></table></figure>
<p>Constraints</p>
<figure class="highlight mathematica"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">其他可能用到的<span class="hljs-variable">constraint</span>有：<br><span class="hljs-variable">r</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用一个通用寄存器<span class="hljs-operator">,</span>由<span class="hljs-variable">GCC</span>在<span class="hljs-operator">%</span><span class="hljs-variable">eax</span><span class="hljs-operator">/%</span><span class="hljs-variable">ax</span><span class="hljs-operator">/%</span><span class="hljs-variable">al</span>、<span class="hljs-operator">%</span><span class="hljs-variable">ebx</span><span class="hljs-operator">/%</span><span class="hljs-variable">bx</span><span class="hljs-operator">/%</span><span class="hljs-variable">bl</span>、<span class="hljs-operator">%</span><span class="hljs-variable">ecx</span><span class="hljs-operator">/%</span><span class="hljs-variable">cx</span><span class="hljs-operator">/%</span><span class="hljs-variable">cl</span>、<span class="hljs-operator">%</span><span class="hljs-variable">edx</span><span class="hljs-operator">/%</span><span class="hljs-variable">dx</span><span class="hljs-operator">/%</span><span class="hljs-variable">dl</span>中选取一个<span class="hljs-variable">GCC</span>认为是合适的<span class="hljs-operator">;</span><br><span class="hljs-variable">q</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用一个通用寄存器<span class="hljs-operator">,</span>与<span class="hljs-variable">r</span>的意义相同<span class="hljs-operator">;</span><br><span class="hljs-variable">g</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用寄存器或内存地址<span class="hljs-operator">;</span><br><span class="hljs-variable">m</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用内存地址<span class="hljs-operator">;</span><br><span class="hljs-variable">a</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用<span class="hljs-operator">%</span><span class="hljs-variable">eax</span><span class="hljs-operator">/%</span><span class="hljs-variable">ax</span><span class="hljs-operator">/%</span><span class="hljs-variable">al</span><span class="hljs-operator">;</span><br><span class="hljs-variable">b</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用<span class="hljs-operator">%</span><span class="hljs-variable">ebx</span><span class="hljs-operator">/%</span><span class="hljs-variable">bx</span><span class="hljs-operator">/%</span><span class="hljs-variable">bl</span><span class="hljs-operator">;</span><br><span class="hljs-variable">c</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用<span class="hljs-operator">%</span><span class="hljs-variable">ecx</span><span class="hljs-operator">/%</span><span class="hljs-variable">cx</span><span class="hljs-operator">/%</span><span class="hljs-variable">cl</span><span class="hljs-operator">;</span><br><span class="hljs-variable">d</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用<span class="hljs-operator">%</span><span class="hljs-variable">edx</span><span class="hljs-operator">/%</span><span class="hljs-variable">dx</span><span class="hljs-operator">/%</span><span class="hljs-variable">dl</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">D</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用<span class="hljs-operator">%</span><span class="hljs-variable">edi</span><span class="hljs-operator">/%</span><span class="hljs-variable">di</span><span class="hljs-operator">;</span><br><span class="hljs-variable">S</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用<span class="hljs-operator">%</span><span class="hljs-variable">esi</span><span class="hljs-operator">/%</span><span class="hljs-variable">si</span><span class="hljs-operator">;</span><br><span class="hljs-variable">f</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用浮点寄存器<span class="hljs-operator">;</span><br><span class="hljs-variable">t</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用第一个浮点寄存器<span class="hljs-operator">;</span><br><span class="hljs-variable">u</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用第二个浮点寄存器<span class="hljs-operator">;</span><br><span class="hljs-variable">A</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示把<span class="hljs-operator">%</span><span class="hljs-variable">eax</span>与<span class="hljs-operator">%</span><span class="hljs-variable">edx</span>组合成一个<span class="hljs-number">64</span>位的整数值<span class="hljs-operator">;</span><br><span class="hljs-variable">o</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用一个内存位置的偏移量<span class="hljs-operator">;</span><br><span class="hljs-variable">V</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示仅仅使用一个直接内存位置<span class="hljs-operator">;</span><br><span class="hljs-variable">i</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用一个整数类型的立即数<span class="hljs-operator">;</span><br><span class="hljs-variable">n</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用一个带有已知整数值的立即数<span class="hljs-operator">;</span><br><span class="hljs-variable">F</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用一个浮点类型的立即数<span class="hljs-operator">;</span><br></code></pre></td></tr></tbody></table></figure>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-title">.data段保存程序的数据，是可读可写的，相当于C程序的全局变量</span><br><span class="hljs-title">.globl指示告诉汇编器，这个符号要被链接器用到，所以要在目标文件的符号表中标记它是一个全局符号</span><br><span class="hljs-title">.text段保存代码，是只读和可执行的</span><br></code></pre></td></tr></tbody></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">Intel Code</th>
<th style="text-align:left">AT&amp;T Code</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">mov     eax,1</td>
<td style="text-align:left">movl    $1,%eax</td>
</tr>
<tr>
<td style="text-align:left">mov     ebx,0ffh</td>
<td style="text-align:left">movl    $0xff,%ebx</td>
</tr>
<tr>
<td style="text-align:left">int     80h</td>
<td style="text-align:left">int     $0x80</td>
</tr>
<tr>
<td style="text-align:left">mov     ebx, eax</td>
<td style="text-align:left">movl    %eax, %ebx</td>
</tr>
<tr>
<td style="text-align:left">mov     eax,[ecx]</td>
<td style="text-align:left">movl    (%ecx),%eax</td>
</tr>
<tr>
<td style="text-align:left">mov     eax,[ebx+3]</td>
<td style="text-align:left">movl    3(%ebx),%eax</td>
</tr>
<tr>
<td style="text-align:left">mov     eax,[ebx+20h]</td>
<td style="text-align:left">movl    0x20(%ebx),%eax</td>
</tr>
<tr>
<td style="text-align:left">add     eax,[ebx+ecx*2h]</td>
<td style="text-align:left">addl    (%ebx,%ecx,0x2),%eax</td>
</tr>
<tr>
<td style="text-align:left">lea     eax,[ebx+ecx]</td>
<td style="text-align:left">leal    (%ebx,%ecx),%eax</td>
</tr>
<tr>
<td style="text-align:left">sub     eax,[ebx+ecx*4h-20h]</td>
<td style="text-align:left">subl    -0x20(%ebx,%ecx,0x4),%eax</td>
</tr>
</tbody>
</table>
<h4 id="汇编调用c函数"><a class="markdownIt-Anchor" href="#汇编调用c函数"></a> 汇编调用c函数</h4>
<ol>
<li>将参数压栈</li>
<li>调用</li>
</ol>
<p>结构体变量注意8字节对齐。</p>
<p>可参照pintos中的switch.h文件中的switch_threads，该函数被schedule()调用。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs asm">#include "threads/switch.h"<br><br>#### struct thread *switch_threads (struct thread *cur, struct thread *next);<br>####<br>#### Switches from CUR, which must be the running thread, to NEXT,<br>#### which must also be running switch_threads(), returning CUR in<br>#### NEXT's context.<br>####<br>#### This function works by assuming that the thread we're switching<br>#### into is also running switch_threads().  Thus, all it has to do is<br>#### preserve a few registers on the stack, then switch stacks and<br>#### restore the registers.  As part of switching stacks we record the<br>#### current stack pointer in CUR's thread structure.<br><br>.globl switch_threads<br>.func switch_threads<br>switch_threads:<br>	# Save caller's register state.<br>	#<br>	# Note that the SVR4 ABI allows us to destroy %eax, %ecx, %edx,<br>	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See<br>	# [SysV-ABI-386] pages 3-11 and 3-12 for details.<br>	#<br>	# This stack frame must match the one set up by thread_create()<br>	# in size.<br>	pushl %ebx<br>	pushl %ebp<br>	pushl %esi<br>	pushl %edi<br><br>	# Get offsetof (struct thread, stack).<br>.globl thread_stack_ofs<br>	mov thread_stack_ofs, %edx<br><br>	# Save current stack pointer to old thread's stack, if any.<br>	movl SWITCH_CUR(%esp), %eax<br>	movl %esp, (%eax,%edx,1)<br><br>	# Restore stack pointer from new thread's stack.<br>	movl SWITCH_NEXT(%esp), %ecx<br>	movl (%ecx,%edx,1), %esp<br><br>	# Restore caller's register state.<br>	popl %edi<br>	popl %esi<br>	popl %ebp<br>	popl %ebx<br>        ret<br>.endfunc<br><br>.globl switch_entry<br>.func switch_entry<br>switch_entry:<br>	# Discard switch_threads() arguments.<br>	addl $8, %esp<br><br>	# Call thread_schedule_tail(prev).<br>	pushl %eax<br>.globl thread_schedule_tail<br>	call thread_schedule_tail<br>	addl $4, %esp<br><br>	# Start thread proper.<br>	ret<br>.endfunc<br></code></pre></td></tr></tbody></table></figure>
<h4 id="进程切换"><a class="markdownIt-Anchor" href="#进程切换"></a> 进程切换</h4>
<p>切换前，保存进程上下文信息</p>
<p>切换后，恢复进程上下文信息</p>
<p>可参照pintos中的switch.h文件中的switch_threads，该函数被schedule()调用。</p>
<hr>
<h3 id="qa"><a class="markdownIt-Anchor" href="#qa"></a> Q&amp;A</h3>
<ol>
<li>
<p>running_thread(void)</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Copy the CPU's stack pointer into `esp', and then round that</span><br><span class="hljs-comment">   down to the start of a page.  Because `struct thread' is</span><br><span class="hljs-comment">   always at the beginning of a page and the stack pointer is</span><br><span class="hljs-comment">   somewhere in the middle, this locates the curent thread. */</span><br></code></pre></td></tr></tbody></table></figure>
</li>
</ol>
<p>​	问：为啥esp和线程在同一个页面？</p>
<p>​	答：见手册P61</p>
<ol start="2">
<li>
<p>sema_down(void)</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Down or "P" operation on a semaphore.  Waits for SEMA's value</span><br><span class="hljs-comment">   to become positive and then atomically decrements it.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   This function may sleep, so it must not be called within an</span><br><span class="hljs-comment">   interrupt handler.  This function may be called with</span><br><span class="hljs-comment">   interrupts disabled, but if it sleeps then the next scheduled</span><br><span class="hljs-comment">   thread will probably turn interrupts back on. */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">sema_down</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sema)</span> <br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span>;</span><br><br>  ASSERT (sema != <span class="hljs-literal">NULL</span>);<br>  ASSERT (!intr_context ());<br><br>  old_level = intr_disable ();<br>  <span class="hljs-keyword">while</span> (sema-&gt;value == <span class="hljs-number">0</span>) <br>    {<br>      list_push_back (&amp;sema-&gt;waiters, &amp;thread_current ()-&gt;elem);<br>      thread_block ();<br>    }<br>  sema-&gt;value--;<br>  intr_set_level (old_level);<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<p>关于sema_down的实现，一开始还是有点迷糊的。先说收它的功能：先是关闭中断，当sema为0的时候，就把它推进等待队列，然后阻塞自己。随后，如果其他进程也sema_down，那同样会进来，由于还没有sema_up，sema还是0，同样阻塞自己。直到有人sema_up。至于注释说它说这个function可能会sleep，sleep是指后面调用了thread_block，会跳出这个程序，执行另一个进程。但是问题在于，它把中断关了，那其他进程岂不都是在关中断的情况下进行的？那不是无法被时间片调度？好像是有可能的。不过，我看了一下有谁会调用开中断程序。</p>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/timer_intr.png)</p>
<p>发现thread_create会间接调用intr_enable，仔细看一下kenel_thread的代码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Function used as the basis for a kernel thread. */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">kernel_thread</span> <span class="hljs-params">(thread_func *function, <span class="hljs-type">void</span> *aux)</span> <br>{<br>  ASSERT (function != <span class="hljs-literal">NULL</span>);<br><br>  intr_enable ();       <span class="hljs-comment">/* The scheduler runs with interrupts off. */</span><br>  function (aux);       <span class="hljs-comment">/* Execute the thread function. */</span><br>  thread_exit ();       <span class="hljs-comment">/* If function() returns, kill the thread. */</span><br>}<br></code></pre></td></tr></tbody></table></figure>
<p>发现，当执行线程函数之前，首先做的事就是开中断。那么就意味着，如果是执行新创建的一个线程，就会把中断打开。不过还是感觉怪怪的，感觉这里关中断关的有点久了？</p>
</li>
</ol>
<h2 id="实现篇"><a class="markdownIt-Anchor" href="#实现篇"></a> 实现篇</h2>
<p>个人认为，project的难度较高，这使得独立实现比较困难。可以参考以下文章，辅助阅读。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/laiy/p/pintos_project1_thread.html">https://www.cnblogs.com/laiy/p/pintos_project1_thread.html</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104497182">https://zhuanlan.zhihu.com/p/104497182</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Calvinzan/article/details/117966196">https://blog.csdn.net/Calvinzan/article/details/117966196</a></p>
<p><a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/8296f9629b6648d7c1c74649.html">https://wenku.baidu.com/view/8296f9629b6648d7c1c74649.html</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/340428650">https://zhuanlan.zhihu.com/p/340428650</a></p>
<h3 id="project1-threads"><a class="markdownIt-Anchor" href="#project1-threads"></a> Project1 Threads</h3>
<h4 id="task1-alarm"><a class="markdownIt-Anchor" href="#task1-alarm"></a> Task1: alarm</h4>
<h5 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h5>
<p>先来看看任务1的Mission List:</p>
<figure class="highlight elixir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-number">0</span><span class="hljs-symbol">:alarm-single</span><br><span class="hljs-number">1</span><span class="hljs-symbol">:alarm-multiple</span><br><span class="hljs-number">2</span><span class="hljs-symbol">:alarm-simultaneous</span><br><span class="hljs-number">3</span><span class="hljs-symbol">:alarm-priority</span><br><span class="hljs-number">4</span><span class="hljs-symbol">:alarm-zero</span><br><span class="hljs-number">5</span><span class="hljs-symbol">:alarm-negative</span><br></code></pre></td></tr></tbody></table></figure>
<p>我们需要实现哪些工作？</p>
<ol>
<li>将忙等待的睡眠机制，转为block</li>
<li>实现优先级唤醒</li>
</ol>
<p>这两个任务，我们最好不要分开考虑，要相结合。</p>
<p>根据操作系统的知识，让系统睡眠的常用方法其实是阻塞该睡眠进程。如下图所示，睡眠时，可将其塞入<strong>阻塞（block）队列</strong>当中，当<strong>事件（Event）<strong>发生时，再将其丢入</strong>ready队列</strong>。</p>
<p>那么这里需阐明几点概念</p>
<ul>
<li><strong>事件</strong>是什么？对于唤醒的事件，就是当时间到的时候，而pintos实现计时功能的，则是利用时间中断的机制，当经过一个最小的时间单位后，8254芯片就会产生时间中断，进入timer_interrupt函数，将时间加1，<strong>因此这里的事件应该指的是，睡眠时间用尽，那么事件发生的地点应在timer_interrupt函数中，则唤醒进程的任务在该函数进行。</strong></li>
<li><strong>ready队列</strong>是个FIFO队列吗？显然不是，因为我们要实现的第二个任务便是优先级唤醒，因此在执行顺序上，对于同一时间唤醒的几个进程，应按照优先级唤醒。<strong>那么ready应当是个优先级队列</strong>。不仅如此，Blocked queue最好也应设计为优先队列。</li>
<li>为了简单起见，我们无需开辟一个Blocked queue去存储阻塞队列，只需遍历all_list，通过标志位进行判断是否为阻塞即可。</li>
</ul>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/schedule.png)</p>
<p>到此为止，task1的思路基本明了了。以下阐述具体实现</p>
<hr>
<h5 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h5>
<ul>
<li>为完成第一个目标，首先我们应修改timer_sleep函数，去除忙等待机制</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*########################## timer.c ###########################*/</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">timer_sleep</span> <span class="hljs-params">(<span class="hljs-type">int64_t</span> ticks)</span><br>{<br>  <span class="hljs-type">int64_t</span> start = timer_ticks ();<br><br>  ASSERT (intr_get_level () == INTR_ON);<br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br>  <span class="hljs-comment">/* 关闭中断，基操 */</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();<br>  <br>  <span class="hljs-comment">/* 获取当前线程，并存入休眠时间，阻塞进程 */</span><br>   <span class="hljs-keyword">if</span>(ticks &gt; <span class="hljs-number">0</span>)<br>   {<br>     thread_current() -&gt; sleepticks = ticks;<br>     thread_block();<br>   }<br>    <br>  intr_set_level(old_level);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>}<br><br><br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>在实现以上函数的时候，我们使用了thread中的sleepticks，而这一些在源程序中，其实是没有的，我们需添加这些东西</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*########################## thread.h ###########################*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span></span><br><span class="hljs-class">  {</span><br>    <span class="hljs-comment">/* Owned by thread.c. */</span><br>    <span class="hljs-type">tid_t</span> tid;                          <span class="hljs-comment">/* Thread identifier. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">thread_status</span> <span class="hljs-title">status</span>;</span>          <span class="hljs-comment">/* Thread state. */</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">16</span>];                      <span class="hljs-comment">/* Name (for debugging purposes). */</span><br>    <span class="hljs-type">uint8_t</span> *<span class="hljs-built_in">stack</span>;                     <span class="hljs-comment">/* Saved stack pointer. */</span><br>    <span class="hljs-type">int</span> priority;                       <span class="hljs-comment">/* Priority. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> <span class="hljs-title">allelem</span>;</span>           <span class="hljs-comment">/* List element for all threads list. */</span><br><br>    <span class="hljs-comment">/* Shared between thread.c and synch.c. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> <span class="hljs-title">elem</span>;</span>              <span class="hljs-comment">/* List element. */</span><br><br>    <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><br>    <span class="hljs-type">int</span> sleepticks;                     <span class="hljs-comment">/* How may time to sleep */</span><br><br>    <span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USERPROG</span><br>    <span class="hljs-comment">/* Owned by userprog/process.c. */</span><br>    <span class="hljs-type">uint32_t</span> *pagedir;                  <span class="hljs-comment">/* Page directory. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* Owned by thread.c. */</span><br>    <span class="hljs-type">unsigned</span> magic;                     <span class="hljs-comment">/* Detects stack overflow. */</span><br>  };<br><br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>接下来我们要考虑怎么去唤醒它了</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span><br><br><span class="hljs-comment">/*对于sleep_queue中的每一个进程，都进行sleepticks--的操作，</span><br><span class="hljs-comment"> 并检查是否到了休眠时间，即sleepticks==0?  */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">check_and_unblock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* t, <span class="hljs-type">void</span>*aux UNUSED)</span><br>{<br>  <span class="hljs-keyword">if</span> (t-&gt;status == THREAD_BLOCKED &amp;&amp; t-&gt;sleepticks &gt; <span class="hljs-number">0</span>)<br>  {<br>    t-&gt;sleepticks --;<br>    <span class="hljs-keyword">if</span> (t-&gt;sleepticks &lt;= <span class="hljs-number">0</span>)<br>    {<br>      thread_unblock(t);<br>    }<br>  }<br><br>}<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br><br><span class="hljs-comment">/* Timer interrupt handler. */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">timer_interrupt</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame *args UNUSED)</span><br>{<br>  ticks++;<br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><br>  thread_foreach (check_and_unblock, <span class="hljs-literal">NULL</span>);<br><br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  thread_tick ();<br>}<br><br><br><span class="hljs-comment">/*########################## thread.c ###########################*/</span><br><br><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><br><span class="hljs-comment">/*比较线程优先级的函数*/</span><br><span class="hljs-type">bool</span><br><span class="hljs-title function_">thread_cmp_priority</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem *a, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem *b, <span class="hljs-type">void</span> *aux UNUSED)</span><br>{<br>  <span class="hljs-keyword">return</span> list_entry(a, <span class="hljs-keyword">struct</span> thread, elem)-&gt;priority &gt; list_entry(b, <span class="hljs-keyword">struct</span> thread, elem)-&gt;priority;<br>}<br><br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">thread_unblock</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> thread *t)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span>;</span><br><br>  ASSERT (is_thread (t));<br><br>  old_level = intr_disable ();<br>  ASSERT (t-&gt;status == THREAD_BLOCKED);<br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><br>  <span class="hljs-comment">/*按优先级插入ready队列，以实现优先级唤醒的目的*/</span><br>  list_insert_ordered (&amp;ready_list, &amp;cur-&gt;elem, (list_less_func *) &amp;thread_cmp_priority, <span class="hljs-literal">NULL</span>);<br><br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  t-&gt;status = THREAD_READY;<br>  intr_set_level (old_level);<br>}<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">thread_yield</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">cur</span> =</span> thread_current ();<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span>;</span><br><br>  ASSERT (!intr_context ());<br><br>  old_level = intr_disable ();<br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br>  <span class="hljs-keyword">if</span> (cur != idle_thread)<br>    list_insert_ordered (&amp;ready_list, &amp;cur-&gt;elem, (list_less_func *) &amp;thread_cmp_priority, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  cur-&gt;status = THREAD_READY;<br>  schedule ();<br>  intr_set_level (old_level);<br>}<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">thread_init</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  ASSERT (intr_get_level () == INTR_OFF);<br><br>  lock_init (&amp;tid_lock);<br>  list_init (&amp;ready_list);<br>  list_init (&amp;all_list);<br><br>  <span class="hljs-comment">/* Set up a thread structure for the running thread. */</span><br>  initial_thread = running_thread ();<br>  init_thread (initial_thread, <span class="hljs-string">"main"</span>, PRI_DEFAULT);<br>  initial_thread-&gt;status = THREAD_RUNNING;<br>  initial_thread-&gt;tid = allocate_tid ();<br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br>  initial_thread-&gt;sleepticks = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>}<br><br><br><span class="hljs-comment">/*########################## thread.h ###########################*/</span><br><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><span class="hljs-type">void</span> <span class="hljs-title function_">check_and_unblock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* t, <span class="hljs-type">void</span>*aux UNUSED)</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">thread_cmp_priority</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem *a, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem *b, <span class="hljs-type">void</span> *aux UNUSED)</span>;<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br></code></pre></td></tr></tbody></table></figure>
<hr>
<h4 id="task2-priority"><a class="markdownIt-Anchor" href="#task2-priority"></a> Task2: priority</h4>
<p>先来看看清单</p>
<figure class="highlight elixir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-number">0</span><span class="hljs-symbol">:priority-change</span><br><span class="hljs-number">1</span><span class="hljs-symbol">:priority-donate-one</span><br><span class="hljs-number">2</span><span class="hljs-symbol">:priority-donate-multiple</span><br><span class="hljs-number">3</span><span class="hljs-symbol">:priority-donate-multiple2</span><br><span class="hljs-number">4</span><span class="hljs-symbol">:priority-donate-nest</span><br><span class="hljs-number">5</span><span class="hljs-symbol">:priority-donate-sema</span><br><span class="hljs-number">6</span><span class="hljs-symbol">:priority-donate-lower</span><br><span class="hljs-number">7</span><span class="hljs-symbol">:priority-donate-chain</span><br><span class="hljs-number">8</span><span class="hljs-symbol">:priority-fifo</span><br><span class="hljs-number">9</span><span class="hljs-symbol">:priority-preempt</span><br><span class="hljs-number">10</span><span class="hljs-symbol">:priority-sema</span><br><span class="hljs-number">11</span><span class="hljs-symbol">:priority-condvar</span><br></code></pre></td></tr></tbody></table></figure>
<p>先做0、8、9，都是和抢占相关</p>
<p>在做10、11，都和进程同步互斥相关</p>
<p>最后做1-7，都是关于priority-donate的</p>
<hr>
<h5 id="分析priority-change-fifo-preempt"><a class="markdownIt-Anchor" href="#分析priority-change-fifo-preempt"></a> 分析：Priority change, fifo, preempt</h5>
<p>这3个任务点都和抢占相关，需要注意以下3点：</p>
<ol>
<li>进程创建之初，若优先级高于running thread时，应当抢占。</li>
<li>当优先级改变在改变优先级之后，若优先级高于running thread的优先级，就抢占。</li>
<li>进程优先级相同时，要保证先进先出。</li>
</ol>
<p>对于抢占，只需要调用thread_yield即可，因为在alarm当中我们已经将thread_yield实现为优先级插入了。先进先出则时list_insert_ordered的所保证的，当它在插入时，如果优先级相同时，先来的会在后来的之前。</p>
<hr>
<h5 id="实现priority-change-fifo-preempt"><a class="markdownIt-Anchor" href="#实现priority-change-fifo-preempt"></a> 实现：Priority change, fifo, preempt</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">tid_t</span> <span class="hljs-title function_">thread_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> priority, thread_func* function, <span class="hljs-type">void</span>* aux)</span> {<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span>* <span class="hljs-title">t</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kernel_thread_frame</span>* <span class="hljs-title">kf</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">switch_entry_frame</span>* <span class="hljs-title">ef</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">switch_threads_frame</span>* <span class="hljs-title">sf</span>;</span><br>  <span class="hljs-type">tid_t</span> tid;<br><br>  ASSERT(function != <span class="hljs-literal">NULL</span>);<br><br>  <span class="hljs-comment">/* Allocate thread. */</span><br>  t = palloc_get_page(PAL_ZERO);<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> TID_ERROR;<br><br>  <span class="hljs-comment">/* Initialize thread. */</span><br>  init_thread(t, name, priority);<br>  tid = t-&gt;tid = allocate_tid();<br><br>  <span class="hljs-comment">/* Stack frame for kernel_thread(). */</span><br>  kf = alloc_frame(t, <span class="hljs-keyword">sizeof</span> *kf);<br>  kf-&gt;eip = <span class="hljs-literal">NULL</span>;<br>  kf-&gt;function = function;<br>  kf-&gt;aux = aux;<br><br>  <span class="hljs-comment">/* Stack frame for switch_entry(). */</span><br>  ef = alloc_frame(t, <span class="hljs-keyword">sizeof</span> *ef);<br>  ef-&gt;eip = (<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>))kernel_thread;<br><br>  <span class="hljs-comment">/* Stack frame for switch_threads(). */</span><br>  sf = alloc_frame(t, <span class="hljs-keyword">sizeof</span> *sf);<br>  sf-&gt;eip = switch_entry;<br>  sf-&gt;ebp = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/* Add to run queue. */</span><br>  thread_unblock(t);<br><br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br>  <span class="hljs-keyword">if</span> (thread_current()-&gt;priority &lt; priority)<br>  {<br>    thread_yield();<br>  }<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br>  <span class="hljs-keyword">return</span> tid;<br>}<br><br><br><span class="hljs-comment">/* Sets the current thread's priority to NEW_PRIORITY. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">thread_set_priority</span><span class="hljs-params">(<span class="hljs-type">int</span> new_priority)</span> { <br>  thread_current()-&gt;priority = new_priority; <br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br>  thread_yield();  <br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>}<br></code></pre></td></tr></tbody></table></figure>
<p>解决测试0后，会发现，测试8、9也pass了，为了节省篇幅，就不放测试8、9的源码。</p>
<p>简单解释一下8、9测试的主要过程。</p>
<p>8-priority-fifo：该测试程序事实上就是创建了16个优先级相同的进程，看优先级相同的进程是否为先进先出。这个能够通过，主要还是因为insert_list_ordered函数，本身就有这样的功能。</p>
<p>9-priority-preempt：该程序在创建时，指定了比主进程高1级的优先级，因此创建后，就立马执行了。然后每次thread_yield，运行过程：调度[thread_yield(将当前线程插到最后)-&gt;schedule(将下一线程丢出，并切换到下一线程)]。可以看到，每次yield由于thread的优先级高于主进程，因此主进程在该进程执行完，是不会得到运行的。因此得到的结果是，主线程最后才执行。</p>
<hr>
<h5 id="分析priority-sema-convar"><a class="markdownIt-Anchor" href="#分析priority-sema-convar"></a> 分析：Priority sema, convar</h5>
<p>而我们实际上的输出，是没有“Thread priority xx woke up.”这类语句。原因在于，sema_up没有做线程切换的操作，自然没有使得主线程被抢占，让主线程一直进行到底。此外，sema的waiters队列还得该是一个优先级队列，这个从函数名字test_priority_sema就可以看出来，这sema_up的唤醒顺序应当是按优先级来的。</p>
<p>test_priority_convar也是同样的道理，它只是要实现优先级唤醒而已。</p>
<h5 id="实现priority-sema-convar"><a class="markdownIt-Anchor" href="#实现priority-sema-convar"></a> 实现：Priority sema, convar</h5>
<p>实现部分如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*########################## synch.c ###########################*/</span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">sema_down</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sema)</span> <br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span>;</span><br><br>  ASSERT (sema != <span class="hljs-literal">NULL</span>);<br>  ASSERT (!intr_context ());<br><br>  old_level = intr_disable ();<br>  <span class="hljs-keyword">while</span> (sema-&gt;value == <span class="hljs-number">0</span>) <br>    {<br>    <span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br>      list_insert_ordered (&amp;sema-&gt;waiters, &amp;thread_current ()-&gt;elem, thread_cmp_priority, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br>      thread_block ();<br>    }<br>  sema-&gt;value--;<br>  intr_set_level (old_level);<br>}<br><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">sema_up</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sema)</span> <br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span>;</span><br><br>  ASSERT (sema != <span class="hljs-literal">NULL</span>);<br><br>  old_level = intr_disable ();<br>  <span class="hljs-keyword">if</span> (!list_empty (&amp;sema-&gt;waiters))<br>  { <br>    thread_unblock (list_entry (list_pop_front (&amp;sema-&gt;waiters),<br>                                <span class="hljs-keyword">struct</span> thread, elem));<br>  }<br>  sema-&gt;value++;<br>  <span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br>  thread_yield();<br>  <span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br>  intr_set_level (old_level);<br>}<br><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">cond_signal</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> condition *cond, <span class="hljs-keyword">struct</span> lock *lock UNUSED)</span> <br>{<br>  ASSERT (cond != <span class="hljs-literal">NULL</span>);<br>  ASSERT (lock != <span class="hljs-literal">NULL</span>);<br>  ASSERT (!intr_context ());<br>  ASSERT (lock_held_by_current_thread (lock));<br><br>  <span class="hljs-keyword">if</span> (!list_empty (&amp;cond-&gt;waiters)){<br>    <span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br>    list_sort(&amp;cond-&gt;waiters, cond_cmp_priority, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br>    sema_up (&amp;list_entry (list_pop_front (&amp;cond-&gt;waiters),<br>                          <span class="hljs-keyword">struct</span> semaphore_elem, elem)-&gt;semaphore);<br>  }<br>}<br><br><br><span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br><span class="hljs-type">bool</span><br><span class="hljs-title function_">cond_cmp_priority</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem *a, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem *b, <span class="hljs-type">void</span> *aux UNUSED)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore_elem</span> *<span class="hljs-title">sa</span> =</span> list_entry (a, <span class="hljs-keyword">struct</span> semaphore_elem, elem);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore_elem</span> *<span class="hljs-title">sb</span> =</span> list_entry (b, <span class="hljs-keyword">struct</span> semaphore_elem, elem);<br>  <span class="hljs-keyword">return</span> list_entry(list_front(&amp;sa-&gt;semaphore.waiters), <span class="hljs-keyword">struct</span> thread, elem)-&gt;priority &gt; list_entry(list_front(&amp;sb-&gt;semaphore.waiters), <span class="hljs-keyword">struct</span> thread, elem)-&gt;priority;<br>}   <br><span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br><br></code></pre></td></tr></tbody></table></figure>
<hr>
<h5 id="分析priority-donate"><a class="markdownIt-Anchor" href="#分析priority-donate"></a> 分析：Priority  donate</h5>
<p>优先级捐赠往往是为了防止<strong>优先级反置</strong>而设置的。</p>
<p>举个例子：有3个线程——老大、老二和老三。根据优先级调度的规则，先执行的是老大，但是老大的执行需要老三提供相应的资源（在程序中可能体现的是老三占有了某资源的锁），因此老大被阻塞。但由于优先级调度的规则，老二先执行。然后再是老三，老三释放锁后，老大才能执行。可以看到，老大作为最高优先级的线程，却最后才完成（<strong>优先级反置</strong>）。有个解决方法是，老大将自己的优先级捐赠给老三，这样老三就能先于老二执行，老三释放锁后，老大就能执行了。</p>
<p>明确思路与需求：</p>
<p>线程之间直接捐赠的程序设计，比较复杂，不好维护。通过阅读别人的代码，我发现，原来可以<strong>利用锁间接地捐赠优先级</strong>。考虑如下两种特殊情况：</p>
<ul>
<li>
<p><strong>多重捐赠</strong>：一个线程占有多个锁，而者些资源又为其他高优先级的资源锁需要。如下图所示，31线程有2个锁，而分别被32、33、34锁需要，其中一个锁又被2个线程需要。<strong>绿线</strong>表示已占用（<strong>held</strong>），<strong>红线</strong>表示正在申请（<strong>applying</strong>）。</p>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/task2_pic1.png)</p>
<ul>
<li>
<p>思路：每一个线程可以维护一个锁的链表，表示这个线程所占有的所有锁。而后，每个锁可能被多个进程锁需要，我们可以将让锁携带这些进程的最大优先级，然后传递给低优先级。然后再释放一个锁后，要重新更新优先级，以保持从锁中获取同样的操作。下图描述了整个过程。可以发现，在获得锁的时候做了两件事：**1. 获得持有该锁进程的最大优先级；2. 向低优先级线程传递所有锁中的最大优先级。**而在释放锁的时候，则做了这样两件事：<strong>1. 使锁的优先级为最小。2. 对锁持有者的优先级进行更新，方法和上述一样，从该线程占有的所有锁中取最大的优先级。</strong></p>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/task2_pic2.png)</p>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/task2_pic3.png)</p>
</li>
</ul>
</li>
<li>
<p><strong>递归捐赠</strong>：线程之间资源占用情况形成链状，如下图所示。那么33线程的优先级将沿着这条链一直捐到底</p>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/task2_pic4.png)</p>
<ul>
<li>
<p>思路：对于这种情况，就让优先级顺着锁往下传递。如下图所示。</p>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/task2_pic5.png)</p>
</li>
</ul>
</li>
</ul>
<h5 id="实现priority-donate"><a class="markdownIt-Anchor" href="#实现priority-donate"></a> 实现：Priority  donate</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*########################## thread.h ###########################*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span></span><br><span class="hljs-class">  {</span><br>    <span class="hljs-comment">/* Owned by thread.c. */</span><br>    <span class="hljs-type">tid_t</span> tid;                          <span class="hljs-comment">/* Thread identifier. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">thread_status</span> <span class="hljs-title">status</span>;</span>          <span class="hljs-comment">/* Thread state. */</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">16</span>];                      <span class="hljs-comment">/* Name (for debugging purposes). */</span><br>    <span class="hljs-type">uint8_t</span> *<span class="hljs-built_in">stack</span>;                     <span class="hljs-comment">/* Saved stack pointer. */</span><br>    <span class="hljs-type">int</span> priority;                       <span class="hljs-comment">/* Priority. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> <span class="hljs-title">allelem</span>;</span>           <span class="hljs-comment">/* List element for all threads list. */</span><br><br>    <span class="hljs-comment">/* Shared between thread.c and synch.c. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> <span class="hljs-title">elem</span>;</span>              <span class="hljs-comment">/* List element. */</span><br>	<br>    <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><br>    <span class="hljs-type">int</span> sleepticks;						<span class="hljs-comment">/* 剩余休眠的时间 */</span><br>    <span class="hljs-type">int</span> original_priority;              <span class="hljs-comment">/* 原始优先级 */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> <span class="hljs-title">locks</span>;</span>                  <span class="hljs-comment">/* 占有的锁队列*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span>* <span class="hljs-title">lock_applying</span>;</span>			<span class="hljs-comment">/* 申请中的锁*/</span><br><br>    <span class="hljs-comment">/*--------------------------------------------------------*/</span> <br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USERPROG</span><br>    <span class="hljs-comment">/* Owned by userprog/process.c. */</span><br>    <span class="hljs-type">uint32_t</span> *pagedir;                  <span class="hljs-comment">/* Page directory. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* Owned by thread.c. */</span><br>    <span class="hljs-type">unsigned</span> magic;                     <span class="hljs-comment">/* Detects stack overflow. */</span><br>  };<br><br>    <br><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><span class="hljs-type">void</span> <span class="hljs-title function_">thread_hold_the_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock* lock)</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">lock_cmp_priority</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem* a, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem* b, <span class="hljs-type">void</span>* aux UNUSED)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">remove_lock</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *lock)</span>;<br><span class="hljs-comment">/* 从捐赠者队列中获取最高优先级  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">update_priority</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* t)</span>;<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br><br></code></pre></td></tr></tbody></table></figure>
<hr>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*########################## synch.h ###########################*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> </span><br><span class="hljs-class">  {</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">holder</span>;</span>      <span class="hljs-comment">/* Thread holding lock (for debugging). */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> <span class="hljs-title">semaphore</span>;</span> <span class="hljs-comment">/* Binary semaphore controlling access. */</span><br>    <br>    <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> <span class="hljs-title">elem</span>;</span><br>    <span class="hljs-type">int</span> max_priority;<br>    <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  };<br><br></code></pre></td></tr></tbody></table></figure>
<hr>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*########################## thread.c ###########################*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">init_thread</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> thread *t, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> priority)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span>;</span><br><br>  ASSERT (t != <span class="hljs-literal">NULL</span>);<br>  ASSERT (PRI_MIN &lt;= priority &amp;&amp; priority &lt;= PRI_MAX);<br>  ASSERT (name != <span class="hljs-literal">NULL</span>);<br><br>  <span class="hljs-built_in">memset</span> (t, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> *t);<br>  t-&gt;status = THREAD_BLOCKED;<br>  strlcpy (t-&gt;name, name, <span class="hljs-keyword">sizeof</span> t-&gt;name);<br>  t-&gt;<span class="hljs-built_in">stack</span> = (<span class="hljs-type">uint8_t</span> *) t + PGSIZE;<br>  t-&gt;priority = priority;<br>  t-&gt;magic = THREAD_MAGIC;<br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span>	<br>  t-&gt;sleepticks = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">/* 初始化捐赠队列锁，原始priority，正在申请的锁 */</span><br>  list_init(&amp;t-&gt;locks);<br>  t-&gt;original_priority = priority;<br>  t-&gt;lock_applying = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span>	<br>  old_level = intr_disable ();<br>  list_insert_ordered (&amp;all_list, &amp;t-&gt;allelem, &amp;thread_cmp_priority, <span class="hljs-literal">NULL</span>);<br>  intr_set_level (old_level);<br>}<br><br><br><br><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span>	<br><span class="hljs-comment">/* 比较锁的最大优先级函数 */</span><br><span class="hljs-type">bool</span><br><span class="hljs-title function_">lock_cmp_priority</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem* a, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem* b, <span class="hljs-type">void</span>* aux UNUSED)</span><br>{<br>  <span class="hljs-keyword">return</span> list_entry(a, <span class="hljs-keyword">struct</span> lock, elem)-&gt;max_priority &gt; list_entry(b, <span class="hljs-keyword">struct</span> lock, elem)-&gt;max_priority;	<br>}<br><br><span class="hljs-comment">/* 该函数的作用是让进程拥有该锁，即把锁推入进程的尺有所队列中</span><br><span class="hljs-comment"> * 如果锁的最大优先级比当前进程高，就将锁的优先级捐赠给当前进程</span><br><span class="hljs-comment"> * 并抢占调度。从而实现优先级捐赠。 */</span><br><span class="hljs-type">void</span> <br><span class="hljs-title function_">thread_hold_the_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock* lock)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();<br>  list_push_back(&amp;thread_current()-&gt;locks, &amp;lock-&gt;elem);<br>  <span class="hljs-keyword">if</span>(lock-&gt;max_priority &gt; thread_current()-&gt;priority)<br>  {<br>    thread_current()-&gt;priority = lock-&gt;max_priority;<br>    thread_yield();<br>  }<br>  intr_set_level(old_level);<br>}<br><br><span class="hljs-comment">/* 从将线程持有的锁（如果持有），根据锁的最大优先级从大到小排序。</span><br><span class="hljs-comment"> * 比较锁的最大优先级，选择自己本身优先级和锁的最大优先级中的</span><br><span class="hljs-comment"> * 较大者作为自己的优先级。如果没有锁，自然就回归自己的原始优先</span><br><span class="hljs-comment"> * 级。*/</span> <br><span class="hljs-type">void</span> <br><span class="hljs-title function_">update_priority</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* t)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();<br>  <span class="hljs-type">int</span> lock_priority = PRI_MIN;<br>  <span class="hljs-keyword">if</span>(!list_empty(&amp;t-&gt;locks))<br>  {<br>    list_sort(&amp;t-&gt;locks, lock_cmp_priority, <span class="hljs-literal">NULL</span>);<br>    lock_priority = list_entry(list_front(&amp;t-&gt;locks), <span class="hljs-keyword">struct</span> lock, elem)-&gt;max_priority;<br>  }<br>  t-&gt;priority = (lock_priority &gt; t-&gt;original_priority ? lock_priority:t-&gt;original_priority);<br>  intr_set_level(old_level);<br>}<br>	<br><span class="hljs-comment">/* 将锁从线程的持有锁队列中释放，调用该函数的时机应当是</span><br><span class="hljs-comment"> * 释放锁的时候。  */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">remove_lock</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *lock)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable ();<br>  list_remove (&amp;lock-&gt;elem);<br>  update_priority (thread_current ());<br>  intr_set_level (old_level);<br>}<br><br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br></code></pre></td></tr></tbody></table></figure>
<hr>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*########################## synch.c ###########################*/</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">lock_init</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *lock)</span><br>{<br>  ASSERT (lock != <span class="hljs-literal">NULL</span>);<br><br>  lock-&gt;holder = <span class="hljs-literal">NULL</span>;<br>  sema_init (&amp;lock-&gt;semaphore, <span class="hljs-number">1</span>);<br><br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  lock-&gt;max_priority = PRI_MIN - <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>}<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">lock_acquire</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *lock)</span><br>{<br>  ASSERT (lock != <span class="hljs-literal">NULL</span>);<br>  ASSERT (!intr_context ());<br>  ASSERT (!lock_held_by_current_thread (lock));<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 首先将该锁置于申请中的状态，然后先判断锁是否被占用，</span><br><span class="hljs-comment">   * 1. 如果没人占用它，则无需捐献，跳过这里，与原函数操作相同</span><br><span class="hljs-comment">   * 2. 如果有人占用它，那么首先判断，递归地捐赠优先级。即，</span><br><span class="hljs-comment">   * 如果该占用者的优先级比自己低，那么捐赠优先级；如果被捐赠者</span><br><span class="hljs-comment">   * 也在申请其他锁，那么就给该锁的占用者捐赠优先级，不断下去</span><br><span class="hljs-comment">   * 直至一个进程没有正在申请的锁为止。*/</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span>* <span class="hljs-title">cur_thread</span> =</span> thread_current();<br>  cur_thread-&gt;lock_applying = lock;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span>* <span class="hljs-title">pre_lock</span> =</span> lock;<br>  <span class="hljs-keyword">while</span>(pre_lock != <span class="hljs-literal">NULL</span> &amp;&amp; pre_lock-&gt;holder != <span class="hljs-literal">NULL</span> &amp;&amp; pre_lock-&gt;max_priority &lt; cur_thread-&gt;priority)<br>  {<br>    pre_lock-&gt;max_priority = cur_thread-&gt;priority;<br>    update_priority(pre_lock-&gt;holder);<br>    pre_lock = pre_lock-&gt;holder-&gt;lock_applying;<br><br>  }<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  sema_down (&amp;lock-&gt;semaphore);<br>  lock-&gt;holder = thread_current ();<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 若成功获得该锁，那么该进程就没有正在申请的锁，归0</span><br><span class="hljs-comment">   * 并且在申请成功后，该锁的最大优先级显然和该进程相同。</span><br><span class="hljs-comment">   * 并将该锁推入进程的locks队列中，表示该锁已被得到 */</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();<br>  cur_thread-&gt;lock_applying = <span class="hljs-literal">NULL</span>;<br>  lock-&gt;max_priority = cur_thread-&gt;priority;<br>  thread_hold_the_lock(lock);<br>  intr_set_level(old_level);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>}<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">lock_release</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *lock)</span> <br>{<br>  ASSERT (lock != <span class="hljs-literal">NULL</span>);<br>  ASSERT (lock_held_by_current_thread (lock));<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 结束后，将其从线程锁列表中释放，并将最大优先级归0 */</span><br>  remove_lock(lock);<br>  lock-&gt;max_priority = PRI_MIN<span class="hljs-number">-1</span>;<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br>  lock-&gt;holder = <span class="hljs-literal">NULL</span>;<br>  sema_up (&amp;lock-&gt;semaphore);<br>}<br><br><br></code></pre></td></tr></tbody></table></figure>
<hr>
<h4 id="task3-mlfqs"><a class="markdownIt-Anchor" href="#task3-mlfqs"></a> Task3: mlfqs</h4>
<h5 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h5>
<p>多级反馈队列调度。具体内容参考手册P91</p>
<p>我稍微说明以下要点：</p>
<ol>
<li>
<p>三大公式：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">priority = PRI_MAX - (recent_cpu / <span class="hljs-number">4</span>) - (nice * <span class="hljs-number">2</span>),<br>recent_cpu = (<span class="hljs-number">2</span>*load_avg)/(<span class="hljs-number">2</span>*load_avg + <span class="hljs-number">1</span>) * recent_cpu + nice<br>load_avg = (<span class="hljs-number">59</span>/<span class="hljs-number">60</span>)*load_avg + (<span class="hljs-number">1</span>/<span class="hljs-number">60</span>)*ready_threads<br></code></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>三个更新时间：</p>
<ol>
<li>recent_cpu: 每个tick后+1，且每秒也就是每TIMER_FREQ个ticks根据公式更新一次，线程成员变量</li>
<li>load_avg: 每秒也就是每TIMER_FREQ个ticks根据公式更新一次，初始值为0，全局变量</li>
<li>priority: 每4个tick更新一次。范围应限制在PRI_MIN到PRI_MAX内</li>
</ol>
</li>
</ol>
<p>优先级、load_avg等计算都是实数计算，但pintos不支持。如下图所示，是手册给予的顶点实数计算公式。可以看到，定点实数的取整、乘法、除法是需要重新定义的，而其他与整数运算相同。我们只需要加个头文件，对这些需要重新定义的计算进行宏定义即可。</p>
<h5 id="实现-2"><a class="markdownIt-Anchor" href="#实现-2"></a> 实现</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*########################## fixed_point.c ###########################*/</span><br><span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br><span class="hljs-comment">/* 定点实数计算</span><br><span class="hljs-comment"> * 我们将后14为定义为小数</span><br><span class="hljs-comment"> * 因此当整数转化为小数时，直接左移14位即可，反之，同理</span><br><span class="hljs-comment"> * 然后定点实数的加减运算不需要重新定义，与整数保持一致</span><br><span class="hljs-comment"> * 乘法，则只要两数相乘最后再14位即可</span><br><span class="hljs-comment"> * 除法，对于定点实数除法，也需要被除数先左移14位再除</span><br><span class="hljs-comment"> * 对于实数转整数，则有直接截尾和四舍五入两种方式  */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> FIXED_POINT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIXED_POINT_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Q 14</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> F (1 &lt;&lt; Q)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT_TO_FP(n) ((n) &lt;&lt; Q)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FP_TO_INT(x) ((x) &gt;&gt; Q)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FP_TO_ROUND_INT(x) ((x) &gt;= 0  ? FP_TO_INT((x) + (F &gt;&gt; 1)) : \</span><br><span class="hljs-meta">		                              FP_TO_INT((x) - (F &gt;&gt; 1)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FP_MUL(x, y) ((int) ((((int64_t) (x)) * (y)) &gt;&gt; Q))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FP_DIV(x, y) ((int) ((((int64_t) (x)) &lt;&lt; Q) / (y)))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><br><br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br><br><span class="hljs-comment">/* 记得在thread.c, timer.c下添加该头文件 */</span><br><span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"threads/fixed_point.h"</span></span><br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br></code></pre></td></tr></tbody></table></figure>
<p>根据上述的归纳我们可以将更新部分的骨架(skeleton)给写了</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">timer_interrupt</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame *args UNUSED)</span><br>{<br>  ticks++;<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  thread_foreach (check_and_unblock, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-comment">/* 针对mlfqs任务  */</span><br>  <span class="hljs-keyword">if</span>(thread_mlfqs)<br>  {<br>    <span class="hljs-comment">/* 每个tick，正在执行进程的recent_cpu++。</span><br><span class="hljs-comment">     * 空闲进程无需计算recent_cpu */</span><br>    <span class="hljs-keyword">if</span>(!is_idle_thread(thread_current()))<br>      thread_current()-&gt;recent_cpu += INT_TO_FP(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">/* 每秒种计算一次load_avg以及recent_cpu</span><br><span class="hljs-comment">     * 每4个ticks(其实就是时间片长度)更新一次priority */</span><br>    <span class="hljs-keyword">if</span>(ticks % TIMER_FREQ == <span class="hljs-number">0</span>)<br>    {<br>      calculate_mlfqs_load_avg();<br>      update_mlfqs_recent_cpu();<br>      update_mlfqs_priority();<br>    }<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ticks % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>)<br>    {<br>      update_mlfqs_priority_aux(thread_current(), <span class="hljs-literal">NULL</span>);<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">      用于调试</span><br><span class="hljs-comment">      msg("load_avg %d",thread_get_load_avg());</span><br><span class="hljs-comment">      msg("priority: %d", thread_current()-&gt;priority);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      msg("tid: %d", thread_current()-&gt;tid);</span><br><span class="hljs-comment">      msg("recent_cp %d", thread_current()-&gt;recent_cpu);</span><br><span class="hljs-comment">      */</span><br>    }  <br>  }<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  thread_tick ();<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>然后具体对更新recent_cpu、load_avg、priority进行实现。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br><span class="hljs-comment">/* 判断是否为空闲程序  */</span><br><span class="hljs-type">bool</span><br><span class="hljs-title function_">is_idle_thread</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* t)</span><br>{<br>  <span class="hljs-keyword">return</span> t == idle_thread;<br>}<br><br><span class="hljs-comment">/* 计算loag_avg函数 */</span><br><span class="hljs-type">void</span> <br><span class="hljs-title function_">calculate_mlfqs_load_avg</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();<br>  <span class="hljs-type">int</span> ready_threads = list_size(&amp;ready_list) +(thread_current() != idle_thread);<br>  load_avg = FP_MUL(INT_TO_FP(<span class="hljs-number">59</span>) / <span class="hljs-number">60</span>, load_avg) + INT_TO_FP(<span class="hljs-number">1</span>) / <span class="hljs-number">60</span> * ready_threads;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  用于调试：</span><br><span class="hljs-comment">  msg("ready_threads %d", ready_threads);</span><br><span class="hljs-comment">  msg("load_avg %d", load_avg);</span><br><span class="hljs-comment">  msg("load_avg %d", thread_get_load_avg());</span><br><span class="hljs-comment">  msg("idle %d", idle_thread-&gt;priority);</span><br><span class="hljs-comment">  */</span><br>  intr_set_level(old_level);<br>}<br><br><span class="hljs-comment">/* 更新recent_cpu接口 */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">update_mlfqs_recent_cpu_aux</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* t, <span class="hljs-type">void</span>* aux UNUSED)</span><br>{<br>  <span class="hljs-keyword">if</span>(is_idle_thread(t))<br>    <span class="hljs-keyword">return</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();<br>  <br>  t-&gt;recent_cpu = FP_MUL(FP_DIV(load_avg * <span class="hljs-number">2</span>, load_avg * <span class="hljs-number">2</span> + INT_TO_FP(<span class="hljs-number">1</span>)), t-&gt;recent_cpu) + INT_TO_FP(t-&gt;nice);<br><br>  intr_set_level(old_level);<br>}<br><br><span class="hljs-comment">/* 调用更新recent_cpu接口对每个线程recent_cpu更新 */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">update_mlfqs_recent_cpu</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  thread_foreach (update_mlfqs_recent_cpu_aux, <span class="hljs-literal">NULL</span>);<br>}<br><br><span class="hljs-comment">/* 优先级更新接口 */</span><br><span class="hljs-type">void</span> <br><span class="hljs-title function_">update_mlfqs_priority_aux</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* t, <span class="hljs-type">void</span>* aux UNUSED)</span><br>{<br><br>  <span class="hljs-keyword">if</span>(is_idle_thread(t))<br>    <span class="hljs-keyword">return</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();<br><br>  t-&gt;priority = (FP_TO_INT(INT_TO_FP(PRI_MAX) - t-&gt;recent_cpu / <span class="hljs-number">4</span> - INT_TO_FP(t-&gt;nice * <span class="hljs-number">2</span>)));<br>  t-&gt;priority = t-&gt;priority &lt; PRI_MIN ? PRI_MIN : t-&gt;priority;<br>  t-&gt;priority = t-&gt;priority &gt; PRI_MAX ? PRI_MAX : t-&gt;priority;<br><br>  intr_set_level(old_level);<br>}<br><br><span class="hljs-comment">/* 调用更新优先级接口对每个线程优先级更新 */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">update_mlfqs_priority</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  thread_foreach (update_mlfqs_priority_aux, <span class="hljs-literal">NULL</span>);<br>}<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br></code></pre></td></tr></tbody></table></figure>
<p>当然，原来的代码中是没有load_avg、nice、recent_cpu。load_avg是全局变量，而nice、recent_cpu则处于线程。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NICE_MIN -20 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NICE_MAX 20</span><br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br><span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> load_avg;<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br><span class="hljs-comment">/* struct thread 中添加 */</span><br>    <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><br>    <span class="hljs-type">int</span> nice;<br>    <span class="hljs-type">int</span> recent_cpu;<br><br>    <span class="hljs-comment">/*--------------------------------------------------------*/</span> <br><br></code></pre></td></tr></tbody></table></figure>
<p>此外题目还要求我们实现，thread_set_nice、thread_get_nice、thread_get_load_avg、thread_get_recent_cpu。他们已经为我们准备好了骨架。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span>	<br><span class="hljs-comment">/* Sets the current thread's nice value to NICE. */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">thread_set_nice</span> <span class="hljs-params">(<span class="hljs-type">int</span> nice)</span> <br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span>;</span><br>  old_level = intr_disable ();<br><br>  nice = (nice &gt; NICE_MAX ? : NICE_MAX, nice);<br>  nice = (nice &lt; NICE_MIN ? : NICE_MIN, nice);<br>          <br>  thread_current ()-&gt;nice = nice;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  调试用</span><br><span class="hljs-comment">  msg("tid: %d nice: %d", thread_current()-&gt;tid , nice);</span><br><span class="hljs-comment">  */</span><br>  update_mlfqs_priority_aux (thread_current (), <span class="hljs-literal">NULL</span>);<br>  thread_yield();<br>  <br>  intr_set_level (old_level);<br>}<br><br><span class="hljs-comment">/* Returns the current thread's nice value. */</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">thread_get_nice</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>{<br>  <span class="hljs-keyword">return</span> thread_current ()-&gt;nice;<br>}<br><br><span class="hljs-comment">/* Returns 100 times the system load average. */</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">thread_get_load_avg</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>{<br>  <br>  <span class="hljs-keyword">return</span> FP_TO_ROUND_INT(load_avg * <span class="hljs-number">100</span>);<br>}<br><br><span class="hljs-comment">/* Returns 100 times the current thread's recent_cpu value. */</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">thread_get_recent_cpu</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>{<br>  <span class="hljs-keyword">return</span> FP_TO_ROUND_INT(thread_current ()-&gt;recent_cpu * <span class="hljs-number">100</span>);<br><br>}<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br></code></pre></td></tr></tbody></table></figure>
<p>然后为了这道题目，**需要对第二题做必要的修改。**这将在Q&amp;A中提到。</p>
<h4 id="qa-2"><a class="markdownIt-Anchor" href="#qa-2"></a> Q&amp;A</h4>
<ul>
<li>
<p><strong>Q1：原本的实现思路是开辟一个新的sleep_queue去完成代码，但实现过程中出现诸多麻烦。</strong></p>
<ul>
<li>Answer：发现函数中有thread_foreach，这是为all_list量身定制的，那么为何不用all_list+标志位实现阻塞队列呢？</li>
</ul>
</li>
<li>
<p><strong>Q2：在实现任务4、任务5时出现死机的现象</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">timer_sleep</span> <span class="hljs-params">(<span class="hljs-type">int64_t</span> ticks)</span><br>{<br>  <span class="hljs-type">int64_t</span> start = timer_ticks ();<br><br>  ASSERT (intr_get_level () == INTR_ON);<br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br>  <span class="hljs-comment">/* 关闭中断，基操 */</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();<br>  <br>  <span class="hljs-comment">/* 获取当前线程，并存入休眠时间，阻塞进程 */</span><br>   thread_current() -&gt; sleepticks = ticks;<br>   thread_block();<br>    <br>  intr_set_level(old_level);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>}<br><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">check_and_unblock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* t, <span class="hljs-type">void</span>*aux UNUSED)</span><br>{<br>    t-&gt;sleepticks --;<br>    <span class="hljs-keyword">if</span> (t-&gt;sleepticks == <span class="hljs-number">0</span>) <span class="hljs-comment">// ==0? wrong</span><br>    {<br>      thread_unblock(t);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p>Answer: 原因是因为，当thread_current的休眠时间为0甚至为负数时，它仍然会阻塞，而check_and_unblock的代码中，由于t-&gt;sleepticks --，因此t-&gt;sleepticks == 0永远都无法实现，进程永远被阻塞。改进代码如下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">timer_sleep</span> <span class="hljs-params">(<span class="hljs-type">int64_t</span> ticks)</span><br>{  <br>    <span class="hljs-type">int64_t</span> start = timer_ticks ();<br>    ASSERT (intr_get_level () == INTR_ON);  <br>    <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span>   <br>    <span class="hljs-comment">/* 关闭中断，基操 */</span>  <br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();    <br>    <span class="hljs-comment">/* 获取当前线程，并存入休眠时间，阻塞进程, 注意如果ticks&lt;=0则无需阻塞*/</span>       <br>    <span class="hljs-keyword">if</span>(ticks &gt; <span class="hljs-number">0</span>)   <br>    {     <br>        thread_current() -&gt; sleepticks = ticks;     <br>        thread_block();   <br>    }      <br>    intr_set_level(old_level);  <br>    <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>}<br><span class="hljs-type">void</span><br><span class="hljs-title function_">check_and_unblock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* t, <span class="hljs-type">void</span>*aux UNUSED)</span><br>{  <br>  <span class="hljs-comment">/* 如果它本身没被阻塞，其实也就没必要去unblock了，小于0什么的根本不会被  阻塞，更无需讨论 */</span>  <br>  <span class="hljs-keyword">if</span> (t-&gt;status == THREAD_BLOCKED &amp;&amp; t-&gt;sleepticks &gt; <span class="hljs-number">0</span>)  <br>  {    <br>    t-&gt;sleepticks --;    <br>    <span class="hljs-keyword">if</span> (t-&gt;sleepticks &lt;= <span class="hljs-number">0</span>)    <br>    {      <br>      thread_unblock(t);    <br>     }  <br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>Q3：在实现priority condvar时，原本是和sema等一样，在插入时实现优先级排序。但会报错。</strong></p>
<ul>
<li>Answer：</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br><span class="hljs-type">bool</span><br><span class="hljs-title function_">cond_cmp_priority</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem *a, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem *b, <span class="hljs-type">void</span> *aux UNUSED)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore_elem</span> *<span class="hljs-title">sa</span> =</span> list_entry (a, <span class="hljs-keyword">struct</span> semaphore_elem, elem);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore_elem</span> *<span class="hljs-title">sb</span> =</span> list_entry (b, <span class="hljs-keyword">struct</span> semaphore_elem, elem);<br>  <span class="hljs-keyword">return</span> list_entry(list_front(&amp;sa-&gt;semaphore.waiters), <span class="hljs-keyword">struct</span> thread, elem)-&gt;priority &gt; list_entry(list_front(&amp;sb-&gt;semaphore.waiters), <span class="hljs-keyword">struct</span> thread, elem)-&gt;priority;<br>}   <br><span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">cond_wait</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> condition *cond, <span class="hljs-keyword">struct</span> lock *lock)</span> <br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore_elem</span> <span class="hljs-title">waiter</span>;</span><br><br>  ASSERT (cond != <span class="hljs-literal">NULL</span>);<br>  ASSERT (lock != <span class="hljs-literal">NULL</span>);<br>  ASSERT (!intr_context ());<br>  ASSERT (lock_held_by_current_thread (lock));<br>  <br>  sema_init (&amp;waiter.semaphore, <span class="hljs-number">0</span>);<br>  list_push_back (&amp;cond-&gt;waiters, &amp;waiter.elem);<br>  lock_release (lock);<br>  sema_down (&amp;waiter.semaphore);<br>  lock_acquire (lock);<br>}<br><br><br><br></code></pre></td></tr></tbody></table></figure>
<p>从代码中可以看到，倘若将push_back改为insert_order，比较函数是比较semaphore的waiter中第一个线程的priority，而此时还未经sema_down，waiter中是空的，没有线程。因此会引发错误。那是否可以将插入放在sema_down之后呢？显然也不行，sema_down会将当前线程阻塞，插入操作无法立即执行。一个解决方法是，<strong>我们在sema_up的时候的对线程进行排序也是可以的</strong>。</p>
</li>
<li>
<p><strong>Q4：写完project1后，测试userprog会出现这样的错误。而这在完成project1之前是不会出现这样的现象的。</strong></p>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/task2_Q2.png)</p>
<ul>
<li>Answer: stack overflow上也有人碰到了类似的问题，参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/52472084/pintos-userprog-all-tests-fail-is-kernel-vaddr%E3%80%82">https://stackoverflow.com/questions/52472084/pintos-userprog-all-tests-fail-is-kernel-vaddr。</a></li>
</ul>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/schedule_before_thread_start.png)<br>
如上图所示，这是在init.c中，userprog任务调用的tss_init函数，根据调用关系，我们看到，它调用了lock_release函数函数，而在我们上述代码的实现里，lock_release调用了thread_yield，而此时还未调用thread_start对线程进行必要的初始化，不可以启用调度。因此解决方法是设一个标志位，在thread_start之前不要启用lock_release的thread_yield。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在thread.c中添加</span><br><span class="hljs-comment">/* 这一标志位是为了防止userprog在thread初始化前调度 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">bool</span> thread_started;<br><span class="hljs-comment">/* 判断线程是否开始  */</span><br><span class="hljs-type">bool</span> <br><span class="hljs-title function_">is_thread_started</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{<br>  <span class="hljs-keyword">return</span> thread_started;<br>}<br><span class="hljs-comment">// 在thread.h中声明</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">is_thread_started</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-comment">// 在synch.c的sema_up中添加 </span><br><span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br><span class="hljs-keyword">if</span> (is_thread_started())<br>{<br>  thread_yield();<br>}<br><br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br></code></pre></td></tr></tbody></table></figure>
<p>你以为这样就完了吗？并没有，我解决掉这个问题后，又会报这样的错误：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">../../threads/thread.c:495 in thread_yield(): assertion `!intr_context ()' failed.<br></code></pre></td></tr></tbody></table></figure>
<p>这又是什么鬼呢？使用gdb经过调试后发现，在初始化的时候sema_up会被内部中断调用，虽然我不知道具体原因，但只能说，sema_up里面压根就不能放thread_yield。而实际上，这一题的thread_yield完全可以放在lock_release里头。以下是最终的修改。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 把以下内容添加至lock_release结尾，并删除sema_up中的相应内容。</span><br><span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br><span class="hljs-keyword">if</span> (is_thread_started())<br>{<br>  thread_yield();<br>}<br><br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>Q5：以下这三个测试点是相当玄幻的。</strong></p>
<figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">tests<span class="hljs-regexp">/threads/m</span>lfqs-load-<span class="hljs-number">60</span><br>tests<span class="hljs-regexp">/threads/m</span>lfqs-load-avg<br>tests<span class="hljs-regexp">/threads/m</span>lfqs-recent-<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p>Answer:</p>
<p>第一种情况，本地压根就没通过。mlfqs-load-avg大部分都不太满足，第一是看你的公式对不对，如果公式无误甚至非常完美，那么就要考虑对第二题所有的在获得锁时添加的代码，设置为thread_mlfqs不可见，如下。同理，<strong>在释放锁时也要做相应设置。</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br><span class="hljs-comment">/* 首先将该锁置于申请中的状态，然后先判断锁是否被占用，</span><br><span class="hljs-comment"> * 1. 如果没人占用它，则无需捐献，跳过这里，与原函数操作相同</span><br><span class="hljs-comment"> * 2. 如果有人占用它，那么首先判断，递归地捐赠优先级。即，</span><br><span class="hljs-comment"> * 如果该占用者的优先级比自己低，那么捐赠优先级；如果被捐赠者</span><br><span class="hljs-comment"> * 也在申请其他锁，那么就给该锁的占用者捐赠优先级，不断下去</span><br><span class="hljs-comment"> * 直至一个进程没有正在申请的锁为止。*/</span><br><span class="hljs-keyword">if</span>(!thread_mlfqs)<br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span>* <span class="hljs-title">cur_thread</span> =</span> thread_current();<br>  cur_thread-&gt;lock_applying = lock;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span>* <span class="hljs-title">pre_lock</span> =</span> lock<br>  <span class="hljs-title function_">while</span><span class="hljs-params">(pre_lock != <span class="hljs-literal">NULL</span> &amp;&amp; pre_lock-&gt;holder != <span class="hljs-literal">NULL</span> &amp;&amp; pre_lock-&gt;max_priority &lt; cur_thread-&gt;priority)</span><br>  {<br>    pre_lock-&gt;max_priority = cur_thread-&gt;priority;<br>    update_priority(pre_lock-&gt;holder);<br>    pre_lock = pre_lock-&gt;holder-&gt;lock_applying;<br>  }<br>}<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br>    <br><span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br><span class="hljs-comment">/* 若成功获得该锁，那么该进程就没有正在申请的锁，归0</span><br><span class="hljs-comment"> * 并且在申请成功后，该锁的最大优先级显然和该进程相同。</span><br><span class="hljs-comment"> * 并将该锁推入进程的locks队列中，表示该锁已被得到 */</span><br><span class="hljs-keyword">if</span>(!thread_mlfqs)<br>{<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span>* <span class="hljs-title">cur_thread</span> =</span> thread_current();<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();<br>cur_thread-&gt;lock_applying = <span class="hljs-literal">NULL</span>;<br>lock-&gt;max_priority = cur_thread-&gt;priority;<br>thread_hold_the_lock(lock);<br>intr_set_level(old_level);<br>}<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br>    <br></code></pre></td></tr></tbody></table></figure>
<p>其实，这在测试文件mlfqs-load-avg有提到。如下，在comment中，他说很可能是因为你的中断做了太多操作，浪费了大量时间，导致主线程没有足够多的线程去输出信息。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Starts 60 threads numbered 0 through 59.  Thread #i sleeps for</span><br><span class="hljs-comment">   (10+i) seconds, then spins in a loop for 60 seconds, then</span><br><span class="hljs-comment">   sleeps until a total of 120 seconds have passed.  Every 2</span><br><span class="hljs-comment">   seconds, starting 10 seconds in, the main thread prints the</span><br><span class="hljs-comment">   load average.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   The expected output is listed below.  Some margin of error is</span><br><span class="hljs-comment">   allowed.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   If your implementation fails this test but passes most other</span><br><span class="hljs-comment">   tests, then consider whether you are doing too much work in</span><br><span class="hljs-comment">   the timer interrupt.  If the timer interrupt handler takes too</span><br><span class="hljs-comment">   long, then the test's main thread will not have enough time to</span><br><span class="hljs-comment">   do its own work (printing a message) and go back to sleep</span><br><span class="hljs-comment">   before the next tick arrives.  Then the main thread will be</span><br><span class="hljs-comment">   ready, instead of sleeping, when the tick arrives,</span><br><span class="hljs-comment">   artificially driving up the load average.</span><br><span class="hljs-comment"> ...</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></tbody></table></figure>
<p>以下是msg的调用图，可以看到在输出信息时会关中断，而后会调用lock_aquire。而task2中的lock_aquire太过复杂，而关闭中断时间太长是很危险的。</p>
<p>第二种情况：你在本地跑的非常不错，ALL PASS，但提交到lab上却fail了，提示TIME OUT错误。</p>
<p>也就是说，超时了。不得不说这样的测试是挺离谱的，因为测试文件的目的就是要执行180秒，这能保证一点也不超时吗？本地测试的时间限制为480s，所以全部通过了，只能说非常的离谱。并且你还可能发现一些神奇的现象，比如说，同一次提交，不同的测试结果，这和平台的关系很大的。</p>
<p>没办法为了减少在timer_intrrupt的运行时间，需要对代码进行改进。原来更新recent_cpu和priority分成2个函数写，需要遍历链表两次，这次把他们放在一起，遍历一次即可，只不过代码的可读性下降了。将原来的这calculate_mlfqs_load_avg()、update_mlfqs_recent_cpu()、update_mlfqs_priority()这三个函数替换为以下函数即可。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 为了加快运行速度，将函数整合了一下 */</span><br><span class="hljs-type">void</span> <br><span class="hljs-title function_">mlfqs_update_rc_la_pr</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  <span class="hljs-type">int</span> ready_threads = list_size(&amp;ready_list) +(thread_current() != idle_thread);<br>  load_avg = FP_MUL(INT_TO_FP(<span class="hljs-number">59</span>) / <span class="hljs-number">60</span>, load_avg) + INT_TO_FP(<span class="hljs-number">1</span>) / <span class="hljs-number">60</span> * ready_threads;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> *<span class="hljs-title">e</span>;</span>     <br>  <span class="hljs-keyword">for</span> (e = list_begin (&amp;all_list); e != list_end (&amp;all_list); e = list_next (e))      <br>  { <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">t</span> =</span> list_entry (e, <span class="hljs-keyword">struct</span> thread, allelem);<br>    <span class="hljs-keyword">if</span>(t == idle_thread)<br>      <span class="hljs-keyword">continue</span>;<br><br>    t-&gt;recent_cpu = FP_MUL(FP_DIV(load_avg * <span class="hljs-number">2</span>, load_avg * <span class="hljs-number">2</span> + INT_TO_FP(<span class="hljs-number">1</span>)), t-&gt;recent_cpu) + INT_TO_FP(t-&gt;nice);<br>    t-&gt;priority = (FP_TO_INT(INT_TO_FP(PRI_MAX) - t-&gt;recent_cpu / <span class="hljs-number">4</span> - INT_TO_FP(t-&gt;nice * <span class="hljs-number">2</span>)));     <br>    t-&gt;priority = t-&gt;priority &lt; PRI_MIN ? PRI_MIN : t-&gt;priority;<br>    t-&gt;priority = t-&gt;priority &gt; PRI_MAX ? PRI_MAX : t-&gt;priority;<br> <br>   }<br>}<br></code></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4>
<p>总的来说，思维上难度比较大的是task2的优先级捐赠，通过锁间接捐赠的想法很好，但也不好想到。不过，搞清楚内在的逻辑之后，代码就比较简单了。虽然task3在逻辑上并没有task2复杂，但我花的时间却最长。一个是花在解决给main线程预留足够时间输出上，另一个就是gitlab上的超时问题。总之task3的难点就是尽量压缩timer_interrupt中执行的程序时间，以避免出错。</p>
<h3 id="project2-userprog"><a class="markdownIt-Anchor" href="#project2-userprog"></a> Project2 Userprog</h3>
<h4 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h4>
<p>如果在make check的时候遇到了非本项目出现的错误，可以参考project1的task2的Q&amp;A部分，很有可能是因为之前的实现造成的问题。想明确这一点，只需利用git回到最初的起点（别告诉我你还不会使用git），看看make check的内容和现在的是否一致即可。如果project1的实现确实造成了project2的一些困扰，可以利用gdb调试，看看问题出在哪里；但如果你遇到的问题和我不同，又不想解决，那你就用最原始的版本吧，因为这两个project是相对独立的。</p>
<p>参考：pintos官方文档</p>
<p>我们来看看userprog要求我们做哪些事呢？</p>
<p>这个项目当中我们会用到文件系统，但是我们不需要也不推荐去对文件系统进行任何修改，因为这不是我们这个project所要关注的事。我们只需要使用pintos写好的文件系统即可。但它提供的文件系统由于尚未完善，因此存在诸多限制：</p>
<ol>
<li>文件系统本身没有对同步互斥的支持，因此应确保一次只能有一个进程在使用文件系统；</li>
<li>文件系统的尺寸在创建之初就已经固定，而根目录其实就可以看作是一个文件，因此，文件的个数有限；</li>
<li>文件数据在磁盘上所占的空间是连续的，因此会有严重的碎片问题；</li>
<li>没有子目录；</li>
<li>文件名最长为14个字符；</li>
<li>在删除一个文件时，如果处于被打开的状态，是不会释放空间的，并且在进程关闭这个文件前，所有进程都能访问它。</li>
</ol>
<p>按照手册的说法我们还可以知道的是，kenel的虚拟地址是全局的，并且是3GB-4GB，如3GB+5MB对应的物理地址就是5MB。而user的虚拟地址则是局部的，<strong>每个user都有自己的虚拟地址，这在代码中的体现是，thread数据结构中，有一个pagedir成员，仅在userprog中启用</strong>，，它们的地址空间如下所示。代码段的地址从128MB左右开始，这没有什么具体意义，只是一个规定而已。</p>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/Memory_alloc.png)</p>
<p>此外文档<strong>还提供了任务的推荐完成顺序</strong>，如下：</p>
<ol>
<li>参数传递(Argument passing)；</li>
<li>用户存储访问(User memory access)；</li>
<li>系统调用(System call infrastructure)，包括关闭系统调用(the exit system call)</li>
<li>写系统调用(The write system call for writing to fd 1)；</li>
<li>剩下的任务</li>
</ol>
<p>但总的任务又分为3类：参数传递、系统调用、</p>
<p>我们将按照上述顺序进行实现</p>
<h4 id="task1-process-termination-messages"><a class="markdownIt-Anchor" href="#task1-process-termination-messages"></a> Task1: Process Termination Messages</h4>
<h5 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h5>
<p>手册中有一个小任务，用printf ("%s: exit(%d)\n",…)<strong>仅当用户进程</strong>退出的时候，打印出进程的名字和进程的退出代码。退出代码在thread中是没有的，因此可以添加上该数据。同时，打印的时机也是需要考虑的，来看看thread_exit和process_exit做了些什么。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Deschedules the current thread and destroys it.  Never</span><br><span class="hljs-comment">   returns to the caller. */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">thread_exit</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>{<br>  ASSERT (!intr_context ());<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USERPROG</span><br>  process_exit ();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-comment">/* Remove thread from all threads list, set our status to dying,</span><br><span class="hljs-comment">     and schedule another process.  That process will destroy us</span><br><span class="hljs-comment">     when it calls thread_schedule_tail(). */</span><br>  intr_disable ();<br>  list_remove (&amp;thread_current()-&gt;allelem);<br>  thread_current ()-&gt;status = THREAD_DYING;<br>  schedule ();<br>  NOT_REACHED ();<br>}<br><br><span class="hljs-comment">/* Free the current process's resources. */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">process_exit</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">cur</span> =</span> thread_current ();<br>  <span class="hljs-type">uint32_t</span> *pd;<br><br>  <span class="hljs-comment">/* Destroy the current process's page directory and switch back</span><br><span class="hljs-comment">     to the kernel-only page directory. */</span><br>  pd = cur-&gt;pagedir;<br>  <span class="hljs-keyword">if</span> (pd != <span class="hljs-literal">NULL</span>) <br>    {<br>      <span class="hljs-comment">/* Correct ordering here is crucial.  We must set</span><br><span class="hljs-comment">         cur-&gt;pagedir to NULL before switching page directories,</span><br><span class="hljs-comment">         so that a timer interrupt can't switch back to the</span><br><span class="hljs-comment">         process page directory.  We must activate the base page</span><br><span class="hljs-comment">         directory before destroying the process's page</span><br><span class="hljs-comment">         directory, or our active page directory will be one</span><br><span class="hljs-comment">         that's been freed (and cleared). */</span><br>      cur-&gt;pagedir = <span class="hljs-literal">NULL</span>;<br>      pagedir_activate (<span class="hljs-literal">NULL</span>);<br>      pagedir_destroy (pd);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>如上所示，process_exit在project2中，会被thread_exit所调用。前面说到，thread结构当中有一个pagedir，只有在用户程序的时候才会给它分配独立的虚拟地址。因此如果是用户程序，正常情况下，pd不应当为空，因此打印退出代码的程序应该放在这里面。值得一提的是，后面的一些语句，表示页面的释放。它说这里的顺序非常重要，不可以修改。先是cur-&gt;pagedir置空，以避免时间中断跳回到用户程序页面。然后再将该页面激活（就是返回页面的物理地址），再把它毁掉。</p>
<p>总的来说任务还是比较清晰的，可以coding了。</p>
<h5 id="实现-3"><a class="markdownIt-Anchor" href="#实现-3"></a> 实现</h5>
<p>在thread.h中的thread数据结构中加入</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><span class="hljs-type">bool</span> exit_code;			<span class="hljs-comment">/* 进程终止信息 */</span><br><span class="hljs-comment">/*--------------------------------------------------------*/</span> <br></code></pre></td></tr></tbody></table></figure>
<p>在process.c中的process_exit加入</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Free the current process's resources. */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">process_exit</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">cur</span> =</span> thread_current ();<br>  <span class="hljs-type">uint32_t</span> *pd;<br><br>  <span class="hljs-comment">/* Destroy the current process's page directory and switch back</span><br><span class="hljs-comment">     to the kernel-only page directory. */</span><br>  pd = cur-&gt;pagedir;<br>  <span class="hljs-keyword">if</span> (pd != <span class="hljs-literal">NULL</span>) <br>    {<br>      <span class="hljs-comment">/* Correct ordering here is crucial.  We must set</span><br><span class="hljs-comment">         cur-&gt;pagedir to NULL before switching page directories,</span><br><span class="hljs-comment">         so that a timer interrupt can't switch back to the</span><br><span class="hljs-comment">         process page directory.  We must activate the base page</span><br><span class="hljs-comment">         directory before destroying the process's page</span><br><span class="hljs-comment">         directory, or our active page directory will be one</span><br><span class="hljs-comment">         that's been freed (and cleared). */</span><br>      cur-&gt;pagedir = <span class="hljs-literal">NULL</span>;<br>      pagedir_activate (<span class="hljs-literal">NULL</span>);<br>      pagedir_destroy (pd);<br><br>      <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br>      <span class="hljs-comment">/* 打印用户进程终止信息 */</span><br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s: exit(%d)\n"</span>, cur-&gt;name, cur-&gt;exit_code);<br>      <span class="hljs-comment">/*--------------------------------------------------------*/</span> <br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<h4 id="task2-argument-passing"><a class="markdownIt-Anchor" href="#task2-argument-passing"></a> Task2: Argument Passing</h4>
<h5 id="分析-4"><a class="markdownIt-Anchor" href="#分析-4"></a> 分析</h5>
<p>依照它的描述：在process_execute()中，所需要修改的只是简单的将字符串拆分而已</p>
<p>如"grep foo bar"，要将其拆成3个单词，且第一个为文件，第二个为参数。</p>
<p>嗯，听起来似乎没什么难的。我们先来看看process_execute做了些什么</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Starts a new thread running a user program loaded from</span><br><span class="hljs-comment">   FILENAME.  The new thread may be scheduled (and may even exit)</span><br><span class="hljs-comment">   before process_execute() returns.  Returns the new process's</span><br><span class="hljs-comment">   thread id, or TID_ERROR if the thread cannot be created. */</span><br><span class="hljs-type">tid_t</span><br><span class="hljs-title function_">process_execute</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file_name)</span> <br>{<br>  <span class="hljs-type">char</span> *fn_copy;<br>  <span class="hljs-type">tid_t</span> tid;<br><br>  <span class="hljs-comment">/* Make a copy of FILE_NAME.</span><br><span class="hljs-comment">     Otherwise there's a race between the caller and load(). */</span><br>  fn_copy = palloc_get_page (<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (fn_copy == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> TID_ERROR;<br>  strlcpy (fn_copy, file_name, PGSIZE);<br><br>  <span class="hljs-comment">/* Create a new thread to execute FILE_NAME. */</span><br>  tid = thread_create (file_name, PRI_DEFAULT, start_process, fn_copy);<br>  <span class="hljs-keyword">if</span> (tid == TID_ERROR)<br>    palloc_free_page (fn_copy); <br>  <span class="hljs-keyword">return</span> tid;<br>}<br><br><br></code></pre></td></tr></tbody></table></figure>
<p>可以看到，显示输入文件名字符串，当然这个字符串可能带着参数。</p>
<p>使用palloc_get_page取获得1页内存（pintos中线程的大小是固定的，就是1页，可见手册P61），而且是kernel pool的页面。 strlcpy则是想file_name复制到fn_copy的空间中去，再调用thread_create创建这个线程。为什么要复制file_name呢？<strong>按它的说法是不复制，调用者和loader会出现冲突</strong>（没太明白也许是地址冲突之类的？）。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">thread_create (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> priority, thread_func *function, <span class="hljs-type">void</span> *aux) <br></code></pre></td></tr></tbody></table></figure>
<p>防止你忘了创建线程函数的格式，上面写出来了。我们发现，process_execute所创建的线程名字为文件名，而调用的函数则是start_process，这又是什么呢？然后，aux则还是文件名。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* A thread function that loads a user process and starts it</span><br><span class="hljs-comment">   running. */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">start_process</span> <span class="hljs-params">(<span class="hljs-type">void</span> *file_name_)</span><br>{<br>  <span class="hljs-type">char</span> *file_name = file_name_;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intr_frame</span> <span class="hljs-title">if_</span>;</span><br>  <span class="hljs-type">bool</span> success;<br><br>  <span class="hljs-comment">/* Initialize interrupt frame and load executable. */</span><br>  <span class="hljs-built_in">memset</span> (&amp;if_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> if_);<br>  if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;<br>  if_.cs = SEL_UCSEG;<br>  if_.eflags = FLAG_IF | FLAG_MBS;<br>  success = load (file_name, &amp;if_.eip, &amp;if_.esp);<br><br>  <span class="hljs-comment">/* If load failed, quit. */</span><br>  palloc_free_page (file_name);<br>  <span class="hljs-keyword">if</span> (!success) <br>    thread_exit ();<br><br>  <span class="hljs-comment">/* Start the user process by simulating a return from an</span><br><span class="hljs-comment">     interrupt, implemented by intr_exit (in</span><br><span class="hljs-comment">     threads/intr-stubs.S).  Because intr_exit takes all of its</span><br><span class="hljs-comment">     arguments on the stack in the form of a `struct intr_frame',</span><br><span class="hljs-comment">     we just point the stack pointer (%esp) to our stack frame</span><br><span class="hljs-comment">     and jump to it. */</span><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">"movl %0, %%esp; jmp intr_exit"</span> : : <span class="hljs-string">"g"</span> (&amp;if_) : <span class="hljs-string">"memory"</span>)</span>;<br>  NOT_REACHED ();<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>start_process 所做的事，就是将ELF可执行文件装载进thread。也许会问，怎么装载的呢？我想这并不是我们需要关心的问题，ELF文件有着固定的格式，根据某种规则，将文件加载进内存，当然还得要进行重定位等等。这也许会在CSAPP这本书中找到答案，这里我们不做深入讨论。</p>
<p>回到这个task，我们要做到参数传递，好像无非就是分割字符串成一个个单词罢了，这需要我们自己去写吗？不需要，贴心的pintos已经为我们准备好了这样的函数，毕竟这并不是操作系统的重点。</p>
<p>在string.c文件中有这么一个函数：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Breaks a string into tokens separated by DELIMITERS.  The</span><br><span class="hljs-comment">   first time this function is called, S should be the string to</span><br><span class="hljs-comment">   tokenize, and in subsequent calls it must be a null pointer.</span><br><span class="hljs-comment">   SAVE_PTR is the address of a `char *' variable used to keep</span><br><span class="hljs-comment">   track of the tokenizer's position.  The return value each time</span><br><span class="hljs-comment">   is the next token in the string, or a null pointer if no</span><br><span class="hljs-comment">   tokens remain.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   This function treats multiple adjacent delimiters as a single</span><br><span class="hljs-comment">   delimiter.  The returned tokens will never be length 0.</span><br><span class="hljs-comment">   DELIMITERS may change from one call to the next within a</span><br><span class="hljs-comment">   single string.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   strtok_r() modifies the string S, changing delimiters to null</span><br><span class="hljs-comment">   bytes.  Thus, S must be a modifiable string.  String literals,</span><br><span class="hljs-comment">   in particular, are *not* modifiable in C, even though for</span><br><span class="hljs-comment">   backward compatibility they are not `const'.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   Example usage:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   char s[] = "  String to  tokenize. ";</span><br><span class="hljs-comment">   char *token, *save_ptr;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   for (token = strtok_r (s, " ", &amp;save_ptr); token != NULL;</span><br><span class="hljs-comment">        token = strtok_r (NULL, " ", &amp;save_ptr))</span><br><span class="hljs-comment">     printf ("'%s'\n", token);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   outputs:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     'String'</span><br><span class="hljs-comment">     'to'</span><br><span class="hljs-comment">     'tokenize.'</span><br><span class="hljs-comment">*/</span><br>strtok_r (<span class="hljs-type">char</span> *s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *delimiters, <span class="hljs-type">char</span> **save_ptr) <br></code></pre></td></tr></tbody></table></figure>
<p>我们也许并不关心它的实现，但还是需要仔细看一下该函数需要注意的点。注释中说，输入的s必须是个可变的字符串，即不能是const型，原因在于，<strong>它的原理就是在原字符串中将delimiters转换为NULL(’\0’)，这对原字符串是会造成修改的</strong>。可以看到，它还贴心的用空格举的例子，这不正是我们所需要的吗？那么来理一下思路：</p>
<ol>
<li>首先我们需要在process_execute中将file_name把file拆出来，<strong>因为thread的名字显然是file，而不是这个字符串</strong>（thread的名字只有15个字符，文件名最长可以有14个字符，显然不太能把这个字符串给thread）。</li>
<li>其二，既然要把拆出来的文件名给thread，而aux得是fn_copy（上面说了，是为了防止冲突），输入的file_name又是const char *，格式，<strong>因此得复制2份，一份给thread的name，一份作为aux</strong>。</li>
<li>拆分字符串就是调用strtok_r 函数，且只要拆分一次即可。</li>
</ol>
<p>这样就完了吗？显然不是，我们参数还没传进去呢？手册中还有这么一句话：</p>
<figure class="highlight delphi"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">See Section <span class="hljs-number">3.5</span>.<span class="hljs-number">1</span> [<span class="hljs-keyword">Program</span> Startup Details], page <span class="hljs-number">36</span>, <span class="hljs-keyword">for</span> information <span class="hljs-keyword">on</span> exactly how<br>you need <span class="hljs-keyword">to</span> <span class="hljs-keyword">set</span> up the stack.<br></code></pre></td></tr></tbody></table></figure>
<p>我们还需要了解，参数压栈的规则，才能真正将参数传递进去。</p>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/PushStack.png)</p>
<p>手册【P36】中又这样一张图，同时手册【P36-37】详细介绍了80386在unix上调用函数的一些惯例。它告诉我们：</p>
<ol>
<li>栈是<strong>从高地址往低地址增长的</strong>，</li>
<li>假如我们有3个参数，我们要先压，参数3，再是2，最后是1，即<strong>压参的顺序是从右往左</strong>。</li>
<li>所有的参数，都是<strong>四字节对齐的</strong>。</li>
<li>如果被调用这有一个返回值，<strong>那么它将被存储于EAX中</strong>。</li>
<li>当然还有一些函数调用常识，比如80x86的RET指令是从栈中pop出返回地址，参数也是从栈中弹出。</li>
</ol>
<p>此外，压栈压栈，我们压的到底是哪个栈，我们在手册上看到了一个set_stack函数，这个函数，也被load调用，而该函数正是设置栈的空间的</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create a minimal stack by mapping a zeroed page at the top of</span><br><span class="hljs-comment">   user virtual memory. */</span><br>setup_stack (<span class="hljs-type">void</span> **esp) <br>{<br>  <span class="hljs-type">uint8_t</span> *kpage;<br>  <span class="hljs-type">bool</span> success = <span class="hljs-literal">false</span>;<br><br>  kpage = palloc_get_page (PAL_USER | PAL_ZERO);<br>  <span class="hljs-keyword">if</span> (kpage != <span class="hljs-literal">NULL</span>) <br>    {<br>      success = install_page (((<span class="hljs-type">uint8_t</span> *) PHYS_BASE) - PGSIZE, kpage, <span class="hljs-literal">true</span>);<br>      <span class="hljs-keyword">if</span> (success)<br>        *esp = PHYS_BASE;<br>      <span class="hljs-keyword">else</span><br>        palloc_free_page (kpage);<br>    }<br>  <span class="hljs-keyword">return</span> success;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>不必去纠结它的实现细节，通过注释我们可以知道，这段代码就是给进程分配一个栈的空间，当然里面是没有参数的，为初始化0的页面。并且有一段代码是值得关注的。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (success) <br>	*esp = PHYS_BASE;<br></code></pre></td></tr></tbody></table></figure>
<p>如果创建成功了，*esp = PHYS_BASE就指向了用户虚拟内存的栈顶。</p>
<p>进一步，我们还可以参考一下c语言main函数传参的过程</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span><br></code></pre></td></tr></tbody></table></figure>
<p>如上是带参main函数的格式，还记得main函数是如何压参的吗？在手册P37中，我们可以找到答案，如下图：</p>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/arg_pass.png)</p>
<p>我们来理一下过程：</p>
<ol>
<li>在调用我们的函数前，我们先将<strong>参数压入</strong></li>
<li>而为了方便，我们可以参照main函数的压参过程，使用<strong>二级指针将参数压入</strong></li>
<li>此外，自右向左，压入参数地址后，<strong>还需要压入argc</strong>，表示有多少个参数</li>
<li>在压参完毕后，还需<strong>压入返回地址</strong>。</li>
</ol>
<p>由此，压参的过程，已经明了了，可以开始coding了。</p>
<hr>
<h5 id="实现-4"><a class="markdownIt-Anchor" href="#实现-4"></a> 实现</h5>
<p>在process.c中的process_execute中添加</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">tid_t</span><br><span class="hljs-title function_">process_execute</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file_name)</span> <br>{<br>  <span class="hljs-type">char</span> *fn_copy;<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-type">char</span> *fn_copy_for_thread_name;<br>  <span class="hljs-type">char</span> *thread_name, *save_ptr; <br>  fn_copy_for_thread_name = palloc_get_page (<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  <span class="hljs-type">tid_t</span> tid;<br><br>  <span class="hljs-comment">/* Make a copy of FILE_NAME.</span><br><span class="hljs-comment">     Otherwise there's a race between the caller and load(). */</span><br>  fn_copy = palloc_get_page (<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (fn_copy == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> TID_ERROR;<br>  strlcpy (fn_copy, file_name, PGSIZE);<br><br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 复制一个字符串，用于分割文件名作为线程名 */</span><br>  strlcpy (fn_copy_for_thread_name, file_name, PGSIZE);<br>  thread_name = strtok_r (fn_copy_for_thread_name, <span class="hljs-string">" "</span>, &amp;save_ptr);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br>  <span class="hljs-comment">/* Create a new thread to execute FILE_NAME. */</span><br>  tid = thread_create (file_name, PRI_DEFAULT, start_process, fn_copy);<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 别忘记把它释放掉 */</span><br>  palloc_free_page (fn_copy_for_thread_name); <br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  <span class="hljs-keyword">if</span> (tid == TID_ERROR)<br>    palloc_free_page (fn_copy); <br>  <span class="hljs-keyword">return</span> tid;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<p>在process.c中的start_process中添加</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">start_process</span> <span class="hljs-params">(<span class="hljs-type">void</span> *file_name_)</span><br>{<br>  <span class="hljs-type">char</span> *file_name = file_name_;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intr_frame</span> <span class="hljs-title">if_</span>;</span><br>  <span class="hljs-type">bool</span> success;<br><br>  <span class="hljs-comment">/* Initialize interrupt frame and load executable. */</span><br>  <span class="hljs-built_in">memset</span> (&amp;if_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> if_);<br>  if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;<br>  if_.cs = SEL_UCSEG;<br>  if_.eflags = FLAG_IF | FLAG_MBS;<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 将真正的文件名装载进去，会造成字符串修改，而文件名</span><br><span class="hljs-comment">   * 也是参数的一部分，因此我们使用original来保存</span><br><span class="hljs-comment">   * 原字符串的副本  */</span><br>  <span class="hljs-type">char</span> *real_file_name, *original_name, *save_ptr; <br>  original_name = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(file_name)+<span class="hljs-number">1</span>);<br>  strlcpy (original_name, file_name, <span class="hljs-built_in">strlen</span>(file_name)+<span class="hljs-number">1</span>);<br>  real_file_name = strtok_r (file_name_, <span class="hljs-string">" "</span>, &amp;save_ptr);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  success = load (real_file_name, &amp;if_.eip, &amp;if_.esp);<br><br>  <span class="hljs-comment">/* If load failed, quit. */</span><br>  palloc_free_page (file_name);<br>  <span class="hljs-keyword">if</span> (!success) <br>    thread_exit ();<br><br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 显然只有在成功装载之后，我们才需要参数传递 </span><br><span class="hljs-comment">   * 以下过程，就是把参数压入栈中，此处的顺序是自左向右</span><br><span class="hljs-comment">   * 这并没有什么关系，因为我们使用二级指针对参数压栈</span><br><span class="hljs-comment">   * 只需要保证压入二级指针时，是自右向左即可。</span><br><span class="hljs-comment">   * argv存储的是各个参数的首地址，即实际的二级指针</span><br><span class="hljs-comment">   * 而386系统中，地址是32位，因此使用int型。</span><br><span class="hljs-comment">   * argc则存储的是参数的个数。</span><br><span class="hljs-comment">   * 由于参数个数未知，我们使用动态分配地址的方法。 */</span><br><br>  <span class="hljs-type">int</span> argc = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> argv_size = <span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span>* argv = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>(argv_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>  <span class="hljs-type">char</span>* token;<br><br>  <span class="hljs-keyword">for</span> (token = strtok_r (original_name, <span class="hljs-string">" "</span>, &amp;save_ptr); token != <span class="hljs-literal">NULL</span>;<br>		             token = strtok_r (<span class="hljs-literal">NULL</span>, <span class="hljs-string">" "</span>, &amp;save_ptr))<br>  {<br>    <span class="hljs-comment">/* 字符串是低地址往高地址存，并且注意'\0'也是字符串</span><br><span class="hljs-comment">     * 的一部分 */</span><br>    if_.esp -= <span class="hljs-built_in">strlen</span>((token)+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memcmp</span>(if_.esp, token, <span class="hljs-built_in">strlen</span>(token)+<span class="hljs-number">1</span>);<br>    argv[argc++] = (<span class="hljs-type">int</span>) if_.esp;<br>    <span class="hljs-keyword">if</span> (argc &gt; argv_size)<br>    {<br>      <span class="hljs-comment">/* 如果空间不够，得重新分配 */</span><br>      argv_size += <span class="hljs-number">10</span>;<br>      <span class="hljs-built_in">realloc</span>(argv, argv_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>* )); <br>    }<br>  }<br><br>  push_arg_and_retaddr(&amp;if_.esp, argc, argv);<br><br>  <span class="hljs-built_in">free</span>(original_name);<br>  <span class="hljs-built_in">free</span>(argv);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br>  <span class="hljs-comment">/* Start the user process by simulating a return from an</span><br><span class="hljs-comment">     interrupt, implemented by intr_exit (in</span><br><span class="hljs-comment">     threads/intr-stubs.S).  Because intr_exit takes all of its</span><br><span class="hljs-comment">     arguments on the stack in the form of a `struct intr_frame',</span><br><span class="hljs-comment">     we just point the stack pointer (%esp) to our stack frame</span><br><span class="hljs-comment">     and jump to it. */</span><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">"movl %0, %%esp; jmp intr_exit"</span> : : <span class="hljs-string">"g"</span> (&amp;if_) : <span class="hljs-string">"memory"</span>)</span>;<br>  NOT_REACHED ();<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<p>在process.c中添加压参函数</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br><span class="hljs-comment">/* 自右向左压入参数的首地址，即二级指针</span><br><span class="hljs-comment"> * 此外还需压入参数的个数，以及返回地址0</span><br><span class="hljs-comment"> * 此处esp使用的是二级指针，原因在于，我们要修改的是</span><br><span class="hljs-comment"> * esp指针(即保存的地址)的值，而非esp所指向的值 */</span><br><span class="hljs-type">void</span> <br><span class="hljs-title function_">push_arg_and_retaddr</span><span class="hljs-params">(<span class="hljs-type">void</span>** esp, <span class="hljs-type">int</span> argc, <span class="hljs-type">int</span>* argv)</span><br>{<br><br>  <span class="hljs-comment">/* 4字节对齐 */</span><br>  <span class="hljs-type">int</span> rest = (<span class="hljs-type">int</span>)*esp % <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rest; i++)<br>  {<br>    *esp --;	  <br>    *esp = (<span class="hljs-type">int</span>)*esp;<br><br>  }<br><br>  <span class="hljs-comment">/* 自右向左依次压入一级指针argv* */</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = argc - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>  {	<br>     *esp -= <span class="hljs-number">4</span>;<br>     *(<span class="hljs-type">int</span> *) *esp = argv[i];<br>  }<br>  <span class="hljs-comment">/* 分别压入二级指针argv**，即argv[0]的地址</span><br><span class="hljs-comment">   * 参数个数，返回地址0 */</span><br>  *esp -= <span class="hljs-number">4</span>;<br>  *(<span class="hljs-type">int</span> *) *esp = (<span class="hljs-type">int</span>) *esp + <span class="hljs-number">4</span>;<br>  *esp -= <span class="hljs-number">4</span>;<br>  *(<span class="hljs-type">int</span> *) *esp = argc;<br>  *esp -= <span class="hljs-number">4</span>;<br>  *(<span class="hljs-type">int</span> *) *esp = <span class="hljs-number">0</span>;<br><br>}<br><br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br></code></pre></td></tr></tbody></table></figure>
<h4 id="task3-system-call"><a class="markdownIt-Anchor" href="#task3-system-call"></a> Task3: System Call</h4>
<h5 id="概述-2"><a class="markdownIt-Anchor" href="#概述-2"></a> 概述</h5>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/syscall_intro.png)</p>
<p>如上图是syscall系统调用的流程，首先通过syscall_init装载内中断syscall_handler，<strong>中断号为30，且特权级为3</strong>（最低级别）。然后通过halt、exit等函数调用系统调用。这些函数用内联汇编代码编写。这些汇编代码的流程如下：</p>
<ol>
<li><strong>自右向左压入参数</strong>；</li>
<li>压入中断号，<strong>因此中断号总是处于栈顶位置</strong>。</li>
<li>调用<strong>30中断</strong>，进入中断处理程序，其实<strong>也就是syscall_handler</strong>。</li>
<li>执行完毕后，pop出所有参数，并返回。</li>
<li>如果有返回值，<strong>从EAX寄存器中取出</strong>，送入retval。</li>
</ol>
<p>手册【P29】说，所有的系统调用存在‘userprog/syscall.c’、‘userprog/syscall.h’，同时‘lib/syscall-nr.h’中还存着各个系统调用的终端号，如下所示。它用枚举型存储着，总共有20个，并且明确标出了project2所需要用到的13个系统调用。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __LIB_SYSCALL_NR_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __LIB_SYSCALL_NR_H</span><br><br><span class="hljs-comment">/* System call numbers. */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> </span><br><span class="hljs-class">  {</span><br>    <span class="hljs-comment">/* Projects 2 and later. */</span><br>    SYS_HALT,                   <span class="hljs-comment">/* Halt the operating system. */</span><br>    SYS_EXIT,                   <span class="hljs-comment">/* Terminate this process. */</span><br>    SYS_EXEC,                   <span class="hljs-comment">/* Start another process. */</span><br>    SYS_WAIT,                   <span class="hljs-comment">/* Wait for a child process to die. */</span><br>    SYS_CREATE,                 <span class="hljs-comment">/* Create a file. */</span><br>    SYS_REMOVE,                 <span class="hljs-comment">/* Delete a file. */</span><br>    SYS_OPEN,                   <span class="hljs-comment">/* Open a file. */</span><br>    SYS_FILESIZE,               <span class="hljs-comment">/* Obtain a file's size. */</span><br>    SYS_READ,                   <span class="hljs-comment">/* Read from a file. */</span><br>    SYS_WRITE,                  <span class="hljs-comment">/* Write to a file. */</span><br>    SYS_SEEK,                   <span class="hljs-comment">/* Change position in a file. */</span><br>    SYS_TELL,                   <span class="hljs-comment">/* Report current position in a file. */</span><br>    SYS_CLOSE,                  <span class="hljs-comment">/* Close a file. */</span><br><br>    <span class="hljs-comment">/* Project 3 and optionally project 4. */</span><br>    SYS_MMAP,                   <span class="hljs-comment">/* Map a file into memory. */</span><br>    SYS_MUNMAP,                 <span class="hljs-comment">/* Remove a memory mapping. */</span><br><br>    <span class="hljs-comment">/* Project 4 only. */</span><br>    SYS_CHDIR,                  <span class="hljs-comment">/* Change the current directory. */</span><br>    SYS_MKDIR,                  <span class="hljs-comment">/* Create a directory. */</span><br>    SYS_READDIR,                <span class="hljs-comment">/* Reads a directory entry. */</span><br>    SYS_ISDIR,                  <span class="hljs-comment">/* Tests if a fd represents a directory. */</span><br>    SYS_INUMBER                 <span class="hljs-comment">/* Returns the inode number for a fd. */</span><br>  };<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* lib/syscall-nr.h */</span></span><br></code></pre></td></tr></tbody></table></figure>
<p>其实在手册【P28】中还明确说到了，当然在本日志project2概述中也提到了，官方提出了一个推荐完成顺序。我们需要完成一些基本的syscall，并且系统调用应当还能够访问用户的内存空间。用户程序使用系统调用通过内部中断进行，在x86系统中，常常是通过<strong>调用门切换自己的特权级（DPL）</strong>，而特权级转变这里不详细展开说它的过程（后续有精力还会在补充）。</p>
<p>按照手册的说法，那我们先来让系统调用能够访问我们的用户内存</p>
<hr>
<h5 id="分析访问用户内存"><a class="markdownIt-Anchor" href="#分析访问用户内存"></a> 分析：访问用户内存</h5>
<p>关于访问用户内存，手册【P27】是这么说的：</p>
<figure class="highlight gcode"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">作为系统调用的一部分，内核必须经常通过用户程序提供的指针访问内存。内核必须非常小心地这样做，因为用户可以传递一个空指针，一个指向未映射虚拟内存的指针，或者一个指向内核虚拟地址空间<span class="hljs-comment">(位于PHYS_BASE之上)</span>的指针。所有这些类型的无效指针都必须被拒绝，从而不会对内核或其他正在运行的进程造成伤害，方法是终止违规进程并释放其资源。<br>至少有两种合理的方法可以正确地做到这一点。<br>第一种方法是验证用户提供的指针的有效性，然后解除对它的引用。如果你选择了这个方法，你可以看看<span class="hljs-string">' userprog/pagedir.c '</span>和<span class="hljs-string">' threads/vaddr.h '</span>中的函数。这是处理用户内存访问的最简单的方法。<br>第二种方法是只检查用户指针是否指向PHYS_BASE下面，然后取消对它的引用。无效的用户指针将导致“页面错误”，您可以通过修改<span class="hljs-string">' userprog/exception.c '</span>中的page_fault<span class="hljs-comment">()</span>代码来处理。这种技术通常更快，因为它利用了处理器的MMU，所以它倾向于在真实的内核<span class="hljs-comment">(包括Linux)</span>中使用。<br>在这两种情况下，您都需要确保不会“泄漏”资源。例如，假设您的系统调用已经使用malloc<span class="hljs-comment">()</span>获得了一个锁或分配了内存，如果之后遇到无效的用户指针，仍然必须确保释放锁或释放内存页；如果您选择在解引用用户指针之前验证它们，这应该很简单，但无效指针导致页面错误，处理起来更加困难，因为无法从内存访问中返回错误代码。因此，对于那些想要尝试后一种技术的人，我们将提供一些有用的代码。<br>代码：略<br></code></pre></td></tr></tbody></table></figure>
<p>这里选择它所谓的最简单的方法。</p>
<p>什么验证用户提供的指针的有效性？可以分为2个方面：</p>
<ol>
<li>用户提供的中断类型号是否正确，即<strong>存不存在它需要的系统调用</strong>？</li>
<li>用户程序的内存是否正确，主要考察：<strong>用户程序的虚拟内存是否在PHYBASE以下？用户的虚拟地址是否指向一个不存在的物理地址？</strong></li>
<li>手册中所谓的确保不会“泄漏”资源（讲道理，这里没怎么看懂），然后给我们提供了2段代码，一个测试能否成功访问（解引用），另一段则是测试能否成功写入。我们在获得这个用户指针，可以用该代码来<strong>验证其是否有效</strong>。</li>
</ol>
<p>对于1，如何去知道用户所提供的中断号呢？<strong>中断存于用户栈顶</strong>，这在前面的分析已经说到了。系统调用时从栈顶推出，即可获得中断号。然后判断中断号是否在0~20之间即可。</p>
<p>对于2，可以用is_user_vaddr来判断是或否在phybase以下，同时还可以使用pagedir_get_page获得用户它的物理地址。该函数如下所示，我们在结构篇提到过，pintos采用的二级页表存储，所以它首先根据虚拟地址通过lookup_page在页目录中查找它所在的页面地址pte，然后使用pte_get_page找到对应页表项的地址，然后再加上页内偏移就是物理地址了。当然，如果中间任何一个环节找不到，那就会返回NULL，由此判断该虚拟地址是否指向一个存在的物理地址。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Looks up the physical address that corresponds to user virtual</span><br><span class="hljs-comment">   address UADDR in PD.  Returns the kernel virtual address</span><br><span class="hljs-comment">   corresponding to that physical address, or a null pointer if</span><br><span class="hljs-comment">   UADDR is unmapped. */</span><br><span class="hljs-type">void</span> *<br><span class="hljs-title function_">pagedir_get_page</span> <span class="hljs-params">(<span class="hljs-type">uint32_t</span> *pd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *uaddr)</span> <br>{<br>  <span class="hljs-type">uint32_t</span> *pte;<br><br>  ASSERT (is_user_vaddr (uaddr));<br>  <br>  pte = lookup_page (pd, uaddr, <span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">if</span> (pte != <span class="hljs-literal">NULL</span> &amp;&amp; (*pte &amp; PTE_P) != <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> pte_get_page (*pte) + pg_ofs (uaddr);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>对于3，我们可以使用手册提供的如下代码，进行解引用。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">get_user</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *uaddr)</span><br>{<br>  <span class="hljs-type">int</span> result;   <br>  <span class="hljs-keyword">asm</span> (<span class="hljs-string">"movl $1f, %0; movzbl %1, %0; 1:"</span><br>       : <span class="hljs-string">"=&amp;a"</span> (result) : <span class="hljs-string">"m"</span> (*uaddr));<br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>而解引用如引发异常，将调用page_fault，page_fault会强行杀掉进程，<strong>而无法返回错误信息</strong>。那么我们就需要对page_fault进行修改，在引发异常时返回-1，而不让它报错即可。</p>
<p>经过如上分析后，可以开始coding了。</p>
<hr>
<h5 id="实现访问用户内存"><a class="markdownIt-Anchor" href="#实现访问用户内存"></a> 实现：访问用户内存</h5>
<p>对于非正常退出的情况，我们在syscall.c中添加如下代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span><br><span class="hljs-comment">/* 非正常退出  */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">exit_error</span><span class="hljs-params">()</span><br>{<br>  thread_current()-&gt;exit_code = <span class="hljs-number">-1</span>;<br>  thread_exit();<br>}<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br></code></pre></td></tr></tbody></table></figure>
<p>3个合法性检查函数：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span><br><span class="hljs-comment">/* 手册提供的判断页面可否访问的代码 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <br><span class="hljs-title function_">get_user</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *uaddr)</span><br>{<br>  <span class="hljs-type">int</span> result;<br>  <span class="hljs-keyword">asm</span> (<span class="hljs-string">"movl $1f, %0; movzbl %1, %0; 1:"</span> : <span class="hljs-string">"=&amp;a"</span> (result) : <span class="hljs-string">"m"</span> (*uaddr));<br>  <span class="hljs-keyword">return</span> result;<br>}<br><br><span class="hljs-comment">/* 主要判断3个方面：</span><br><span class="hljs-comment"> * 1. 用户指针是否可以访问。  </span><br><span class="hljs-comment"> * 2. 地址是狗在用户虚拟内存范围内</span><br><span class="hljs-comment"> * 3. 用户虚拟内存是否对应存在的物理空间</span><br><span class="hljs-comment"> * 最后返回用户虚拟内存的返回物理地址 */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">check_valid</span><span class="hljs-params">(<span class="hljs-type">void</span>* vaddr)</span><br>{  <br>  <span class="hljs-comment">/* 逐次检测用户指针的4个字节，判断是否都能够</span><br><span class="hljs-comment">   * 成功访问。 */</span><br>  <span class="hljs-type">uint8_t</span> *check_byteptr = (<span class="hljs-type">uint8_t</span> *) vaddr;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) <br>  {<br>    <span class="hljs-keyword">if</span> (get_user(check_byteptr + i) == <span class="hljs-number">-1</span>)<br>    {<br>      exit_error ();<br>    }<br>  }<br><br>  <span class="hljs-keyword">if</span> (is_user_vaddr(vaddr) == <span class="hljs-literal">NULL</span>)<br>  {<br>    exit_error ();<br>  }<br><br>  <span class="hljs-comment">/* 返回物理地址 */</span><br>  <span class="hljs-type">void</span> *ptr = pagedir_get_page (thread_current()-&gt;pagedir, vaddr);<br>  <span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>)<br>  {<br>    exit_error ();<br>  }<br><br>  <span class="hljs-keyword">return</span> ptr;<br>}<br><br><span class="hljs-comment">/* 判断压入的参数是否全都合法 */</span><br><span class="hljs-type">bool</span><br><span class="hljs-title function_">is_valid_args</span><span class="hljs-params">(<span class="hljs-type">void</span>* esp, <span class="hljs-type">uint8_t</span> argc)</span><br>{<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; argc; ++i)<br>  {<br>    <span class="hljs-keyword">if</span>( (is_user_vaddr(esp) == <span class="hljs-literal">NULL</span>) || (pagedir_get_page(thread_current()-&gt;pagedir, esp) == <span class="hljs-literal">NULL</span>) )<br>    {<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br></code></pre></td></tr></tbody></table></figure>
<p>重写中断处理函数syscall_handler。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 重写syscall中断处理函数</span><br><span class="hljs-comment"> * 首先检查参数用户空间的合法性</span><br><span class="hljs-comment"> * 然后再检查中断号是否处在正确范围内 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">syscall_handler</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame *f UNUSED)</span> <br>{<br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span><br>  <span class="hljs-type">int</span> * p = f-&gt;esp;<br>  <span class="hljs-comment">/* 检查参数空间是否处于用户空间内 */</span><br>  check_valid(p + <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">/* 从栈顶取出中断号 */</span><br>  <span class="hljs-type">int</span> syscall_code = * (<span class="hljs-type">int</span>* ) f-&gt;esp;<br>  <span class="hljs-keyword">if</span>(syscall_code &lt;= <span class="hljs-number">0</span> || syscall_code &gt;= SYSCALL_MAX)<br>  {<br>    exit_error();<br>  }<br>  syscalls[syscall_code](f);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>}<br><br></code></pre></td></tr></tbody></table></figure>
<p>在syscall.h中添加如下声明：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;syscall-nr.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"userprog/process.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"userprog/pagedir.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"threads/interrupt.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"threads/malloc.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"threads/palloc.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"threads/interrupt.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"threads/thread.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"threads/vaddr.h"</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_MAX 20</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_user</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *uaddr)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">check_valid</span><span class="hljs-params">(<span class="hljs-type">void</span>* vaddr)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">exit_error</span><span class="hljs-params">()</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">is_valid_args</span><span class="hljs-params">(<span class="hljs-type">void</span>* esp, <span class="hljs-type">uint8_t</span> argc)</span>;<br><br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br></code></pre></td></tr></tbody></table></figure>
<p>在exception.c中修改</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">page_fault</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame *f)</span> <br>{<br>  <span class="hljs-type">bool</span> not_present;  <span class="hljs-comment">/* True: not-present page, false: writing r/o page. */</span><br>  <span class="hljs-type">bool</span> write;        <span class="hljs-comment">/* True: access was write, false: access was read. */</span><br>  <span class="hljs-type">bool</span> user;         <span class="hljs-comment">/* True: access by user, false: access by kernel. */</span><br>  <span class="hljs-type">void</span> *fault_addr;  <span class="hljs-comment">/* Fault address. */</span><br><br>  <span class="hljs-comment">/* Obtain faulting address, the virtual address that was</span><br><span class="hljs-comment">     accessed to cause the fault.  It may point to code or to</span><br><span class="hljs-comment">     data.  It is not necessarily the address of the instruction</span><br><span class="hljs-comment">     that caused the fault (that's f-&gt;eip).</span><br><span class="hljs-comment">     See [IA32-v2a] "MOV--Move to/from Control Registers" and</span><br><span class="hljs-comment">     [IA32-v3a] 5.15 "Interrupt 14--Page Fault Exception</span><br><span class="hljs-comment">     (#PF)". */</span><br>  <span class="hljs-keyword">asm</span> (<span class="hljs-string">"movl %%cr2, %0"</span> : <span class="hljs-string">"=r"</span> (fault_addr));<br><br>  <span class="hljs-comment">/* Turn interrupts back on (they were only off so that we could</span><br><span class="hljs-comment">     be assured of reading CR2 before it changed). */</span><br>  intr_enable ();<br><br>  <span class="hljs-comment">/* Count page faults. */</span><br>  page_fault_cnt++;<br><br>  <span class="hljs-comment">/* Determine cause. */</span><br>  not_present = (f-&gt;error_code &amp; PF_P) == <span class="hljs-number">0</span>;<br>  write = (f-&gt;error_code &amp; PF_W) != <span class="hljs-number">0</span>;<br>  user = (f-&gt;error_code &amp; PF_U) != <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span><br>  <span class="hljs-keyword">if</span>(user == <span class="hljs-number">0</span>)<br>  {<br>    f-&gt;eip = f-&gt;eax;<br>    f-&gt;eax = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span>;<br>  }<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br>  <span class="hljs-comment">/* To implement virtual memory, delete the rest of the function</span><br><span class="hljs-comment">     body, and replace it with code that brings in the page to</span><br><span class="hljs-comment">     which fault_addr refers. */</span><br>  <span class="hljs-built_in">printf</span> (<span class="hljs-string">"Page fault at %p: %s error %s page in %s context.\n"</span>,<br>          fault_addr,<br>          not_present ? <span class="hljs-string">"not present"</span> : <span class="hljs-string">"rights violation"</span>,<br>          write ? <span class="hljs-string">"writing"</span> : <span class="hljs-string">"reading"</span>,<br>          user ? <span class="hljs-string">"user"</span> : <span class="hljs-string">"kernel"</span>);<br>  kill (f);<br>}<br><br><br></code></pre></td></tr></tbody></table></figure>
<hr>
<h5 id="分析进程相关系统调用"><a class="markdownIt-Anchor" href="#分析进程相关系统调用"></a> 分析：进程相关系统调用</h5>
<p>我们先来完成进程相关的四个系统调用的实现：<strong>halt、exit、exec、wait</strong>。</p>
<p>首先是halt，手册对于halt的描述很简单，他说终止Pintos是靠shutdown_power_off（在<br>
‘devices/shutdown.h’中声明）进行的，那么这没什么好分析的，<strong>直接调用shutdown_power_off就完事了</strong>。</p>
<p>手册在exit、exec的描述中，都提到了父进程，这是什么呢？</p>
<p>父子进程在对wait的系统调用中进行了详细的说明。</p>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/process_wait.png)</p>
<p>上图描述比较清晰的描述了父子进程之间的关系：</p>
<ol>
<li>父进程首先创建子进程，让其加载用户程序。</li>
<li>若成功加载，则进行参数传递。</li>
<li>进行完1、2后，要告知父进程是否成功执行了1、2。</li>
<li>若子进程成功加载、传参，告知父进程，父进程将调用wait，等待子进程运行。</li>
<li>子进程开始运行，知道进程退出，并告知父进程退出信息。</li>
<li>如果父进程有多个子进程，则循环上述步骤。</li>
<li>以上操作设计到进程的同步关系，因此需要使用信号量保证它们的执行次序。</li>
</ol>
<h5 id="实现进程相关系统调用"><a class="markdownIt-Anchor" href="#实现进程相关系统调用"></a> 实现：进程相关系统调用</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 对于exec来说，输入是文件名+参数的字符串,首先是user_ptr</span><br><span class="hljs-comment"> * 存的是参数的地址，而输入的参数是字符串，即char*类型。</span><br><span class="hljs-comment"> * 首先应取出参数，然后将参数转换为char*类型即可。</span><br><span class="hljs-comment"> * 这里有点绕，简单来说就是*user_ptr取参数，(char*)将参数</span><br><span class="hljs-comment"> * 强制转换。 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_exec</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  <span class="hljs-type">uint32_t</span>* user_ptr = f-&gt;esp;<br>  check_valid(++user_ptr);<br>  check_valid(*user_ptr);<br>  f-&gt;eax = process_execute((<span class="hljs-type">char</span>*)* user_ptr);<br>}<br><br><span class="hljs-comment">/* wait输入的是1个pid，直接取出来即可，并且wait是有</span><br><span class="hljs-comment"> * 输出的，其输出为process的返回值，即退出信息码 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_wait</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  <span class="hljs-type">uint32_t</span>* user_ptr = f-&gt;esp;<br>  check_valid(++user_ptr);<br>  f-&gt;eax = process_wait(*user_ptr);<br>}<br><br><span class="hljs-comment">/* exit输入的是1个整型变量即退出状态，将其赋值给</span><br><span class="hljs-comment"> * 当前进程的退出信息数据中，然后调用线程退出函数。  */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_exit</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  <span class="hljs-type">uint32_t</span>* user_ptr = f-&gt;esp;<br>  check_valid(++user_ptr);<br>  thread_current()-&gt;exit_code = *user_ptr;<br>  thread_exit();<br>}<br><br><span class="hljs-comment">/* 关机函数，无输入参数，无返回值，直接调用关机</span><br><span class="hljs-comment"> * 函数即可。 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_halt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  shutdown_power_off();<br>  NOT_REACHED();<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>在process.c中添加</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Starts a new thread running a user program loaded from</span><br><span class="hljs-comment">   FILENAME.  The new thread may be scheduled (and may even exit)</span><br><span class="hljs-comment">   before process_execute() returns.  Returns the new process's</span><br><span class="hljs-comment">   thread id, or TID_ERROR if the thread cannot be created. */</span><br><span class="hljs-type">tid_t</span><br><span class="hljs-title function_">process_execute</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file_name)</span> <br>{<br>  <span class="hljs-type">char</span> *fn_copy;<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-type">char</span> *fn_copy_for_thread_name;<br>  <span class="hljs-type">char</span> *thread_name, *save_ptr; <br>  fn_copy_for_thread_name = palloc_get_page (<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  <span class="hljs-type">tid_t</span> tid;<br><br>  <span class="hljs-comment">/* Make a copy of FILE_NAME.</span><br><span class="hljs-comment">     Otherwise there's a race between the caller and load(). */</span><br>  fn_copy = palloc_get_page (<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (fn_copy == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> TID_ERROR;<br>  strlcpy (fn_copy, file_name, PGSIZE);<br><br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 复制一个字符串，用于分割文件名作为线程名 */</span><br>  strlcpy (fn_copy_for_thread_name, file_name, PGSIZE);<br>  thread_name = strtok_r (fn_copy_for_thread_name, <span class="hljs-string">" "</span>, &amp;save_ptr);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br>  <span class="hljs-comment">/* Create a new thread to execute FILE_NAME. */</span><br>  tid = thread_create (thread_name, PRI_DEFAULT, start_process, fn_copy);<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 别忘记把它释放掉 */</span><br>  palloc_free_page (fn_copy_for_thread_name); <br><br>  <span class="hljs-keyword">if</span> (tid == TID_ERROR){<br>    palloc_free_page (fn_copy); <br>    <span class="hljs-keyword">return</span> tid;<br>  }<br><br>  <span class="hljs-comment">/* 等待子进程装载，如果装载不成功则返回ERROR */</span><br>  sema_down(&amp;thread_current()-&gt;sema);<br>  <span class="hljs-keyword">if</span>(!thread_current()-&gt;is_load_success)<br>    <span class="hljs-keyword">return</span> TID_ERROR;<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  <span class="hljs-keyword">return</span> tid;<br>}<br><br><span class="hljs-comment">/* A thread function that loads a user process and starts it</span><br><span class="hljs-comment">   running. */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">start_process</span> <span class="hljs-params">(<span class="hljs-type">void</span> *file_name_)</span><br>{<br>  <span class="hljs-type">char</span> *file_name = file_name_;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intr_frame</span> <span class="hljs-title">if_</span>;</span><br>  <span class="hljs-type">bool</span> success;<br><br>  <span class="hljs-comment">/* Initialize interrupt frame and load executable. */</span><br>  <span class="hljs-built_in">memset</span> (&amp;if_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> if_);<br>  if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;<br>  if_.cs = SEL_UCSEG;<br>  if_.eflags = FLAG_IF | FLAG_MBS;<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 将真正的文件名装载进去，会造成字符串修改，而文件名</span><br><span class="hljs-comment">   * 也是参数的一部分，因此我们使用original来保存</span><br><span class="hljs-comment">   * 原字符串的副本  */</span><br>  <span class="hljs-type">char</span> *real_file_name, *original_name, *save_ptr; <br>  original_name = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(file_name)+<span class="hljs-number">1</span>);<br>  strlcpy (original_name, file_name, <span class="hljs-built_in">strlen</span>(file_name)+<span class="hljs-number">1</span>);<br>  real_file_name = strtok_r (file_name_, <span class="hljs-string">" "</span>, &amp;save_ptr);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  success = load (real_file_name, &amp;if_.eip, &amp;if_.esp);<br><br>  <span class="hljs-comment">/* If load failed, quit. */</span><br>  palloc_free_page (file_name);<br><br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 显然只有在成功装载之后，我们才需要参数传递 </span><br><span class="hljs-comment">   * 以下过程，就是把参数压入栈中，此处的顺序是自左向右</span><br><span class="hljs-comment">   * 这并没有什么关系，因为我们使用二级指针对参数压栈</span><br><span class="hljs-comment">   * 只需要保证压入二级指针时，是自右向左即可。</span><br><span class="hljs-comment">   * argv存储的是各个参数的首地址，即实际的二级指针</span><br><span class="hljs-comment">   * 而386系统中，地址是32位，因此使用int型。</span><br><span class="hljs-comment">   * argc则存储的是参数的个数。</span><br><span class="hljs-comment">   * 由于参数个数未知，我们使用动态分配地址的方法。 */</span><br><br>  <span class="hljs-type">int</span> argc = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> argv_size = <span class="hljs-number">50</span>;<br>  <span class="hljs-type">int</span>* argv = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>(argv_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>  <span class="hljs-type">char</span>* token;<br><br>  <span class="hljs-keyword">if</span>(success)<br>  {<br>    <span class="hljs-keyword">for</span> (token = strtok_r (original_name, <span class="hljs-string">" "</span>, &amp;save_ptr); token != <span class="hljs-literal">NULL</span>;<br>		             token = strtok_r (<span class="hljs-literal">NULL</span>, <span class="hljs-string">" "</span>, &amp;save_ptr))<br>    {<br>      <span class="hljs-comment">/* 字符串是低地址往高地址存，并且注意'\0'也是字符串</span><br><span class="hljs-comment">       * 的一部分 */</span><br>      if_.esp -= <span class="hljs-built_in">strlen</span>(token)+<span class="hljs-number">1</span>;<br>      <span class="hljs-built_in">memcpy</span>(if_.esp, token, <span class="hljs-built_in">strlen</span>(token)+<span class="hljs-number">1</span>);<br>      argv[argc++] = (<span class="hljs-type">int</span>) if_.esp;<br>      <span class="hljs-keyword">if</span> (argc &gt; argv_size)<br>      {<br>        <span class="hljs-comment">//  如果空间不够，得重新分配 </span><br>        argv_size += <span class="hljs-number">10</span>;<br>        <span class="hljs-built_in">realloc</span>(argv, argv_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>* )); <br>      }<br>    }<br><br>    push_arg_and_retaddr(&amp;if_.esp, argc, argv);<br><br>  }<br> <br><br>  <span class="hljs-comment">/* 告诉父线程自己装载情况，并让父线程继续执行 */</span><br>  thread_current()-&gt;parent-&gt;is_load_success = success;<br>  sema_up(&amp;thread_current()-&gt;parent-&gt;sema);<br><br>  <span class="hljs-built_in">free</span>(original_name);<br>  <span class="hljs-built_in">free</span>(argv);<br><br>  <span class="hljs-keyword">if</span>(!success)<br>    thread_exit();<br><br> <br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br>  <span class="hljs-comment">/* Start the user process by simulating a return from an</span><br><span class="hljs-comment">     interrupt, implemented by intr_exit (in</span><br><span class="hljs-comment">     threads/intr-stubs.S).  Because intr_exit takes all of its</span><br><span class="hljs-comment">     arguments on the stack in the form of a `struct intr_frame',</span><br><span class="hljs-comment">     we just point the stack pointer (%esp) to our stack frame</span><br><span class="hljs-comment">     and jump to it. */</span><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">"movl %0, %%esp; jmp intr_exit"</span> : : <span class="hljs-string">"g"</span> (&amp;if_) : <span class="hljs-string">"memory"</span>)</span>;<br>  NOT_REACHED ();<br>}<br><br><span class="hljs-comment">/* Waits for thread TID to die and returns its exit status.  If</span><br><span class="hljs-comment">   it was terminated by the kernel (i.e. killed due to an</span><br><span class="hljs-comment">   exception), returns -1.  If TID is invalid or if it was not a</span><br><span class="hljs-comment">   child of the calling process, or if process_wait() has already</span><br><span class="hljs-comment">   been successfully called for the given TID, returns -1</span><br><span class="hljs-comment">   immediately, without waiting.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   This function will be implemented in problem 2-2.  For now, it</span><br><span class="hljs-comment">   does nothing. */</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">process_wait</span> <span class="hljs-params">(<span class="hljs-type">tid_t</span> child_tid UNUSED)</span> <br>{<br> <br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 遍历整个child队列，如果发现child已经没被等待过了，那么</span><br><span class="hljs-comment">   * 阻塞自己，等待child执行，并置位等待标志位。如果child已经</span><br><span class="hljs-comment">   * 被等待过了，说明这是不正常的，应当返回-1。此外，子进程队列</span><br><span class="hljs-comment">   * 中没有对应的子进程ID，这也是非正常现象。  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span>* <span class="hljs-title">child_list</span> =</span> &amp;thread_current()-&gt;child_list;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span>* <span class="hljs-title">child_elem</span> =</span> list_begin(child_list);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">child_thread</span>* <span class="hljs-title">cur_child</span> =</span> <span class="hljs-literal">NULL</span>; <br>  <br>  <span class="hljs-keyword">while</span>(child_elem != list_end(child_list))<br>  { <br>    cur_child = list_entry(child_elem, <span class="hljs-keyword">struct</span> child_thread, elem);<br>    <span class="hljs-keyword">if</span>(cur_child-&gt;tid == child_tid)<br>      <span class="hljs-keyword">break</span>;<br>    child_elem = list_next(child_elem);<br>  }<br>  <br>  <span class="hljs-keyword">if</span>(child_elem == list_end(child_list) || cur_child-&gt;tid != child_tid)<br>  {<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  }<br>  <span class="hljs-keyword">else</span><br>  {<br>    cur_child-&gt;is_waited = <span class="hljs-literal">true</span>;<br>    sema_down(&amp;cur_child-&gt;sema);<br>    list_remove(child_elem);<br>  }<br><br>  <span class="hljs-keyword">return</span> cur_child-&gt;exit_code;<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>}<br><br></code></pre></td></tr></tbody></table></figure>
<hr>
<h5 id="分析文件相关系统调用"><a class="markdownIt-Anchor" href="#分析文件相关系统调用"></a> 分析：文件相关系统调用</h5>
<p>![](D:/ZJUT/Operating System/pintos/code/tmp/cic-master/pNotes.assets/file_syscall.png)</p>
<p>CREATE：主要就是调用filesys_create即可。</p>
<p>OPEN： 在用户打开文件时，要维护一个打开文件表，者可以用链表实现。文件表记录着每个文件的file结构体以及其相对应的fd。所谓fd是文件描述符，整型变量。对于一个进程来说，其打开的所有文件的文件描述符都是不相同的，但不同的进程相同文件可以有不同文件描述符。read、write、close等系统调用都是依据fd来操作的。</p>
<p>READ：读入文件描述符fd，然后在该进程的打开文件表中，找到fd对应的file，进行读操作即可。需要注意的是，fd=0时，是标准输入，此时可以调用input_getc，这样就能从键盘中读入字符了。</p>
<p>WRITE：与read类似，同样先是找到fd对应的file，进行写操作。类似的，fd=1表示标准输出，此时可以使用printf输出到屏幕即可。</p>
<p>CLOSE：在用户打开文件时，处了使用pintos提供的关闭文件操作，同时，还要将文件从打开文件表中删除。</p>
<p>REMOVE：主要就是调用filesys_remove即可。</p>
<p>FILESIZE、TELL和SEEK的执行机制都一样，都是通过fd找到对应的file，然后运行pintos文件系统提供的函数即可。</p>
<p><strong>注：以上的所有操作都要加锁，以互斥访问</strong></p>
<hr>
<h5 id="实现文件相关系统调用"><a class="markdownIt-Anchor" href="#实现文件相关系统调用"></a> 实现：文件相关系统调用</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 文件创建操作输入的参数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  <span class="hljs-type">uint32_t</span> *user_ptr = f-&gt;esp;<br>  <span class="hljs-comment">/* ??? */</span><br>  check_valid(user_ptr + <span class="hljs-number">5</span>);<br>  check_valid(*(user_ptr + <span class="hljs-number">4</span>));<br>  user_ptr++;<br><br>  acquire_file_lock();<br>  f-&gt;eax = filesys_create ((<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)*user_ptr, *(user_ptr+<span class="hljs-number">1</span>));<br>  release_file_lock();<br>}<br><br><span class="hljs-comment">/* 文件删除操作输入的参数为文件名 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br><br>  <span class="hljs-type">uint32_t</span> *user_ptr = f-&gt;esp;<br>  check_valid(++user_ptr);<br>  check_valid(*user_ptr);<br><br>  acquire_file_lock();<br>  f-&gt;eax = filesys_remove ((<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)*user_ptr);<br>  release_file_lock();<br><br>}<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  <span class="hljs-type">uint32_t</span> *user_ptr = f-&gt;esp;<br>  check_valid(user_ptr + <span class="hljs-number">1</span>);<br>  check_valid(*(user_ptr + <span class="hljs-number">1</span>));<br>  *user_ptr++;<br><br>  acquire_file_lock();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">file_opened</span> =</span> filesys_open((<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)*user_ptr);<br>  release_file_lock();<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> * <span class="hljs-title">t</span> =</span> thread_current();<br><br>  <span class="hljs-keyword">if</span> (file_opened)<br>  {<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_file</span> *<span class="hljs-title">thread_file_temp</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> thread_file));<br>    thread_file_temp-&gt;fd = t-&gt;fd++;<br>    thread_file_temp-&gt;file = file_opened;<br>    list_push_back (&amp;t-&gt;file_list, &amp;thread_file_temp-&gt;elem);<br>    f-&gt;eax = thread_file_temp-&gt;fd;<br>  } <br>  <span class="hljs-keyword">else</span><br>  {<br>    f-&gt;eax = <span class="hljs-number">-1</span>;<br>  }<br><br>}<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_close</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  <span class="hljs-type">uint32_t</span> *user_ptr = f-&gt;esp;<br>  check_valid(++user_ptr);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_file</span> * <span class="hljs-title">opened_file</span> =</span> find_file_by_fd (*user_ptr);<br>  <span class="hljs-keyword">if</span> (opened_file)<br>  {<br>    acquire_file_lock ();<br>    file_close (opened_file-&gt;file);<br>    release_file_lock ();<br>    list_remove (&amp;opened_file-&gt;elem);<br>    <span class="hljs-built_in">free</span>(opened_file);<br>  }<br><br>}<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{  <br>  <span class="hljs-type">int32_t</span> *user_ptr = f-&gt;esp;<br>  *user_ptr++;<br>  <span class="hljs-type">int</span> fd = *user_ptr;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">uint8_t</span> * buffer = (<span class="hljs-type">uint8_t</span>*)*(user_ptr+<span class="hljs-number">1</span>);<br>  <span class="hljs-type">uint32_t</span> size = *(user_ptr+<span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (!is_valid_args(buffer, <span class="hljs-number">1</span>) || !is_valid_args(buffer + size,<span class="hljs-number">1</span>))<br>  {<br>     exit_error();<br>  }<br><br>  <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">0</span>) <br>  {<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>    buffer[i] = input_getc();<br>    f-&gt;eax = size;<br>  }<br>  <span class="hljs-keyword">else</span><br>  {<br>    <span class="hljs-keyword">struct</span> thread_file * thread_file_temp = find_file_by_fd(*user_ptr);<br>    <span class="hljs-keyword">if</span> (thread_file_temp)<br>    {<br>      acquire_file_lock();<br>      f-&gt;eax = file_read (thread_file_temp-&gt;file, buffer, size);<br>      release_file_lock();<br>    } <br>    <span class="hljs-keyword">else</span><br>    {<br>      f-&gt;eax = <span class="hljs-number">-1</span>;<br>    }<br>  }<br><br>}<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  <span class="hljs-type">uint32_t</span> *user_ptr = f-&gt;esp;<br>  check_valid(user_ptr + <span class="hljs-number">7</span>);<br>  check_valid(*(user_ptr + <span class="hljs-number">6</span>));<br>  *user_ptr++;<br>  <span class="hljs-type">int</span> temp2 = *user_ptr;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> * buffer = (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)*(user_ptr+<span class="hljs-number">1</span>);<br>  <span class="hljs-type">uint32_t</span> size = *(user_ptr+<span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (temp2 == <span class="hljs-number">1</span>) <br>  {<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, buffer);<br>    f-&gt;eax = size;<br>  }<br>  <span class="hljs-keyword">else</span><br>  {<br>    <span class="hljs-keyword">struct</span> thread_file * thread_file_temp = find_file_by_fd(*user_ptr);<br>    <span class="hljs-keyword">if</span> (thread_file_temp)<br>    {<br>      acquire_file_lock();<br>      f-&gt;eax = file_write (thread_file_temp-&gt;file, buffer, size);<br>      release_file_lock();<br>    } <br>    <span class="hljs-keyword">else</span><br>    {<br>     f-&gt;eax = <span class="hljs-number">0</span>;<br>    }<br>  }<br><br>}<br><br><span class="hljs-comment">/* 通过输入的fd先取找到相应的file数据结构，在执行操作 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_filesize</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  <span class="hljs-type">uint32_t</span> *user_ptr = f-&gt;esp;<br>  check_valid(++user_ptr);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_file</span>* <span class="hljs-title">file_target</span> =</span> find_file_by_fd(*user_ptr);<br><br>  <span class="hljs-keyword">if</span>(file_target != <span class="hljs-literal">NULL</span>)<br>  {<br>    acquire_file_lock();<br>    f-&gt;eax = file_length(file_target-&gt;file);<br>    release_file_lock();<br>  } <br>  <span class="hljs-keyword">else</span><br>  {<br>    f-&gt;eax = <span class="hljs-number">-1</span>;<br>  }<br><br>}<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_seek</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br><br>  <span class="hljs-type">uint32_t</span> *user_ptr = f-&gt;esp;<br>  check_valid(user_ptr + <span class="hljs-number">5</span>);<br>  user_ptr++;<br>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_file</span>* <span class="hljs-title">file_target</span> =</span> find_file_by_fd(*user_ptr);<br>  <span class="hljs-keyword">if</span>(file_target)<br>  {<br>    acquire_file_lock();<br>    file_seek(file_target-&gt;file, *(user_ptr+<span class="hljs-number">1</span>));<br>    release_file_lock();<br>  }<br>  <span class="hljs-keyword">else</span><br>  {<br>    f-&gt;eax = <span class="hljs-number">-1</span>;<br>  }<br>}<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_tell</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  <span class="hljs-type">uint32_t</span> *user_ptr = f-&gt;esp;<br>  check_valid(++user_ptr);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_file</span>* <span class="hljs-title">file_target</span> =</span> find_file_by_fd(*user_ptr);<br>  <span class="hljs-keyword">if</span>(file_target)<br>  {<br>    acquire_file_lock();<br>    f-&gt;eax = file_tell(file_target-&gt;file);<br>    release_file_lock();<br>  }<br>  <span class="hljs-keyword">else</span><br>  {<br>    f-&gt;eax = <span class="hljs-number">-1</span>;<br>  }<br><br>}<br><br><span class="hljs-comment">/* 通过fd寻找file */</span><br><span class="hljs-keyword">struct</span> thread_file*<br><span class="hljs-title function_">find_file_by_fd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>{<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span>* <span class="hljs-title">e</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_file</span>* <span class="hljs-title">thread_file_ptr</span> =</span> <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span>* <span class="hljs-title">files</span> =</span> &amp;thread_current()-&gt;file_list;<br>  <span class="hljs-keyword">for</span>(e = list_begin (files); e != list_end (files); e = list_next(e))<br>  {<br>    thread_file_ptr = list_entry(e, <span class="hljs-keyword">struct</span> thread_file, elem);<br>    <span class="hljs-keyword">if</span> (fd == thread_file_ptr-&gt;fd)<br>      <span class="hljs-keyword">return</span> thread_file_ptr;<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="task4-denying-writes-to-executables"><a class="markdownIt-Anchor" href="#task4-denying-writes-to-executables"></a> Task4: Denying Writes to Executables</h4>
<h5 id="分析-5"><a class="markdownIt-Anchor" href="#分析-5"></a> 分析</h5>
<p>在文档中，它对该任务是这么描述的</p>
<figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">You can use file_deny_write() <span class="hljs-keyword">to</span> prevent writes <span class="hljs-keyword">to</span> an open <span class="hljs-built_in">file</span>. Calling file_allow_<br><span class="hljs-built_in">write</span>() <span class="hljs-keyword">on</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span> will re-enable them (unless <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span> <span class="hljs-keyword">is</span> denied writes <span class="hljs-keyword">by</span> another opener. Closing a <span class="hljs-built_in">file</span> will also re-enable writes. Thus,<span class="hljs-keyword">to</span> deny writes <span class="hljs-keyword">to</span> a process’s executable, you must keep <span class="hljs-keyword">it</span> open <span class="hljs-keyword">as</span> long <span class="hljs-keyword">as</span> <span class="hljs-keyword">the</span> process <span class="hljs-keyword">is</span> still <span class="hljs-built_in">running</span>.<br></code></pre></td></tr></tbody></table></figure>
<p>该任务的实现也很简单，就是在装载的时候调用file_deny_write拒绝写入。利用t-&gt;file_owned = file存储拥有的这个文件（即只有这个文件可以写），这是为了方便进程退出后关闭文件。还需注意的是，load中原本在结尾是要关闭文件的。但是，为了完成进程能够一致保持着对改文件的所有权，应注释掉file_close。而使之推迟至进程退出后执行。</p>
<h5 id="实现-5"><a class="markdownIt-Anchor" href="#实现-5"></a> 实现</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Loads an ELF executable from FILE_NAME into the current thread.</span><br><span class="hljs-comment">   Stores the executable's entry point into *EIP</span><br><span class="hljs-comment">   and its initial stack pointer into *ESP.</span><br><span class="hljs-comment">   Returns true if successful, false otherwise. */</span><br><span class="hljs-type">bool</span><br><span class="hljs-title function_">load</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file_name, <span class="hljs-type">void</span> (**eip) (<span class="hljs-type">void</span>), <span class="hljs-type">void</span> **esp)</span> <br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">t</span> =</span> thread_current ();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Elf32_Ehdr</span> <span class="hljs-title">ehdr</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span> =</span> <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-type">off_t</span> file_ofs;<br>  <span class="hljs-type">bool</span> success = <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">int</span> i;<br><br>  <span class="hljs-comment">/* Allocate and activate page directory. */</span><br>  t-&gt;pagedir = pagedir_create ();<br>  <span class="hljs-keyword">if</span> (t-&gt;pagedir == <span class="hljs-literal">NULL</span>) <br>    <span class="hljs-keyword">goto</span> done;<br>  process_activate ();<br><br>  <span class="hljs-comment">/* Open executable file. */</span><br>  <span class="hljs-comment">// acquire_file_lock();</span><br>  file = filesys_open (file_name);<br>  <span class="hljs-keyword">if</span> (file == <span class="hljs-literal">NULL</span>) <br>    {<br>      <span class="hljs-built_in">printf</span> (<span class="hljs-string">"load: %s: open failed\n"</span>, file_name);<br>      <span class="hljs-keyword">goto</span> done; <br>    }<br><br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br>  file_deny_write(file);<br>  t-&gt;file_owned = file;<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span> <br><br>  <span class="hljs-comment">/* Read and verify executable header. */</span><br>  <span class="hljs-keyword">if</span> (file_read (file, &amp;ehdr, <span class="hljs-keyword">sizeof</span> ehdr) != <span class="hljs-keyword">sizeof</span> ehdr<br>      || <span class="hljs-built_in">memcmp</span> (ehdr.e_ident, <span class="hljs-string">"\177ELF\1\1\1"</span>, <span class="hljs-number">7</span>)<br>      || ehdr.e_type != <span class="hljs-number">2</span><br>      || ehdr.e_machine != <span class="hljs-number">3</span><br>      || ehdr.e_version != <span class="hljs-number">1</span><br>      || ehdr.e_phentsize != <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> Elf32_Phdr)<br>      || ehdr.e_phnum &gt; <span class="hljs-number">1024</span>) <br>    {<br>      <span class="hljs-built_in">printf</span> (<span class="hljs-string">"load: %s: error loading executable\n"</span>, file_name);<br>      <span class="hljs-keyword">goto</span> done; <br>    }<br><br>  <span class="hljs-comment">/* Read program headers. */</span><br>  file_ofs = ehdr.e_phoff;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ehdr.e_phnum; i++) <br>    {<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Elf32_Phdr</span> <span class="hljs-title">phdr</span>;</span><br><br>      <span class="hljs-keyword">if</span> (file_ofs &lt; <span class="hljs-number">0</span> || file_ofs &gt; file_length (file))<br>        <span class="hljs-keyword">goto</span> done;<br>      file_seek (file, file_ofs);<br><br>      <span class="hljs-keyword">if</span> (file_read (file, &amp;phdr, <span class="hljs-keyword">sizeof</span> phdr) != <span class="hljs-keyword">sizeof</span> phdr)<br>        <span class="hljs-keyword">goto</span> done;<br>      file_ofs += <span class="hljs-keyword">sizeof</span> phdr;<br>      <span class="hljs-keyword">switch</span> (phdr.p_type) <br>        {<br>        <span class="hljs-keyword">case</span> PT_NULL:<br>        <span class="hljs-keyword">case</span> PT_NOTE:<br>        <span class="hljs-keyword">case</span> PT_PHDR:<br>        <span class="hljs-keyword">case</span> PT_STACK:<br>        <span class="hljs-keyword">default</span>:<br>          <span class="hljs-comment">/* Ignore this segment. */</span><br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> PT_DYNAMIC:<br>        <span class="hljs-keyword">case</span> PT_INTERP:<br>        <span class="hljs-keyword">case</span> PT_SHLIB:<br>          <span class="hljs-keyword">goto</span> done;<br>        <span class="hljs-keyword">case</span> PT_LOAD:<br>          <span class="hljs-keyword">if</span> (validate_segment (&amp;phdr, file)) <br>            {<br>              <span class="hljs-type">bool</span> writable = (phdr.p_flags &amp; PF_W) != <span class="hljs-number">0</span>;<br>              <span class="hljs-type">uint32_t</span> file_page = phdr.p_offset &amp; ~PGMASK;<br>              <span class="hljs-type">uint32_t</span> mem_page = phdr.p_vaddr &amp; ~PGMASK;<br>              <span class="hljs-type">uint32_t</span> page_offset = phdr.p_vaddr &amp; PGMASK;<br>              <span class="hljs-type">uint32_t</span> read_bytes, zero_bytes;<br>              <span class="hljs-keyword">if</span> (phdr.p_filesz &gt; <span class="hljs-number">0</span>)<br>                {<br>                  <span class="hljs-comment">/* Normal segment.</span><br><span class="hljs-comment">                     Read initial part from disk and zero the rest. */</span><br>                  read_bytes = page_offset + phdr.p_filesz;<br>                  zero_bytes = (ROUND_UP (page_offset + phdr.p_memsz, PGSIZE)<br>                                - read_bytes);<br>                }<br>              <span class="hljs-keyword">else</span> <br>                {<br>                  <span class="hljs-comment">/* Entirely zero.</span><br><span class="hljs-comment">                     Don't read anything from disk. */</span><br>                  read_bytes = <span class="hljs-number">0</span>;<br>                  zero_bytes = ROUND_UP (page_offset + phdr.p_memsz, PGSIZE);<br>                }<br>              <span class="hljs-keyword">if</span> (!load_segment (file, file_page, (<span class="hljs-type">void</span> *) mem_page,<br>                                 read_bytes, zero_bytes, writable))<br>                <span class="hljs-keyword">goto</span> done;<br>            }<br>          <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">goto</span> done;<br>          <span class="hljs-keyword">break</span>;<br>        }<br>    }<br><br>  <span class="hljs-comment">/* Set up stack. */</span><br>  <span class="hljs-keyword">if</span> (!setup_stack (esp))<br>    <span class="hljs-keyword">goto</span> done;<br><br>  <span class="hljs-comment">/* Start address. */</span><br>  *eip = (<span class="hljs-type">void</span> (*) (<span class="hljs-type">void</span>)) ehdr.e_entry;<br><br>  success = <span class="hljs-literal">true</span>;<br><br> done:<br>  <span class="hljs-comment">/* We arrive here whether the load is successful or not. */</span><br>  <span class="hljs-comment">// file_close (file);</span><br>  <span class="hljs-keyword">return</span> success;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>在thread.c中添加</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">thread_exit</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>{<br>  ASSERT (!intr_context ());<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USERPROG</span><br>  process_exit ();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-comment">/* Remove thread from all threads list, set our status to dying,</span><br><span class="hljs-comment">     and schedule another process.  That process will destroy us</span><br><span class="hljs-comment">     when it calls thread_schedule_tail(). */</span><br>  intr_disable ();<br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span>	<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USERPROG</span><br>  <span class="hljs-comment">/* 告诉父进程自己的退出码 */</span><br>  thread_current()-&gt;child-&gt;exit_code = thread_current()-&gt;exit_code;<br>  sema_up(&amp;thread_current()-&gt;child-&gt;sema);<br>  file_close (thread_current ()-&gt;file_owned);<br>  close_all_files();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span>	<br>  <br>  list_remove (&amp;thread_current()-&gt;allelem);<br>  thread_current ()-&gt;status = THREAD_DYING;<br>  schedule ();<br>  NOT_REACHED ();<br>}<br><br></code></pre></td></tr></tbody></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="category-chain-item">操作系统</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">#操作系统</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>操作系统知识整理</div>
      <div>http://vitaminzl.com/2022/08/20/os/cao-zuo-xi-tong-zhi-shi-dian-zheng-li/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>vitaminzl</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年8月20日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/08/20/os/cao-zuo-xi-tong-shi-yan-pintos/" title="操作系统实验-Pintos">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统实验-Pintos</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/21/dsandalg/gao-ji-suan-fa-chu-deng-shu-lun/" title="高级算法：初等数论">
                        <span class="hidden-mobile">高级算法：初等数论</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"N5b4uVEvRE5UcVcWvkv2ln10-gzGzoHsz","appKey":"KJFp10KGLr5F9HxFUUsL2AeD","path":"window.location.pathname","placeholder":"你的意见至关重要！","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
