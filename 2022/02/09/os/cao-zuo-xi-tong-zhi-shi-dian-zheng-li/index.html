

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/image/cat.png">
  <link rel="icon" href="/image/cat.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="vitaminzl">
  <meta name="keywords" content="">
  
    <meta name="description" content="Operating System 操作系统概述 计算机资源的管理者 主要管理处理机、存储器、文件、设备。 为用户提供硬件系统的接口 命令接口（shell，又分联机、脱机）和系统调用（又称广义指令，用于请求系统服务） 最基本的特征 并发（不是并行）、共享 系统调用  image-20211211190408030  系统调用和库函数 库函数是语言或应用程序的一部分，可以运行再用户空间中。而系统调用是">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统知识整理">
<meta property="og:url" content="http://vitaminzl.com/2022/02/09/os/cao-zuo-xi-tong-zhi-shi-dian-zheng-li/index.html">
<meta property="og:site_name" content="闲渔">
<meta property="og:description" content="Operating System 操作系统概述 计算机资源的管理者 主要管理处理机、存储器、文件、设备。 为用户提供硬件系统的接口 命令接口（shell，又分联机、脱机）和系统调用（又称广义指令，用于请求系统服务） 最基本的特征 并发（不是并行）、共享 系统调用  image-20211211190408030  系统调用和库函数 库函数是语言或应用程序的一部分，可以运行再用户空间中。而系统调用是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:/ZJUT/OS/Notes/notes.assets/image-20211211190408030.png">
<meta property="og:image" content="d:/ZJUT/OS/Notes/notes.assets/image-20211211192551500.png">
<meta property="og:image" content="d:/ZJUT/OS/Notes/notes.assets/image-20211210104231984.png">
<meta property="og:image" content="d:/ZJUT/OS/Notes/notes.assets/image-20211210104931119.png">
<meta property="og:image" content="d:/ZJUT/OS/Notes/notes.assets/image-20211210110941976.png">
<meta property="og:image" content="d:/ZJUT/OS/Notes/notes.assets/image-20211210112136928.png">
<meta property="og:image" content="d:/ZJUT/OS/Notes/notes.assets/image-20211210112152550.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190808150452263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5MDE4Mjc3,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210601155400267.jpg#pic_center">
<meta property="og:image" content="d:/ZJUT/OS/Notes/notes.assets/image-20211213111615507.png">
<meta property="og:image" content="d:/ZJUT/OS/Notes/notes.assets/image-20211213113003434.png">
<meta property="og:image" content="d:/ZJUT/OS/Notes/notes.assets/image-20211213113037695.png">
<meta property="article:published_time" content="2022-02-09T04:00:00.000Z">
<meta property="article:modified_time" content="2022-09-01T15:32:39.554Z">
<meta property="article:author" content="vitaminzl">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="d:/ZJUT/OS/Notes/notes.assets/image-20211211190408030.png">
  
  
  
  <title>操作系统知识整理 - 闲渔</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"vitaminzl.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="闲渔" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>闲渔</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/image/snow-small.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="操作系统知识整理"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-02-09 12:00" pubdate>
          2022年2月9日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          50 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">操作系统知识整理</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="operating-system">Operating System</h1>
<h2 id="操作系统概述">操作系统概述</h2>
<h3 id="计算机资源的管理者">计算机资源的管理者</h3>
<p>主要管理处理机、存储器、文件、设备。</p>
<h3 id="为用户提供硬件系统的接口">为用户提供硬件系统的接口</h3>
<p>命令接口（shell，又分联机、脱机）和系统调用（又称广义指令，用于请求系统<strong>服务</strong>）</p>
<h3 id="最基本的特征">最基本的特征</h3>
<p>并发（<strong>不是并行</strong>）、共享</p>
<h3 id="系统调用">系统调用</h3>
<figure>
<img src="D:\ZJUT\OS\Notes\notes.assets\image-20211211190408030.png" srcset="/img/loading.gif" lazyload alt="image-20211211190408030"><figcaption aria-hidden="true">image-20211211190408030</figcaption>
</figure>
<h4 id="系统调用和库函数">系统调用和库函数</h4>
<p>库函数是语言或应用程序的一部分，可以运行再用户空间中。而系统调用是操作系统的一部分，是内核为用户提供的程序接口，运行再内核空间中，而且许多库函数都会使用系统调用来实现功能。未使用系统调用的库函数，其执行效率通常要比系统调用的高。因为使用系统调用时，需要上下文切换及状态的转换（用户态转为和心态）。</p>
<h3 id="操作发展史">操作发展史</h3>
<p>手工操作系统（=没有操作系统）--&gt;批处理阶段</p>
<figure>
<img src="D:\ZJUT\OS\Notes\notes.assets\image-20211211192551500.png" srcset="/img/loading.gif" lazyload alt="image-20211211192551500"><figcaption aria-hidden="true">image-20211211192551500</figcaption>
</figure>
<h4 id="手工操作系统">手工操作系统</h4>
<p>略</p>
<h4 id="批处理阶段">批处理阶段</h4>
<h5 id="单道批处理系统">单道批处理系统</h5>
<p>如磁带</p>
<p>自动性、顺序性、单道性</p>
<h5 id="多道批处理系统">多道批处理系统</h5>
<p>多道、宏观上并行、微观上串行</p>
<p>多道程序设计的基本特征：制约性、间断性、共享性</p>
<h4 id="分时操作系统">分时操作系统</h4>
<p>同时性：多路性，多个用户同时使用一个计算机</p>
<p>交互性：通过终端进行人机交互、人机对话</p>
<p>独立性：用户之间独立操作、互不干扰</p>
<p>及时性：时间片轮转，响应时间短</p>
<h4 id="实时操作系统">实时操作系统</h4>
<p>硬实时：某个动作必须再规定时间内完成，如飞行器系统</p>
<p>软实时：可偶尔超出规定时间，如飞机订票、银行管理等</p>
<h4 id="网络操作系统和分布式系统">网络操作系统和分布式系统</h4>
<p>略</p>
<h4 id="个人计算机操作系统">个人计算机操作系统</h4>
<p>如windows、linux等</p>
<h3 id="操作系统运行环境">操作系统运行环境</h3>
<h2 id="内存管理">内存管理</h2>
<h3 id="硬件">硬件</h3>
<p>内存管理的实现高度依赖硬件</p>
<p><strong>MMU（内存管理单元）</strong></p>
<h3 id="操作系统">操作系统</h3>
<ol type="1">
<li>重定位</li>
<li>分段</li>
<li>分页</li>
<li>虚拟内存</li>
</ol>
<h3 id="地址">地址</h3>
<h4 id="物理地址空间">物理地址空间</h4>
<p>由物理地址线决定</p>
<p>显然，程序员并不好直接使用物理地址空间</p>
<h4 id="逻辑地址空间">逻辑地址空间</h4>
<p>运行的进程，所能看到的地址</p>
<h4 id="地址生成">地址生成</h4>
<p>一个c程序的执行之旅：</p>
<p>.c .h文件 -&gt; 编译 -&gt; 汇编 -&gt; 链接 -&gt; 程序加载（重定位）</p>
<h5 id="生成时机">生成时机</h5>
<p>逻辑地址</p>
<ol type="1">
<li><p>编译时就会产生逻辑地址</p></li>
<li><p>但链接后会产生最终的逻辑地址</p></li>
</ol>
<p>可重入程序</p>
<p>​ 一个此程序被某进程调用，还未结束，又被另一个进程调用</p>
<p>​ 共享使用同一块存储空间的，或者通过动态链接的方式将所需的程序段映射到相关进程中去，减少对换信息量来改善系统响应时间</p>
<p>物理地址有3种情况：</p>
<ol type="1">
<li>编译时就生成地址，程序写死了</li>
<li>加载时，通过重定位生成物理地址</li>
<li>执行时生成地址</li>
</ol>
<h5 id="生成过程">生成过程</h5>
<p>ALU MMU 地址映射</p>
<h3 id="内存分配">内存分配</h3>
<h4 id="连续内存分配">连续内存分配</h4>
<p>根据空闲分区表、寻找空闲区域、释放区域的不同可分为</p>
<h5 id="最先分配">最先分配</h5>
<p>分配n个字节,使用第一个可用的空间比n大的空闲块。</p>
<h5 id="最优匹配">最优匹配</h5>
<p>分配n字节分区时，查找并使用不小于n的最小空闲分区</p>
<h5 id="最差匹配">最差匹配</h5>
<p>分配n字节，使用尺寸不小于n的最大空闲分区</p>
<h4 id="碎片整理">碎片整理</h4>
<h5 id="紧凑compaction">紧凑（compaction）</h5>
<p>紧凑的条件：可动态重定位</p>
<h5 id="分区对换swapping-inout">分区对换（swapping in/out）</h5>
<h4 id="伙伴系统buddy-system">伙伴系统（buddy system）</h4>
<p>整个可分配的分区大小<span class="math inline">\(2^u\)</span>，需要的分区大小<span class="math inline">\(s\)</span>满足<span class="math inline">\(2^{u-1}&lt;s&lt;2^u\)</span>。 空闲块按大小和起始地址组织成二维数组，初始地址只有一个大小为<span class="math inline">\(2^u\)</span></p>
<h3 id="非连续分配">非连续分配</h3>
<p>需解决的问题 虚拟地址和物理地址的转换</p>
<ol type="1">
<li>软件实现</li>
<li>硬件实现</li>
</ol>
<p>内存分块的大小问题</p>
<ol type="1">
<li>段式存储</li>
<li>页式存储</li>
</ol>
<h3 id="段式存储">段式存储</h3>
<h4 id="分门别类">分门别类</h4>
<p>我们在整理东西的时候，很多时候会把属性、类别相似的东西放在一起<br>
对于不同类别的东西分别放在不同的地方<br>
那么段式存储用的就是这样的想法</p>
<p>进程的段地址空间由多个段组成<br>
例如我们通常将逻辑地址分为堆栈段、数据段、代码段<br>
可以看到段的分离是具有意义的，而且一个段的大小也是不一定的<br>
作用：更细粒度和灵活的分离和共享（？）</p>
<h4 id="什么是段">什么是段</h4>
<p><strong>段（segment）</strong>表示访问方式和存储数据等属性相同的一段地址空间<br>
对应一个连续内存的“块”<br>
若干个段组成进程的逻辑地址空间<br>
段访问：段号：段内偏移地址</p>
<p>硬件实现：段号-&gt;查段表-&gt;段描述符-&gt;合法性检查-&gt;段基址+偏移地址=物理地址</p>
<h3 id="页式存储">页式存储</h3>
<h4 id="固定大小">固定大小</h4>
<p>如果说段解决了我们对代码分门别类的需要<br>
段内连续，段间不连续<br>
而一个段的大小是不固定的，那么很容易造成连续内存管理中的碎片问题<br>
有没有可能让段内地址也不连续呢？把它们也分开来？</p>
<p>当然可以！如果将内存分成一个个<strong>固定大小</strong>的抽屉<br>
然后把段内地址空间塞到一个个抽屉里，那就可以把段内的地址空间页拆开了<br>
若是要寻找实际的物理地址，只需要在维护一张目录就可以了（即每个部分放在第几号抽屉）<br>
这就是<strong>页</strong></p>
<h4 id="什么是页">什么是页</h4>
<p>进程内逻辑地址空间被划分为大小相等的<strong>页（page）</strong><br>
物理内存被划分为大小相等（与页大小相等）的<strong>帧（Frame）</strong><br>
页是逻辑地址的概念，而帧是物理地址的概念<br>
页内偏移地址 = 帧内偏移地址</p>
<p>页-&gt;帧<br>
页号-&gt;页表-&gt;帧号-&gt;帧号+偏移地址=物理地址</p>
<h4 id="存储页的索引或目录页表page-table">存储页的索引或目录——页表（Page Table）</h4>
<p>每个进程都维护着一个页表<br>
每个页面对应一个页表项（或者页描述符）<br>
随进程的运行状态而动态变化<br>
页表项中可能有以下标志位（取决于具体硬件）：</p>
<ol type="1">
<li>存在位：分配时根据该标志位来决定是否分配</li>
<li>修改位</li>
<li>引用位</li>
</ol>
<h4 id="快表与多级页表">快表与多级页表</h4>
<p>页式存储带来的问题：</p>
<ol type="1">
<li>性能问题，二次访问：先访问页表，再访问实际内存</li>
<li>页表本身也需要占用存储空间</li>
</ol>
<h5 id="快表translation-look-aside-buffer-tlb">快表（Translation Look-aside Buffer, TLB）</h5>
<p>对于问题1，将上一次的访问页表项缓存下来<br>
TLB使用关联存储（硬件实现，具有并行、速度快、功耗高、容量小的特定）来实现<br>
TLB就类似于CPU中的cache</p>
<h5 id="多级页表">多级页表</h5>
<p>对于问题2，间接访问（再建一个目录，目录的目录），即多级页表<br>
对于k级页表，要访问k+1次<br>
如80386就是二级页表机制<br>
之所以可以减少空间的浪费，拿二级页表为例，若一级页表某个页表项存在位为0<br>
那么对应的二级页表也就不需要维护了</p>
<h5 id="反置页表">反置页表</h5>
<p>对于问题2，除了多级页表的解决方法，还可以改进<br>
显然多级页表需要增加访问次数，降低效率</p>
<h4 id="section"></h4>
<h3 id="段页式存储">段页式存储</h3>
<h3 id="虚拟内存">虚拟内存</h3>
<h4 id="外存">外存</h4>
<p>传统内存：一次性、驻留性</p>
<p>内存不够，有时需要短暂的将进程移到外存中去</p>
<h4 id="覆盖和交换">覆盖和交换</h4>
<ol type="1">
<li>覆盖：通过进程中的各模块的调用顺序来节省空间</li>
</ol>
<p></p><pre><code class=" mermaid">graph LR
A--&gt;B
A--&gt;C
B--&gt;D
C--&gt;E
C--&gt;F

</code></pre><p></p>
<ol start="2" type="1">
<li>交换</li>
</ol>
<h4 id="局部性原理">局部性原理</h4>
<p>时间局部性：某个指令或数据被执行或访问过，那么近期很可能还会在执行或访问</p>
<p>空间局部性：程序访问了某个存储单元，那么很可能会访问该存储单元附近的存储单元</p>
<p>快表（TLB）是局部性原理的应用之一。</p>
<h4 id="容量">容量</h4>
<p>虚拟内存的最大容量：寻址范围</p>
<p>实际容量：min(内存与外存的容量之和, 寻址范围)。</p>
<h4 id="特性">特性</h4>
<p>多次性：允许数据多次调如内存</p>
<p>对换性：作业运行时，无需一直常驻内存</p>
<p>虚拟性：对于用户来说，内存的虚拟容量提升</p>
<h4 id="虚拟页式存储">虚拟页式存储</h4>
<p>功能：请求调页、页面置换</p>
<h3 id="请求调页">请求调页</h3>
<h4 id="页表机制">页表机制</h4>
<p>状态位：调入内存？</p>
<p>访问字段：访问次数？上一次访问时间？</p>
<p>修改位：修改过？写指令，才修改，并且只修改快表中的内容，快表项删除时，再写回</p>
<p>外存地址：存在哪块？</p>
<h4 id="缺页中断机构">缺页中断机构</h4>
<p>产生缺页中断（内中断），故障（fault）</p>
<p>可能产生多次中断，因为一条指令可能访问多个存储的单元</p>
<p>缺页进程被阻塞：</p>
<ol type="1">
<li><p>若内存有空闲块，则为进程分配一个空闲块</p></li>
<li><p>若无，则使用<strong>页面置换算法</strong>，淘汰一个页面</p></li>
</ol>
<p>若有快表：</p>
<p>查询快表-&gt;缺页-&gt;查慢表-&gt;调页至内存-&gt;复制到快表</p>
<h4 id="地址变换机构">地址变换机构</h4>
<p>请求调页：先进行判断，是否存在</p>
<p>页面置换：页面置换</p>
<p>是否修改：。。只有写指令才需要改变修改位</p>
<p>先在快表中查，若快表没有，再在慢表中查</p>
<p>某个页面调出外存，则应删除快表中的内容</p>
<h3 id="页面置换算法">页面置换算法</h3>
<h4 id="置换算法的评价">置换算法的评价</h4>
<p>置换过程中，缺页的次数</p>
<p>如访问顺序为a, b, a, c, b, d, c, a...</p>
<p>在访问过程中缺页的次数</p>
<p>缺页率=缺页次数/访问次数</p>
<h4 id="算法分类">算法分类</h4>
<h5 id="局部页面置换算法">局部页面置换算法</h5>
<p>仅限当前进程占用的物理页面</p>
<ul>
<li><p>最优算法、先进先出、最近最久未使用</p></li>
<li><p>时钟算法、最不常用算法</p></li>
</ul>
<h5 id="全局页面置换算法">全局页面置换算法</h5>
<p>范围是所有可换出的物理页面</p>
<ul>
<li>工作集算法、缺页率算法</li>
</ul>
<h4 id="局部页面置换详解">局部页面置换详解</h4>
<h5 id="最优算法opt">最优算法（OPT）</h5>
<p>选择未来最长时间不访问的页面进行置换</p>
<p>第一次使用离目前时间最远的</p>
<p>显然这无法实现，因为无法预知未来</p>
<p>该算法的意义是作为baseline，评估其他的优劣</p>
<h5 id="先进先出fifo">先进先出（FIFO）</h5>
<p>实现简单，但性能较差</p>
<p>很少单独使用</p>
<h5 id="最近最久未使用lru">最近最久未使用（LRU）</h5>
<p>Leat Recently Used</p>
<p>选择过去最久未访问的页面置换，是OPT的近似</p>
<p>OPT是往后，LRU是往前</p>
<p>记录过去访问此处最少的页面，进行置换</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">		序号 <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br>假设访问次数为 c <span class="hljs-selector-tag">a</span> d <span class="hljs-selector-tag">b</span> e <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c d<br>最开始的物理存储顺序为  <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c d<br>在访问e时缺页<br><span class="hljs-selector-tag">a</span> = <span class="hljs-number">2</span> (数字就是最近访问的序号)<br><span class="hljs-selector-tag">b</span> = <span class="hljs-number">4</span><br>c = <span class="hljs-number">1</span><br>d = <span class="hljs-number">3</span><br>选择最小的d<br>物理存储顺序改为 <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c e<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><p>可能的实现方法</p>
<ul>
<li><p>维护一个按最近一次访问时间排序的链表</p></li>
<li><p>活动页面栈，压入栈后，把相同的页号抽出来</p>
<p><img src="D:\ZJUT\OS\Notes\notes.assets\image-20211210104231984.png" srcset="/img/loading.gif" lazyload alt="image-20211210104231984" style="zoom:33%;"></p></li>
</ul></li>
<li><p>时间空间开销都太大，算法复杂</p></li>
</ul>
<h5 id="时钟算法clock">时钟算法（Clock）</h5>
<p>对页面访问的情况进行大致统计</p>
<p>页表项中增加<strong>访问位</strong>，各页面组织成一个<strong>环形链表</strong>，指针指向最先调入的页面</p>
<p>缺页时<strong>从指针开始处（从头开始？）顺序查找未被访问的页面</strong>进行置换</p>
<p><img src="D:\ZJUT\OS\Notes\notes.assets\image-20211210104931119.png" srcset="/img/loading.gif" lazyload alt="image-20211210104931119" style="zoom:33%;"></p>
<p>对FIFO和LRU做了折中</p>
<figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">		序号<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 5 </span>6<span class="hljs-number"> 7 </span>8<span class="hljs-number"> 9 </span>10<br>假设访问次数为 c a d b e b a b c d<br>最开始的物理存储顺序为  a b c d<br>在访问到e时，此时<br>a =<span class="hljs-number"> 1 </span>b =<span class="hljs-number"> 1 </span>c =<span class="hljs-number"> 1 </span>d =<span class="hljs-number"> 1 </span><br>缺页后，会从指针开始处a（为啥是从头开始？）<br>a =<span class="hljs-number"> 0 </span>b =<span class="hljs-number"> 0 </span>c =<span class="hljs-number"> 0 </span>d = 0<br>一句话概括缺页情况：遇1则0，遇0则换，换则置1<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><p>改进的Clock算法</p>
<p>四轮扫描版</p>
<p>第一轮：(0, 0) 不改变</p>
<p>第二轮：(0, 1) 访问帧-&gt;0</p>
<p>第三轮：(0, 0) 不改变</p>
<p>第四轮：(0, 1)</p>
<p>二轮扫描版</p>
<p>考虑到对于修改过的部分，若要置换则要写回到缓冲区、磁盘中去，这也是一个开销</p>
<figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">		序号<span class="hljs-number"> 1 </span>2  <span class="hljs-number"> 3 </span>4  <span class="hljs-number"> 5 </span>6<span class="hljs-number"> 7 </span> <span class="hljs-number"> 8 </span>9 10<br>假设访问次数为 c a_w d b_w e b a_w b c d<br>最开始的物理存储顺序为  a b c d<br>在访问到e时，此时<br>xx表示 访问位 修改位<br>a =<span class="hljs-number"> 11 </span>b =<span class="hljs-number"> 11 </span>c =<span class="hljs-number"> 10 </span>d =<span class="hljs-number"> 10 </span><br>缺页后，会从指针开始处a（为啥是从头开始？）<br>a =<span class="hljs-number"> 01 </span>b =<span class="hljs-number"> 01 </span>c =<span class="hljs-number"> 00 </span>d = 00<br>a =<span class="hljs-number"> 00 </span>b =<span class="hljs-number"> 00 </span>置换c<br>一句话概括缺页情况：遇11则01，遇01则00，遇00则换，换则置10/11<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h5 id="最不常用算法lfu">最不常用算法（LFU）</h5>
<p>Least Frequency Used</p>
<p>与LRU的区别在于，它统计的是访问次数</p>
<p><img src="D:\ZJUT\OS\Notes\notes.assets\image-20211210110941976.png" srcset="/img/loading.gif" lazyload alt="image-20211210110941976" style="zoom:33%;"></p>
<h5 id="belady现象">Belady现象</h5>
<p>使用FIFO等算法时，物理页面数增加，缺页次数也增加的现象</p>
<p>哪些算法可能出现Belady现象？</p>
<p>FIFO。</p>
<h5 id="算法的比较">算法的比较</h5>
<p>LRU、FIFO本质都是先进先出的思路</p>
<p>LRU可退化成FIFO</p>
<p>Clock是二者的折中</p>
<h4 id="全局页面置换详解">全局页面置换详解</h4>
<p><img src="D:\ZJUT\OS\Notes\notes.assets\image-20211210112136928.png" srcset="/img/loading.gif" lazyload alt="image-20211210112136928" style="zoom:33%;"><img src="D:\ZJUT\OS\Notes\notes.assets\image-20211210112152550.png" srcset="/img/loading.gif" lazyload alt="image-20211210112152550" style="zoom:33%;"></p>
<p>如上图所示，页面增加1个，缺页率大大下降</p>
<p>全局页面置换算法要考虑的是<strong>给进程分配可变数目的物理页面</strong>。</p>
<p>进程在执行过程中，内存的需求是变化的，如何动态给进程分配物理页面</p>
<p>对换区，连续分配，读写速度更快；文件区，离散分配</p>
<p>unix方式：第一次调入，空间不够调入对换区，再使用的话再从对换区调入内存</p>
<p>不存在固定分配全局置换的方式。</p>
<h5 id="抖动和负载控制">抖动和负载控制</h5>
<p>抖动：刚换入内存，又要换出外存</p>
<h5 id="工作集算法">工作集算法</h5>
<p>驻留集：请求分页存储管理中给进程分配的物理块的集和</p>
<p>工作集：某段时间（窗口）内，进程实际访问的页面集合</p>
<p>驻留集不能小于工作集的大小</p>
<h2 id="调度">调度</h2>
<h3 id="评价指标">评价指标</h3>
<p><img src="https://img-blog.csdnimg.cn/20190808150452263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5MDE4Mjc3,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom: 33%;"></p>
<p>等待时间=周转时间-运行时间-(I/O时间)</p>
<h3 id="fcfs">FCFS</h3>
<h4 id="简述">简述</h4>
<p>First-Come-First-Served. 先来先服务。</p>
<h4 id="特点">特点</h4>
<ul>
<li>简单且垃圾</li>
</ul>
<h3 id="spnsjf">SPN(SJF)</h3>
<h4 id="简述-1">简述</h4>
<p>Short Process Next. 短进程优先算法。若一个进程正在执行，然后又来一个进程，该进程的<strong>预期时间</strong>要比正在运行的进程<strong>预期剩余时间</strong>要短，则允许其抢占（<strong>SRT</strong>，短剩余时间优先）。至于<strong>预期时间</strong>，一是可询问用户，二可以通过过去预测未来。对于后者，<span class="math inline">\(\tau_{n+1}=\alpha t_n + (1-\alpha)\tau_n = \alpha t_n + (1-\alpha)\alpha t_n+(1-\alpha)(1-\alpha)t_{n-2}+\dots\)</span></p>
<p>选择<strong>当前已经到达</strong>的<strong>等待时间最短</strong>的进程</p>
<h4 id="优点">优点</h4>
<ul>
<li><p>最优平均周转时间（所有进程几乎同时到达的情况下）</p>
<ul>
<li><p>证明：</p>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+-----------------------------------------------------------+</span><br><span class="hljs-section">| c1 |   c2   |		c3		 |				c4				|</span><br><span class="hljs-section">+-----------------------------------------------------------+</span><br>0  r1     	 r2             r3	   							r4<br>平均周转时间为(r1<span class="hljs-code">+r2+</span>r3+r4)/4<br><span class="hljs-section">任意调换2个进程</span><br><span class="hljs-section">+-----------------------------------------------------------+</span><br><span class="hljs-section">| c1 |				c4				|   c2   |		c3	    |</span><br><span class="hljs-section">+-----------------------------------------------------------+</span><br>0	r1							r3-c2-c3<span class="hljs-code">+c4	r2+</span>c4			r4<br>平均周转时间为(r1<span class="hljs-code">+r2+</span>r3<span class="hljs-code">+r4+</span>2<span class="hljs-strong">*c4-c2-c3)</span><br><span class="hljs-strong">又c4&gt;c2,c4&gt;c3，所以2*</span>c4-c2-c3&gt;0，调换之后时间更长。<br></code></pre></td></tr></tbody></table></figure></li>
</ul></li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>饥饿
<ul>
<li>长进程持续得不到执行</li>
</ul></li>
<li>预期时间不好预测</li>
</ul>
<h3 id="hrrn">HRRN</h3>
<h4 id="简述-2">简述</h4>
<p>Highest Response Ratio Next. 最高响应比优先算法。相应比R=(w+s)/s。s: 执行时间；w: 等待时间。<strong>不允许抢占</strong>。SPN的一种改进。<strong>不会导致饥饿</strong></p>
<p>响应比： 响应比=1+S/T （S：等待时间；T：运行时间） a. ex:有三个作业，在9:40开始响应三个作业，在单道运行且采用响应比优先调度算法（HRRN：Highest Response Ratio Next）的情况下，求： （1）三个作业的执行次序； （2）三个作业被选中时的响应比</p>
<p><img src="https://img-blog.csdnimg.cn/20210601155400267.jpg#pic_center" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom: 67%;"></p>
<p>解： （1）在9:40开始响应三个作业，此时，三个作业均已到达。 先把运行时间（计算时间）转换为分钟。 再考虑它们的到达时间与9:40的间隔： J1：100分钟 J2：70分钟 J3：10分钟 有： J1响应比=1+100/120=11/6 J2响应比=1+70/60=13/6 J3响应比=1+10/15=5/3 所以，三个作业的执行次序：J2、J1、J3 （2）一开始先由（1）的结果来进行判断，此时可以看出，是J2先开始，J1、J3等待。 需要注意的是，因为是单道运行，所以J2运行的时候，J1、J3是不运行的，此时，它们的等待时间会延长，延长的时间等于J2运行的时间（J2运行时间=60），所以接下来： J1响应比=1+（100+60）/120=7/3 J3响应比=1+（10+60）/15=17/3 之后的执行顺序变为了：J3、J1 同理： J1响应比=1+（100+60+15）/120=59/24 之后依次列出三个作业最终的响应比即可。</p>
<h3 id="rr">RR</h3>
<h4 id="简述-3">简述</h4>
<p>Round Robin. 时间片轮转算法，时间片+FCFS。假定：时间片=20，进程P1=53，P2=8，P3=68，P4=24。时间片选择：经验规则为，维持上下文开销为1%左右。</p>
<figure class="highlight coq"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq">+---------------------------------------------------------------+<br>|	<span class="hljs-type">P1</span>	|<span class="hljs-type">P2</span>|	<span class="hljs-type">P3</span>	|	<span class="hljs-type">P4</span>	|	<span class="hljs-type">P1</span>	|	<span class="hljs-type">P3</span>	|<span class="hljs-type">P4</span>	|<span class="hljs-type">P1</span>	|	<span class="hljs-type">P3</span>	|<span class="hljs-type">P3</span>	|<br><span class="hljs-type">+---------------------------------------------------------------+</span><br><span class="hljs-type">0</span>		<span class="hljs-number">20</span> <span class="hljs-number">28</span>   	<span class="hljs-number">48</span>		<span class="hljs-number">68</span>		<span class="hljs-number">88</span>		<span class="hljs-number">108</span> <span class="hljs-number">112</span>	<span class="hljs-number">125</span>		<span class="hljs-number">145</span> <span class="hljs-number">153</span><br></code></pre></td></tr></tbody></table></figure>
<h4 id="优点-1">优点</h4>
<ul>
<li>交互性强</li>
</ul>
<h4 id="缺点-1">缺点</h4>
<ul>
<li>额外的上下文开销</li>
<li>时间片大小不好确定，太长则退化成FCFS，太短则加大切换上下文时间开销。</li>
</ul>
<h3 id="srtn">SRT(N)</h3>
<p>Shortset Remaining Time (Next)</p>
<p><strong>抢占式</strong>的SPN。当有新进程加入时，重新执行调度。</p>
<p>具有最短的平均周转时间、平均等待时间。</p>
<h3 id="mlfq">MLFQ</h3>
<h4 id="简述-4">简述</h4>
<p>MultiLevel Feedback Queue. 多级反馈队列。多种算法的集成。</p>
<h3 id="fss">FSS</h3>
<h4 id="简述-5">简述</h4>
<p>公平共享调度算法。</p>
<h3 id="总结">总结</h3>
<p><img src="D:\ZJUT\OS\Notes\notes.assets\image-20211213111615507.png" srcset="/img/loading.gif" lazyload alt="image-20211213111615507" style="zoom: 50%;"></p>
<p><img src="D:\ZJUT\OS\Notes\notes.assets\image-20211213113003434.png" srcset="/img/loading.gif" lazyload alt="image-20211213113003434" style="zoom:50%;"></p>
<p><img src="D:\ZJUT\OS\Notes\notes.assets\image-20211213113037695.png" srcset="/img/loading.gif" lazyload alt="image-20211213113037695" style="zoom:50%;"></p>
<h3 id="实时系统">实时系统</h3>
<h4 id="简述-6">简述</h4>
<p>指定时间完成指定任务</p>
<ul>
<li>实时任务：完成任务所需的时间，定时参数</li>
<li>周期实时任务：任务有规律性地重复
<ul>
<li>周期</li>
<li>执行时间 = 最大执行时间</li>
<li>使用率</li>
</ul></li>
<li>硬时限，软时限</li>
<li>可调度性
<ul>
<li>一个实时系统，能够满足任务时限的要求</li>
<li>静态调度算法
<ul>
<li>速率单调调度算法（RM）
<ul>
<li>通过周期安排优先级</li>
<li>周期越短优先级越高</li>
<li>执行周期最短的任务</li>
</ul></li>
</ul></li>
<li>动态调度算法
<ul>
<li>最早截止时间任务（EDF）
<ul>
<li>截止时间越早的任务先执行</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="多处理机调度">多处理机调度</h3>
<h4 id="进程分配">进程分配</h4>
<h5 id="静态进程分配">静态进程分配</h5>
<p>开始到结束都被分配到一个固定的处理</p>
<p>每个处理机有自己的就绪队列</p>
<p>调度开销小</p>
<p>各处理机可能忙闲不均</p>
<h5 id="动态进程分配">动态进程分配</h5>
<p>进程在执行中可分配到任意空闲处理机执行</p>
<p>所有处理机共享一个公共的就绪队列</p>
<p>调度开销大</p>
<p>各处理机的负载是均衡的</p>
<h2 id="同步互斥">同步互斥</h2>
<h3 id="问题">问题</h3>
<ul>
<li>保证并发进程的正确性
<ul>
<li>独立进程
<ul>
<li>不和其他进程共享资源</li>
<li>确定性，输入状态决定结果</li>
<li>可重现，能够重现起始条件</li>
<li>调度顺序不重要</li>
</ul></li>
<li>并发进程
<ul>
<li>在多个进程有资源共享</li>
<li>不确定性</li>
<li>不可重现</li>
<li>程序错误可能是间歇性发生的</li>
</ul></li>
</ul></li>
<li>并发进程很好啊
<ul>
<li>资源共享</li>
<li>加速</li>
<li>模块化</li>
</ul></li>
<li>新进程分配标识中的可能错误
<ul>
<li>原子操作：不存在任何中断或失败的操作</li>
</ul></li>
</ul>
<h3 id="实现方法">实现方法</h3>
<ul>
<li><p>临界区</p>
<ul>
<li>共享的资源</li>
</ul></li>
<li><p>中断法</p>
<ul>
<li>仅限于单处理器</li>
</ul></li>
<li><p>软件法</p>
<ul>
<li><p>共享变量</p></li>
<li><p>Peterson算法（互相谦让）</p>
<ul>
<li><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span>{<br>	flag[i] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示进程是否准备好进入临界区</span><br>    turn = j;		<span class="hljs-comment">// 表示该谁进入临界区</span><br>    <span class="hljs-keyword">while</span>(flag[j] &amp;&amp; turn == j); <span class="hljs-comment">// 如果对方准备好了，那就给对方，等待，即谦让</span><br>    	Critical Section;<br>    flag[i] = <span class="hljs-literal">false</span>;<br>    	Remainder Section;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></tbody></table></figure></li>
</ul></li>
<li><p>Dekker's算法（举手回答）</p>
<ul>
<li><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">do</span>{<br>    flag[i] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(flag[j] == <span class="hljs-literal">true</span>){		<span class="hljs-comment">// 如果对方准备好了（也可能正在Critical Section）</span><br>		<span class="hljs-keyword">if</span>(turn != i){			<span class="hljs-comment">// 看turn指向谁</span><br>			flag[i] = <span class="hljs-literal">false</span>;  	<span class="hljs-comment">// 不是指向我，那就放弃，防止死锁</span><br>            <span class="hljs-keyword">while</span>(turn != i); 	<span class="hljs-comment">// busy waiting</span><br>			flag[i] = <span class="hljs-literal">true</span>;		<br>        }<br>    }<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    这种似乎也可以？非也</span><br><span class="hljs-comment">    if(flag[j] == true){		// 如果对方准备好了</span><br><span class="hljs-comment">		if(turn != i){			// 看turn指向谁</span><br><span class="hljs-comment">            while(turn != i); 	// busy waiting	</span><br><span class="hljs-comment">        }</span><br><span class="hljs-comment">    }</span><br><span class="hljs-comment">    若本来turn == j, 但是flag[j] == false;</span><br><span class="hljs-comment">    欸，那么i说既然你不来，我就去Critical Section了</span><br><span class="hljs-comment">    执行到一半flag[j] == true, 虽然j看到flag[i] == true</span><br><span class="hljs-comment">    那也无妨，因为turn == j, 所以j也就进去了。</span><br><span class="hljs-comment">    */</span><br>    Critical section;<br>    turn = j;<br>    flag[i] = <span class="hljs-literal">false</span>;<br>    Remainder Section;<br>}<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br></code></pre></td></tr></tbody></table></figure></li>
</ul></li>
<li><p>对于多个线程</p>
<ul>
<li><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">对于Dekker's算法</span><br><span class="hljs-comment">turn:</span><br><span class="hljs-comment">    0 -&gt; 1 -&gt; 2 -&gt; ... -&gt; i -&gt; i+1 -&gt; ... -&gt; j -&gt; ... -&gt; n -&gt; 0</span><br><span class="hljs-comment">	                            t</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></tbody></table></figure></li>
</ul></li>
<li><p>软件法的缺陷：忙等待，占用CPU资源，复杂。</p></li>
</ul></li>
<li><p>锁</p>
<ul>
<li><p>原子操作指令</p>
<ul>
<li>test-and-set
<ul>
<li>从内存中读取值-&gt;测试是否为1，返回true or false-&gt;设置内存为1</li>
</ul></li>
<li>compare-and-swap
<ul>
<li>交换内存的两个值</li>
</ul></li>
</ul></li>
<li><p>自旋锁（Spinlock）</p>
<ul>
<li><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//--------------忙等待版---------------</span><br>Lock{<br>    <span class="hljs-type">bool</span> value;<br>    Aquire(){<br>		<span class="hljs-keyword">while</span>(test-and-<span class="hljs-built_in">set</span>(value)); <span class="hljs-comment">// spin</span><br>        <span class="hljs-comment">// 若为0，则加锁 </span><br>        <span class="hljs-comment">// 若为1，则等待对方释放锁再加锁</span><br>    }<br>    Release(){<br>		value = <span class="hljs-number">0</span>;<br>    }<br>};<br><br><span class="hljs-comment">//--------------无忙等待版--------------</span><br>Lock{<br>	<span class="hljs-type">bool</span> value;<br>    Aquire(){<br>		<span class="hljs-keyword">while</span>(test-and-<span class="hljs-built_in">set</span>(value)){<br>			add this TCB to wait <span class="hljs-built_in">queue</span> q;<br>            schedule();<br>        }<br>    }<br>    Release(){<br>		value = <span class="hljs-number">0</span>;<br>        remove one thread t from q;<br>        wakeup(t)<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure></li>
</ul></li>
<li><p>优点：适用于多处理器、多临界区</p></li>
<li><p>缺点：可能导致饥饿，可能导致死锁</p></li>
</ul></li>
</ul>
<h3 id="信号量">信号量</h3>
<h4 id="问题-1">问题</h4>
<p>信号量（semaphore）的引入，和<strong>锁</strong>类似，也是一种在并发编程中为解决不同资源对临界区的访问的方法</p>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">并发编程					临界区<br>高层抽象				信号量		锁<br>硬件支持	禁用中断		原子操作		原子<br></code></pre></td></tr></tbody></table></figure>
<p>信号是一种抽象数据类型</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">classSemaphore{<br>    <span class="hljs-type">int</span> sem; <span class="hljs-comment">// 信号量</span><br>    WaitQueue q;<br>    P(){<br>  		sem--;<br>        <span class="hljs-keyword">if</span>(sem &lt; <span class="hljs-number">0</span>){<br>            Add this thread t to q;<br>            block(p);<br>        }<br>	}<br>    V(){<br>        sem++;<br>        <span class="hljs-keyword">if</span>(sem&lt;=<span class="hljs-number">0</span>){<br>			Remove a thread t from q;<br>            wakeup(t);<br>        }<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>
<p><strong>PV由操作系统支持，是原子操作</strong></p>
<h4 id="使用">使用</h4>
<h5 id="互斥访问">互斥访问</h5>
<p>PV操作必须成对使用，不可颠倒重复</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">mutex = new classSemaphore(<span class="hljs-number">1</span>);<br>mutex -&gt; P();			<span class="hljs-comment">// 若第1个线程来了，那就sem--，第二个线程来，sem--，由于sem&lt;0，所以等待</span><br>Critical Section;		<br>mutex -&gt; V();			<span class="hljs-comment">// 恢复</span><br></code></pre></td></tr></tbody></table></figure>
<h5 id="条件同步">条件同步</h5>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">condition = new classSemaphore(<span class="hljs-number">0</span>);<br>---------------------------------------------<br>Thread A							|Thread B<br>Module M							|<br>	condition -&gt; P()       			|<br>Module N							|<br>waiting    							|X<br>waiting								|	condition -&gt; V()<br>Module N    						|Y<br></code></pre></td></tr></tbody></table></figure>
<h4 id="生产者与消费者问题">生产者与消费者问题</h4>
<p>生产者-&gt;缓冲区-&gt;消费者</p>
<p>缓冲区只允许一个生产者或消费者进行操作。所以缓冲区是一种临界区。</p>
<ul>
<li>任何时刻只允许由一个线程进行操作（互斥访问） -----mutex</li>
<li>缓冲区为空时，消费者必须等待生产者（条件同步）-----fullBuffer</li>
<li>缓冲区为满时，生产者必须等待消费者（条件同步）-----emptyBuffer</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">Class BoundedBuffer{<br>	mutex = new Semaphore(<span class="hljs-number">1</span>);<br>    fullBuffers = new Semaphore(<span class="hljs-number">0</span>);<br>    emptyBuffers = new Semaphore(n);<br>    Deposit(c){					<span class="hljs-comment">// 生产者</span><br>        emptyBuffers -&gt; P();	<span class="hljs-comment">// 是否有空余空间</span><br>        mutex -&gt; P();<br>		Add c to the Buffer;<br>        mutex -&gt; V();<br>        fullBuffers -&gt; V();<br>    }<br>	Remove(c){<br>        fullBuffers -&gt; P();<br>        mutex -&gt; P();<br>		Remove c to the Buffer;<br>        mutex -&gt; V();<br>        emptyBuffers -&gt; V();<br>    }<br>}<br><span class="hljs-comment">// PV顺序不要随意调换，否则很容易发生死锁</span><br></code></pre></td></tr></tbody></table></figure>
<h4 id="读者写者问题">读者/写者问题</h4>
<h4 id="缺陷">缺陷</h4>
<p>编程复杂，容易构成死锁</p>
<h3 id="管程">管程</h3>
<p>管程（Monitor），一种并发程序的编程方法</p>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">并发编程					临界区		管程<br>高层抽象				信号量		锁	条件变量<br>硬件支持		禁用中断		原子操作		原子<br></code></pre></td></tr></tbody></table></figure>
<p>管程是一种用于多线程互斥访问的共享资源的程序结构。</p>
<ul>
<li>采取面向对象的方法</li>
<li>任意时刻最多只有一个线程执行管程代码</li>
<li>正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时的恢复（<strong>与临界区的重要区别</strong>）</li>
</ul>
<p>比如我在临界区执行时，需要等某个数据，那就可以暂时放弃临界区，让其他代码进行访问。</p>
<h2 id="文件系统">文件系统</h2>
<h3 id="基本概念">基本概念</h3>
<h4 id="属性">属性</h4>
<p>文件名 标识符 类型 位置 大小 文件所有者 保护信息 上次修改时间</p>
<h4 id="类型">类型</h4>
<p>无结构：流式文件</p>
<p>有结构：数据库，有数据项。。</p>
<h4 id="组织">组织</h4>
<p>根目录-&gt;子目录-&gt;文件</p>
<h4 id="系统调用-1">系统调用</h4>
<p>create open read write close delete</p>
<h4 id="外存管理">外存管理</h4>
<p>磁盘块</p>
<h4 id="共享和保护">共享和保护</h4>
<p>多个用户、权限</p>
<h3 id="逻辑结构">逻辑结构</h3>
<p>对于一个文件</p>
<h4 id="堆文件">堆文件</h4>
<p>数据按先来后到的次序组织，每个记录由一串数据组成，是串结构的顺序文件</p>
<p>目的是积累大量数据并保存，不适合大多数应用</p>
<h4 id="顺序文件">顺序文件</h4>
<p>主要对于有结构文件</p>
<p>文件的记录一个跟着一个顺序排列</p>
<p>顺序文件常用于批处理应用，适用于对所有记录的处理，对于查询或更新某个记录的请求的处理性能不佳（需要遍历）</p>
<h5 id="顺序存储">顺序存储</h5>
<p>逻辑相邻-&gt;物理相邻</p>
<p>变长记录：不可随机存取</p>
<p>定长记录：可随机存取</p>
<h4 id="索引文件">索引文件</h4>
<p>主要对于有结构文件</p>
<p>索引表本身是一个定长记录的顺序文件</p>
<p>每个记录都索引，那开销太大了，可能一个索引都比一条记录大</p>
<p>常用于实时处理环境中</p>
<h4 id="索引顺序文件">索引顺序文件</h4>
<p>主要对于有结构文件</p>
<p>对索引表进行瘦身，记录进行分组-&gt;每组建立索引-&gt;组内顺序存储</p>
<p>索引顺序文件既适用于交互方式应用，也适用于批处理方式应用。</p>
<h5 id="多级索引顺序文件">多级索引顺序文件</h5>
<h4 id="直接文件或散列文件">直接文件或散列文件</h4>
<p>检索时给出记录编号（关键域），通过哈希函数（散列函数）计算出该记录在文件中的相对位臵</p>
<p>常用于需要高速访问文件且每次访问一条记录的应用中。</p>
<h3 id="目录">目录</h3>
<p>目录文件是一个有结构文件</p>
<h4 id="文件控制块fcb">文件控制块（FCB）</h4>
<p>目录的一条一条记录</p>
<p>为了实现<strong>按名存取</strong></p>
<p>一般成分：</p>
<ul>
<li>基本属性：文件名、文件的物理位置、文件的逻辑结构、文件的物理结构</li>
<li>存取控制信息：文件存储权限等</li>
<li>使用信息：文件建立时间、修改时间等</li>
</ul>
<h4 id="单级目录">单级目录</h4>
<p>不可重名</p>
<h4 id="两级目录结构">两级目录结构</h4>
<p>主文件目录（MFD）、用户文件目录（UFD）</p>
<h4 id="多级目录结构">多级目录结构</h4>
<p>不同目录下的文件名可以重名</p>
<p><strong>当前目录</strong>：相对路径，不必从根目录开始一层一层往下找，提高效率</p>
<p>树形结构不便于文件共享</p>
<h4 id="无环图目录结构">无环图目录结构</h4>
<p>有向无环图</p>
<p>共享计数器：计数器减少至0时，才删除</p>
<p>其中一个用户进行更改，其他用户也可以看到</p>
<h4 id="索引节点fcb的改进">索引节点（FCB的改进）</h4>
<p>FCB太大了，I/O操作费时</p>
<p>文件名+索引节点指针</p>
<p>也就是说，每次找文件，不必把文件信息都调进来</p>
<p>先把文件名找到，再根据指针调入索引节点</p>
<p>就是说 文件名和文件信息分开，取而代之的是文件信息的指针</p>
<h3 id="物理结构">物理结构</h3>
<p>要考虑的是在外存的组织形式</p>
<p>文件地址空间被划分为一个一个文件的块</p>
<p>逻辑块号-&gt;物理块号</p>
<h4 id="连续分配">连续分配</h4>
<p>物理块号=起始块号+逻辑块号；验证长度</p>
<p>顺序读写时非常快（对于磁盘来说）</p>
<p>数据拓展非常不方便；磁盘碎片</p>
<h4 id="链接分配">链接分配</h4>
<h5 id="隐式链接默认">隐式链接（默认）</h5>
<p>一个一个块调入</p>
<p>先调入一个块，读取指针，再读下一个块</p>
<p>查找效率很低；方便拓展，不会有碎片问题</p>
<h5 id="显式链接">显式链接</h5>
<p>FAT（文件分配表）</p>
<p>FAT存放 物理块号+下一块块号</p>
<p>一个磁盘仅设置一个FAT</p>
<p>将FAT读入内存，并常驻内存</p>
<p>从文件表项查找起始块号-&gt;从FAT依次查找所有块号</p>
<p>方便拓展，不会有碎片问题；没有频繁的I/O操作；FAT需要空间啊</p>
<h4 id="索引分配">索引分配</h4>
<p>每个文件建立一张索引表</p>
<p>每个文件设置一个索引块号，根据索引块号读入索引表</p>
<p>索引表的块号一般占4B，定长，可随机访问</p>
<p>但是一个磁盘块可能放不下呀</p>
<h5 id="链接方案">链接方案</h5>
<p>多个索引块链接</p>
<p>同样低效</p>
<h5 id="索引方案套娃">索引方案（套娃）</h5>
<p>一级索引-&gt;二级索引</p>
<p>都要k+1次访问</p>
<h5 id="混合索引">混合索引</h5>
<p>直接地址</p>
<p>一级地址</p>
<p>二级地址</p>
<h4 id="存储空间管理">存储空间管理</h4>
<h5 id="划分与初始化">划分与初始化</h5>
<p>文件卷(分区)-&gt;[目录区 文件区]</p>
<h5 id="空闲表法">空闲表法</h5>
<p>适用于连续分配的方式</p>
<p>首次适应、最佳适应、最坏适应之类的</p>
<p>合并问题</p>
<h5 id="空心链表法">空心链表法</h5>
<p>空闲盘块链</p>
<p>空闲盘区链</p>
<p>链头、链尾指针</p>
<h5 id="位示图法">位示图法</h5>
<p>(字号, 位号)</p>
<p>顺序扫描，找到连续的0（非连续分配则不需要）</p>
<h5 id="成组链接">成组链接</h5>
<p>超级块：空闲块好，下一组空闲盘块号（指针），和各个空闲盘块块号</p>
<p>先检查第一组，如果改组满了，记得把下一组的链接信息复制回去</p>
<h4 id="文件操作">文件操作</h4>
<ul>
<li><p>create</p>
<p>所需空间大小，存放路径，文件名</p>
<p>为文件分配存储空间</p>
<p>在目录表中插入目录项</p></li>
<li><p>delete</p>
<p>文件存放路径，文件名</p>
<p>找到文件名对用的目录项</p>
<p>回收文件占用的磁盘块</p>
<p>删除目录项</p></li>
<li><p>open</p>
<p>存放路径，文件名，文件操作类型（读/写）</p>
<p>找到文件名对应的目录项，检查操作权限</p>
<p>对应的目录项，复制到内存的打开文件表中</p>
<p>系统的打开文件表（全局，仅一张）,文件偏移量，访问权限，索引节点指针</p>
<p>进程的打开文件表，指向系统的打开文件表</p>
<p>打开计数器+1</p></li>
<li><p>close</p>
<p>。。。</p></li>
<li><p>read</p></li>
<li><p>write</p></li>
</ul>
<h4 id="文件共享">文件共享</h4>
<ul>
<li>硬链接
<ul>
<li></li>
</ul></li>
<li>软链接（类似于win的快捷方式）
<ul>
<li>根据路径信息去找到</li>
<li>删除一个文件，其对应的软链接去查找会失败</li>
<li>更慢</li>
</ul></li>
</ul>
<h4 id="文件保护">文件保护</h4>
<ul>
<li>口令保护
<ul>
<li>请求时须提供口令</li>
<li>口令一般存于FCB或者索引节点中</li>
<li>不安全，存在于系统内部</li>
</ul></li>
<li>加密保护
<ul>
<li>保密性强，不需要在系统中存储密码</li>
<li>编码/译码费时</li>
</ul></li>
<li>访问控制
<ul>
<li>rwx</li>
<li>u g o su</li>
</ul></li>
</ul>
<h4 id="层次结构">层次结构</h4>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">	用户接口-系统调用</span><br><span class="hljs-code">	文件目录系统-文件目录</span><br><span class="hljs-code">	存取控制模块-文件保护</span><br><span class="hljs-code">	逻辑文件系统与文件信息缓存区-逻辑结构</span><br><span class="hljs-code">	物理文件系统-物理结构</span><br><span class="hljs-code">辅助分配模块-存储管理		设备管理模块-磁盘管理		</span><br><span class="hljs-code"></span><br></code></pre></td></tr></tbody></table></figure>
<ol type="1">
<li>通过系统调用发送请求</li>
<li>在系统中一层层查找，找到对应的目录项</li>
<li>根据目录项（FCB）验证权限</li>
<li>将记录号转变为对应的逻辑地址</li>
<li>将逻辑地址转化为物理地址</li>
<li>对磁盘设备发送请求，存储空间管理</li>
</ol>
<h2 id="io设备管理">I/O设备管理</h2>
<h3 id="缓冲区">缓冲区</h3>
<h4 id="单缓冲">单缓冲</h4>
<p>初始状态：工作区满，缓冲区空</p>
<p>缓冲区-&gt;工作区：M</p>
<p>工作区-&gt;CPU: C</p>
<p>设备-&gt;缓冲区: T</p>
<p>max(T, C)+M</p>
<h4 id="双缓冲">双缓冲</h4>
<p>初始状态：一个缓冲区满，一个为空</p>
<p>max(M+C, T)</p>
<h2 id="question">QUESTION</h2>
<ol type="1">
<li>GDT</li>
<li></li>
</ol>
<h3 id="section-1"></h3>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="category-chain-item">操作系统</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">#操作系统</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>操作系统知识整理</div>
      <div>http://vitaminzl.com/2022/02/09/os/cao-zuo-xi-tong-zhi-shi-dian-zheng-li/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>vitaminzl</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年2月9日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/02/10/os/cao-zuo-xi-tong-shi-yan-pintos/" title="操作系统实验-Pintos">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统实验-Pintos</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"N5b4uVEvRE5UcVcWvkv2ln10-gzGzoHsz","appKey":"KJFp10KGLr5F9HxFUUsL2AeD","path":"window.location.pathname","placeholder":"你的意见至关重要！","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
