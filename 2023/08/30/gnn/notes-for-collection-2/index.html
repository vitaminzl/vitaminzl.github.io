

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/image/cat.png">
  <link rel="icon" href="/image/cat.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="vitaminzl">
  <meta name="keywords" content="">
  
    <meta name="description" content="DropEdge Towards Deep Graph Convolutional Networks On Node Classification Drop Edge Drop Edge[1]，其方法顾名思义，就是丢弃图中的边。 具体来说，对于一个邻接矩阵 \(A\) ,对于其中的每一个元素以 \(p\) 的概率置0。 这看起来和 dropout 如出一辙，事实上在实现的时候，也是采用 dropo">
<meta property="og:type" content="article">
<meta property="og:title" content="GNN论文精选-第二组">
<meta property="og:url" content="http://vitaminzl.com/2023/08/30/gnn/notes-for-collection-2/index.html">
<meta property="og:site_name" content="闲渔">
<meta property="og:description" content="DropEdge Towards Deep Graph Convolutional Networks On Node Classification Drop Edge Drop Edge[1]，其方法顾名思义，就是丢弃图中的边。 具体来说，对于一个邻接矩阵 \(A\) ,对于其中的每一个元素以 \(p\) 的概率置0。 这看起来和 dropout 如出一辙，事实上在实现的时候，也是采用 dropo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230806161528.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230806164029.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230806164516.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230806164542.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230806181232.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230810160006.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230810150249.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230810162254.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230810145230.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230812165605.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230812170559.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230813211822.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230816154534.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230816165539.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230817105644.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230819213010.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230819213112.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230818220732.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230818202859.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230822115150.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230822115204.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230822144103.png">
<meta property="og:image" content="https://imagehost.vitaminz-image.top/20230822144111.png">
<meta property="article:published_time" content="2023-08-30T04:00:00.000Z">
<meta property="article:modified_time" content="2023-08-30T04:05:56.000Z">
<meta property="article:author" content="vitaminzl">
<meta property="article:tag" content="图">
<meta property="article:tag" content="GNN">
<meta property="article:tag" content="综述">
<meta property="article:tag" content="论文解读">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://imagehost.vitaminz-image.top/20230806161528.png">
  
  
  
  <title>GNN论文精选-第二组 - 闲渔</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"vitaminzl.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="闲渔" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>闲渔</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/image/snow-small.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="GNN论文精选-第二组"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-30 12:00" pubdate>
          2023年8月30日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          70 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">GNN论文精选-第二组</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="dropedge-towards-deep-graph-convolutional-networks-on-node-classification"><strong>DropEdge</strong> Towards Deep Graph Convolutional Networks On Node Classification</h1>
<h2 id="drop-edge">Drop Edge</h2>
<p>Drop Edge<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Y. Rong, W. Huang, T. Xu, and J. Huang, “DropEdge: Towards Deep Graph Convolutional Networks on Node Classification.” arXiv, Mar. 12, 2020. doi: [10.48550/arXiv.1907.10903](https://doi.org/10.48550/arXiv.1907.10903).">[1]</span></a></sup>，其方法顾名思义，就是丢弃图中的边。</p>
<p>具体来说，对于一个邻接矩阵 <span class="math inline">\(A\)</span> ,对于其中的每一个元素以 <span class="math inline">\(p\)</span> 的概率置0。 这看起来和 dropout 如出一辙，事实上在实现的时候，也是采用 dropout 算子来对邻接矩阵进行处理的（dropout 算子在每一轮梯度下降时，使每一个神经元以 <span class="math inline">\(p\)</span> 的概率随机置0，使得被置0的神经元无法进行梯度更新）。</p>
<p>这可以说就是该方法的全部了。没错，就是这么简单。那么作者又是怎么把这么一个两句话就能讲完的方法写成一篇论文的呢？故事由此开始。</p>
<h2 id="overfitting-and-oversmoothing">Overfitting and Oversmoothing</h2>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230806161528.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>Overfitting 是机器学习的常用概念了，具体来说就是训练集上的效果不错，但在测试集上的效果却很差。Oversmoothing 则是由Li等人<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Q. Li, Z. Han, and X.-M. Wu, “Deeper insights into graph convolutional networks for semi-supervised learning,” in _Proceedings of the AAAI conference on artificial intelligence_, 2018.">[2]</span></a></sup>提出来的概念，而后被[[Notes for Collection 1#<strong>JKN</strong> Representation Learning on Graphs with Jumping Knowledge Networks|JKN]]、[[Notes for Collection 1#<strong>PPNP</strong> Predict then Propagate Graph Neural Networks meet Personalized PageRank|PPNP]]等模型的论文里具体说明并尝试解决的问题。具体来说，它是指GNN在层数增多后，由于特征传播与聚合的操作，所有特征表示都趋向一个稳定值，其原理类似于随机游走。这使得后期的训练变得困难，具体表现为梯度下降优化时发生梯度消失，从而使得训练损失难以下降。</p>
<p>而 Drop Edge 的引入可以改善这2个问题。</p>
<h3 id="overfitting">Overfitting</h3>
<p>关于过拟合，作者定性地说明了该方法是通过对数据的随机扰动而对数据进行增强改善，其类似于图像分类中对图像进行拉伸、旋转等变换。另外，这种数据扰动从期望上看与原数据相比是无偏的。如果我们以概率 <span class="math inline">\(p\)</span> 删除边，则 DropEdge 只会将邻居聚合的期望上乘上 <span class="math inline">\((1-p)\)</span>（因为采样符合伯努利分布），而这个乘数将在对其归一化后实际上消失了，因此，DropEdge不会改变邻居聚合的期望。综上，DropEdge可以看作是一个无偏数据增强技术。</p>
<h3 id="oversmoothing">Oversmoothing</h3>
<p>对于过度平滑，作者花了较大笔墨去证明。其过程有些复杂，暂时看不太懂[[[WHY]]]。</p>
<p>但仍然可以从实验的角度来验证这一点。实验中，作者使用该层结点表示与上一层结点表示的欧几里得距离来衡量。由下图可以知道，在训练之前（模型采用初始化权重），可以发现经过DropEdge后，相邻两层结点表示的差距始终大于未使用DropEdge的模型。图b为经过150个epoch训练后的结果，发现在5和6层，其差异为0。从训练损失来看，没有通过DropEdge根本训练不动，原因很简单，第5和第6层差异为0，从而发生了严重的梯度消失现象，无法使用梯度下降优化。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230806164029.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="hyperparameter">Hyperparameter</h2>
<p>该论文的超参数也是值得一提的。作者使用的超参数由下表列出。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230806164516.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>其中withloop为方法self feature modeling，来源于Fout等人的工作<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="A. Fout, J. Byrd, B. Shariat, and A. Ben-Hur, “Protein Interface Prediction using Graph Convolutional Networks,” in _Advances in Neural Information Processing Systems_, Curran Associates, Inc., 2017. Accessed: Aug. 06, 2023. [Online]. Available:[https://proceedings.neurips.cc/paper_files/paper/2017/hash/f507783927f2ec2737ba40afbd17efb5-Abstract.html](https://proceedings.neurips.cc/paper_files/paper/2017/hash/f507783927f2ec2737ba40afbd17efb5-Abstract.html)">[3]</span></a></sup>，其公式如下。 <span class="math display">\[ H^{(l+1)} = \sigma (\tilde AH^{(l)}W^{(l)} + H^{(l)}W^{(l)}_{self})\]</span> 表中的normalization为传播模型，它使用了如下4种模式，都是比较流行的传播模式。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230806164542.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="dropout-and-layer-wise-dropedge">Dropout and Layer-wise DropEdge</h2>
<p>Dropout 可以看作是 DropEdge 的一种特殊情形，因为当结点特征被丢弃，那么所连接的边也就没了。作者通过实验说明了 Dropout 和 DropEdge 有互补的作用，联合使用可以使得效果更好。</p>
<p>此外，作者还提出了 Layer-wise DropEdge。上述所使用的 DropEdge 都是针对一整个模型的，也就是说，每一次梯度下降使用一次 DropEdge 得到的 <span class="math inline">\(A_{drop}\)</span> 是针对模型的所有层。而Layer-wise 指的是每一层都独立使用一次 DropEdge，也就是说每一层的 <span class="math inline">\(A_{drop}\)</span> 是不一样的。作者通过实验说明，Layer-wise DropEdge缺失可以降低训练损失，但在验证集上的损失并没有下降。因此，作者更建议使用对面向模型的 DropEdge，而非 Layer-wise，这样可以防止过拟合，并减少不必要的计算。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230806181232.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="conclusion">Conclusion</h2>
<p>该论文借鉴了 dropout，仅仅对模型进行了一个很简单的改动，却在各个数据集上取得了非常不错的效果。也从理论上证明作者的方法可以一定程度上缓解Over Smoothing的问题。文章也教会我们如何将一个简短的方法写长，即使用大量的分析、比较，再辅之以理论证明，就可以讲好一个简单又精彩的故事。</p>
<h1 id="adagcn-adaboosting-graph-convolutional-networks-into-deep-models"><strong>AdaGCN</strong> Adaboosting Graph Convolutional Networks into Deep Models</h1>
<h2 id="adaboost">Adaboost</h2>
<p>论文首先是借鉴了 Adaboost 方法。</p>
<p>[[Ensemble Learning#Random Forest|Adaboost]] 是一种集成学习的方法。该方法可以使一组弱分类器组成一个强的集成分类。但由于其用于二分类，作者使用它的多分类形式，SAMME<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="T. Hastie, S. Rosset, J. Zhu, and H. Zou, “Multi-class AdaBoost,” _Stat. Interface_, vol. 2, no. 3, pp. 349–360, 2009, doi: [10.4310/SII.2009.v2.n3.a8](https://doi.org/10.4310/SII.2009.v2.n3.a8).">[4]</span></a></sup>。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230810160006.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>其区别就在于 <span class="math inline">\(\alpha\)</span> 的式子增加了 <span class="math inline">\(log(K-1)\)</span> 这一项。直观地去理解，会发现，当每一个类别的误差率大于 <span class="math inline">\(\frac{1}{K}\)</span> 时，<span class="math inline">\(\alpha\)</span> 就会大于0，这符合原来二分类的性质。</p>
<p>为了方便计算以及增强模型的收敛性质，作者使用它的一个改良版本 SAMME.R (R for real)。以下为它的算法描述。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230810150249.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>它的主要区别在于将误差率的公式，由原来的指示函数，更改为一个加权概率函数。随后的权重计算公式以及加权分类结果是通过解决以下优化方程得到的。 <span class="math display">\[
\begin{align}
&amp;\min _{h(x)} \operatorname{E} \bigg( \exp \bigg( -\frac{1}{K} Y^T\big(f^{(m−1)}(x)+h(x)) \bigg) |x \bigg) \\
&amp;subject~to~h_1(x)+···+ h_K(x)=0
\end{align}
\]</span> 该方程旨在最小化集成分类器的指数损失。<strong>其中还需注意的一个是</strong>，其中的数据标签的向量<span class="math inline">\(y =(y_1,...,y_K )^T\)</span>，它并不是一个 0/1 向量，它的定义为 <span class="math display">\[
yk = 
\left\{ 
\begin{align}
&amp;1, &amp;&amp;if~c = k, \\
&amp;−\frac{1}{K−1} , &amp;&amp;if~c \ne k.\\
\end{align}
\right.
\]</span></p>
<h2 id="rnn-like">RNN-like</h2>
<p>该论文提出的模型架构可以概括为： <span class="math display">\[
\begin{align}
&amp;\hat{A}^lX = \hat A·(\hat A^{l−1} X ) \\
&amp;Z^{(l)} = f _{\theta}^{(l)} (\hat A^l X ) \\
&amp;Z = \operatorname{AdaBoost}(Z^{(l)}) %不能有多余的空行，不然在网页中也可能除左
\end{align}
\]</span> 其中 <span class="math inline">\(f_{\theta}^{(l)}\)</span> 为非线性函数，比如说2层的神经网络<span class="math inline">\(f^{(l)}_{\theta}(\hat A^l X) = \operatorname{ReLU}(\hat A^l XW ^{(0)})W^{(1)}\)</span>。但是，这里需要注意的是，该模型和Adaboost有一个重要区别，那就是对于所有的 <span class="math inline">\(l\)</span> 来说，<span class="math inline">\(f_{\theta}^{(l)}\)</span> 使用 <span class="math inline">\(\theta\)</span> 参数是基于上一层分类器 <span class="math inline">\(f_{\theta}^{(l-1)}\)</span>。而一般的Adaboost各个基分类器的参数都是独立的。</p>
<p>模型架构可以由如下图表示。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230810162254.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>可以看到，这样的结构和RNN非常相像，每一层都由来自于上一层的输入，使用的 <span class="math inline">\(\theta\)</span> 参数是共用的。也就是说，AdaGCN中每一层基分类器 <span class="math inline">\(f_{\theta}^{(l)}\)</span> 都是在上一层分类器 <span class="math inline">\(f_{\theta}^{(l-1)}\)</span> 的参数上进行更行的，这一点是和Adaboost的一个重要区别。</p>
<h2 id="algorithm">Algorithm</h2>
<p>以下为算法的伪代码。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230810145230.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>该流程基本在参数更新中，基本仿照了SAMME.R的算法流程。值得注意的是，该算法和我们之前所看到的那些模型有个重要的不同，那就是最后的输出不是一个模型，而是一个最终的预测结果，这一点是有些奇怪的。</p>
<p>因为常理来说，在训练过程之后，我们将得到一个模型，最终再使用这个模型运用到验证集、测试集上。也就是说训练和预测应当是分开的，但这个算法流程貌似是合起来的。但如果我们回想一下GCN的训练过程也许就能明白，GCN的训练是一种transductive learning，也就是说其预测的东西都是模型所见过的。所以GCN训练时，将整个数据集都输入了进去，但只使用少量标签进行训练。事实上，每次训练都可以得到整个数据集的标签，但计算损失时仅使用训练数据的标签。</p>
<p>那么算法也同理，训练时输入整个数据集（包括训练集、验证集、测试集），但计算损失、拟合参数时只是用训练集部分的标签。因此它的输出也自然可以是整个数据集的标签。但如果偏要将训练和预测完分离开来，则需要记录训练时每一层分类器的参数<span class="math inline">\(\theta\)</span>，还要在预测时将第3、6、7步去掉。</p>
<h2 id="computational-comlexity-and-netowrk-depth">Computational Comlexity and Netowrk Depth</h2>
<p>AdaGCN的计算复杂度，主要的有点就是可以提前计算传播矩阵，也就是对于第 <span class="math inline">\(l\)</span> 层来说，<span class="math inline">\(B^{l}=\hat A^{l}X\)</span> 可以被提前计算，这使得不需要在训练的每个epoch都再算一遍，这和SGC类似。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230812165605.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>经过作者的实验，也确实展现出它的高效。但是上面右边这张图就有些奇怪了，随着网络层次的加深，SGC每个epoch训练时间的增长远超AdaGCN，这不禁令人怀疑。因为对于SGC来说，同样是提前计算了传播矩阵和特征矩阵的乘积，并且其算法要比AdaGCN简单得多，怎么可能会比它慢呢？个人感觉，作者对SGC并没有采取提前计算的方法。</p>
<p>此外作者同样指出，AdaGCN虽然每个epoch训练时间比较短，但它所需要的epoch却更多一些。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230812170559.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>此外，作者还比较了各个模型加大深度后性能的变化。这里需要注意的是，模型的深度指的是特征传播的深度。事实上，AdaGCN有2个深度，一个是基分类器的数量，也就是作者所谓的深度，还有一个是 <span class="math inline">\(f_{\theta}\)</span> 这一非线性函数，事实上它可以是个深度神经网络，同样也可以有深度。作者的模型，也确实将网络深度与传播深度分离开来了，这一点和[[Notes for Collection 1#<strong>PPNP</strong> Predict then Propagate Graph Neural Networks meet Personalized PageRank|PPNP]]比较类似。</p>
<p>在结果上，随着深度加深，其性能确实不会有什么衰减，一定程度上减轻了Oversmoothing的问题，甚至可能略有提升。</p>
<p>不同于其他论文，改论文还讨论了模型的深度该如何确定，也就是基分类器的个数如何选择。其引用了[[#附录#Vapnik–Chervonenkis dimension|VC-dimesion]]的理论，大该是想说明，随着基分类器个数的增加，模型的VC维上界也会增大，从而提高模型过拟合的风险。但是总之，作者也就是说在实践中用交叉验证的方法来确定模型深度（讲了和没讲一样）。</p>
<h2 id="connection-with-ppnp-and-appnp.">Connection with PPNP and APPNP.</h2>
<p>作者认为，AdaGCN是自适应版本的APPNP。这里我没怎么看懂。我的理解时在传播过程中，APPNP里MLP参数是固定的，而AdaGCN则不是，每一层传播的参数不一样，即基分类器参数不同。因此他更具备适应性。另外有一点和APPNP是一样的，就是MLP的深度和传播深度是独立的。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230813211822.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>作者通过实验比较，发现在低标签率的情况下，其效果也超过APPNP（这曾是APPNP的优点之一）。</p>
<h2 id="conclusion-1">Conclusion</h2>
<p>AdaGCN借鉴集成学习中Adaboost的方法，设计了一个RNN-like的算法。其效率和性能都比较强。</p>
<h1 id="gcnii-simple-and-deep-graph-convolutional-networks"><strong>GCNII</strong> Simple and Deep Graph Convolutional Networks</h1>
<h2 id="residual-connection-and-identity-map">Residual Connection and Identity Map</h2>
<p>GCNII 的模型可以由如下公式表示： <span class="math display">\[
H^{(l+1)} =\sigma\bigg(\bigg( (1−\alpha_l) \tilde PH^{(l)} +\alpha_l H^{(0)}\bigg)\bigg( (1−\beta_l)I_n +\beta_l W^{(l)}\bigg)\bigg)
\]</span> 它由2部分组成： * 初始层残差连接：<span class="math inline">\((1−\alpha_l) \tilde PH^{(l)} +\alpha_l H^{(0)}\)</span>，注意这里的 <span class="math inline">\(H^{(0)}\)</span> 不必是 <span class="math inline">\(X\)</span>，它可以是 <span class="math inline">\(X\)</span> 经过线性变换的结果，如 <span class="math inline">\(XW\)</span>。 * 自身映射：<span class="math inline">\((1−\beta_l)I_n +\beta_l W^{(l)}\)</span></p>
<p>著名的 ResNet 就是利用残差连接来避免梯度消失问题，从而使得神经网络可以做得很深。但 ResNet 的残差连接，是和前几层做加法运算，这事实上在 GCN 中就已经尝试过使用这种方法了，确实在一定程度上可以缓解 Oversmoothing 的问题，但效果随着深度地加深，并没有变好。</p>
<p>于是在本文使用的残差是与初始层做的残差。事实上这一迭代形式和 [[Notes for Collection 1#PPNP and APPNP|APPNP]] 非常相似。这里提供了一个新的视角来理解APPNP，即和初始层做残差连接的神经网络。但和 APPNP 的区别也十分明显，APPNP 在传播过程并没有参数学习的过程，但 GCNII 每一次传播乘上参数矩阵，并使用非线性函数压缩。也就是说，在 GCNII 中，它并没有讲特征传播的深度和神经网络的深度独立开来，二者是统一的。</p>
<p>这里 GCNII 每一层使用的参数矩阵包含了一个自身的映射。从优化的角度来看，它有2个作用<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="M. Hardt and T. Ma, “Identity Matters in Deep Learning.” arXiv, Jul. 20, 2018. doi: [10.48550/arXiv.1611.04231](https://doi.org/10.48550/arXiv.1611.04231).">[5]</span></a></sup>：1. 使得参数矩阵 <span class="math inline">\(W\)</span> 的范数很小，这样可以使用较大的正则化系数防止过拟合；2. 优化方程的驻点就是全局最小值。</p>
<p>另外作者还给出了 <span class="math inline">\(\beta_l\)</span> 的选取，它的选择对于不同深度来说应当使不以言的，随着深度的加深，为了防止过拟合以及梯度消失，<span class="math inline">\(\beta_l\)</span> 应当变小，让单位矩阵占据更大比重。作者给出了调整公式： <span class="math display">\[
\beta_l=log(\frac{\lambda}{l}+1)\approx\frac{\lambda}{l}
\]</span> 其中 <span class="math inline">\(\lambda\)</span> 时超参数。但他貌似没有说原因，我也不知道这公式是哪来的[[[WHY]]]。</p>
<p>另外作者还介绍了自身映射和压缩感知（Compressive Sensing）领域中的算法 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/555651497">ISTA</a> （或者<a target="_blank" rel="noopener" href="https://www.cnblogs.com/louisanu/p/12045861.html">iSTA</a>）进行了比较。ISTA 是线性问题的逆问题，通过求解以下 Lasso 正则化形式的优化方程 <span class="math display">\[
\min_{x\in \mathcal{R}^n} \frac{1} {2} ‖Bx − y‖_2^2 + \lambda‖x‖_1.
\]</span> 与我们常见的线性回归问题不同，这里 <span class="math inline">\(B,y\)</span> 是已知量，而 <span class="math inline">\(x\)</span> 则是待求量。它可以看作是一个信号重建的问题，经过亚采样的信号进行重建。和梯度下降类似，最终可以通过如下的迭代求解 <span class="math inline">\(x\)</span>。 <span class="math display">\[
x_{t+1} = P_{\mu_tλ} (x_t − \mu_tB^T Bx_t + \mu_tB^T y) ,
\]</span> <span class="math inline">\(P_β(·)\)</span> 是一个带阈值的线性函数，他的曲线如下图所示。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230816154534.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>如果令 <span class="math inline">\(W=-B^TB\)</span>，那么就有 <span class="math display">\[
x_{t+1} = P_{\mu_tλ} \bigg((I_n + \mu W)x_t + \mu_tB^T y\bigg) ,
\]</span> 于是作者认为， <span class="math inline">\((I_n + \mu W)\)</span> 就是自身映射，而 <span class="math inline">\(\mu_tB^T y\)</span> 则可以看作是初始层残差连接。另外 <span class="math inline">\(P_β(·)\)</span> 的作用可以类比为 GCNII 的非线性函数，如 <span class="math inline">\(ReLU\)</span>。作者的想法也很可能是从该算法上得到的启发。</p>
<p>另外，作者还提出了 GCNII 的一个变式 GCNII*，公式如下。主要区别在于，他对初始化层也乘上了一个带自身映射的参数矩阵。 <span class="math display">\[
H^{(l+1)} =\sigma\bigg((1−\alpha_l) \tilde PH^{(l)} \bigg( (1−\beta_l)I_n +\beta_l W^{(l)}_1 \bigg)+\alpha_l H^{(0)}\bigg( (1−\beta_l)I_n +\beta_l W^{(l)}_2 \bigg)\bigg)
\]</span></p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230816165539.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>根据最后的结果，可以看到 GCN 和 GCNII 即便在高达64层的深度，性能也并未有明显减弱，甚至会达到较高的水准。但值得一提的是，表格中没有展现 APPNP 的性能，事实上 APPNP 的性能也是有如此特点的。</p>
<h2 id="spectral-aanlaysis">Spectral Aanlaysis</h2>
<p>作者首先分析了<strong>带残差连接</strong>的 GCN，其最后也是会收敛到一个值，<span class="math inline">\(π = \frac{\langle \tilde{D}^{1/2} 1,x\rangle} {2m+n}\)</span>。</p>
<p>作者对每一层的结点做了分析，最后得到对于第 <span class="math inline">\(K\)</span> 层的 <span class="math inline">\(j\)</span> 结点有： <span class="math display">\[
h^{(K)}(j)=\sqrt{d_j+1}\bigg(\sum_{i=1}^{n}\frac{\sqrt{d_i+1}}{2m+n}x_i\pm\frac{\sum_{i=1}^nx_i\big(1-\frac{\lambda_\tilde{G}^2}{2}\big)^K}{\sqrt{d_j+1}}\bigg)
\]</span> 其中，<span class="math inline">\(\lambda_\tilde{G}\)</span> 带自环的规范化拉普拉斯矩阵的 <span class="math inline">\(\tilde L = I_n − \tilde{D}^{−1/2} \tilde{A} \tilde{D}^{−1/2}\)</span> 的最小非0特征值，<span class="math inline">\(m,n\)</span> 分别为结点和边的数量。可以看到，对于结点 <span class="math inline">\(j\)</span> 来说，如果有更大的度数 <span class="math inline">\(d_j\)</span>，那么就有更大的 <span class="math inline">\(\sqrt{d_j + 1}\)</span>，其收敛到终态的速度也就越快（注意 <span class="math inline">\(\pm\)</span> 后一项会趋向于0）。</p>
<p>作者也从 Spectral 的角度分析了 GCNII，作者认为，一个 K 层的 GCNII，他可以模拟以下多项式： <span class="math display">\[
\sum^{K}_{l=0}\theta_l\tilde{L}^{l}
\]</span> 且参数 <span class="math inline">\(\theta\)</span> 是 arbitrary 的。这个形式在 [[Notes for Collection 1#ChebNet|GCN]] 中就有提及，但需注意的是，作者认为 GCN 中的 <span class="math inline">\(\theta\)</span> 是 fixed 的[[[WHY]]]。我对这里的 fixed 和 arbitrary 不是很理解。个人感觉，大概是说对于 GCN 来说，对于某个任务他最后学得的最优参数只有一种可能，但是对于 GCNII 来说，可以用过调节 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\beta\)</span> 来获得任意可能的解。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230817105644.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>作者也做了实验的验证。首先结点度数对 GNN 的影响。作者根据结点的根据度数的范围 <span class="math inline">\([2^i, 2^{i+1})\)</span> ， <span class="math inline">\(i = 0, . . . , \infty\)</span>，分成了一个个组。并分别计算各个组的准确率。得到上图中的 figure 1。可以看到，对于度数会越高的组别，其准确率下降的越厉害。尤其在 Cora 和 Citeseer 度数 100 之后，甚至连 GCN-2(residual) 准确率降至0。</p>
<p>此外作者还做了消融实验，验证了添加的2个模块的有效性。但从图中也可以看出，虽然 GCN 做不深，但浅层的 GCN 效果也不错，而做深的 GCNII 其实并没有好太多，不得不怀疑做深是否有必要。</p>
<h2 id="limitation">Limitation</h2>
<p>文章聚焦于把网络做深，但是做深的效果并没有好太多。这种深度加大的行为，性价比可能并不高。</p>
<h2 id="conclusion-2">Conclusion</h2>
<p>作者通过加入初始化残差和自身映射，引入2个超参数调节模型，确实能把网络做的很深，不至于梯度消失、过拟合或者说Oversmoothing，其效果也略有上升，但是其性能的调高很有限。不过在大模型时代，不顾一切地把网络做深也许确实能够带来性能的极大提升，这或许也是为什么这么多论文想把 GNN 做深的原因了。</p>
<h1 id="deepergcn-all-you-need-to-train-deeper-gcns"><strong>DeeperGCN</strong> All You Need to Train Deeper GCNs</h1>
<h2 id="massage-passing">Massage Passing</h2>
<p>论文将 GNN 抽象成了3个阶段：1. Message Construction，2. Message Aggregation，3. Vertex Update。</p>
<p>这在 PyG 中，有着同样的分类。具体参考 <em><a target="_blank" rel="noopener" href="https://pytorch-geometric.readthedocs.io/en/latest/tutorial/create_gnn.html">Creating Message Passing Networks</a></em>。公式可描述如下： <span class="math display">\[
\mathbf{x}_i^{(k)} = \gamma^{(k)} \left( \mathbf{x}_i^{(k-1)}, \bigoplus_{j \in \mathcal{N}(i)} \, \phi^{(k)}\left(\mathbf{x}_i^{(k-1)}, \mathbf{x}_j^{(k-1)},\mathbf{e}_{j,i}\right) \right),
\]</span> 其中 <span class="math inline">\(\phi,\bigoplus, \gamma\)</span> 分别表示1、2、3这3个阶段。其中，<span class="math inline">\(\bigoplus\)</span> 是一个 Permutation Invariant 的函数，而 <span class="math inline">\(\phi_k,\gamma\)</span> 往往是一个可微函数，比如MLP。</p>
<p>后2个阶段是常用的，但是第1个阶段，可能并未明确点出。其实，在 GCN 中，我可以将对结点特征做 Normalize 作为 Message Construction。即所有的 Message 是带权重的特征，且权重为 <span class="math inline">\(1/\sqrt{d_id_j}\)</span>。因此 <span class="math inline">\(\phi\)</span> 函数的输入需要输入结点可能需要源节点和邻居结点以及他们的边信息。</p>
<p>另外，在之前大部分论文中，遇到的数据集边是没有特征的，如果边存在特征，那 Message 该如何构建呢？这里提供一种论文使用的办法。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230819213010.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>首先，我们在对离散数据编码时，往往常用 one-hot 编码，比如在 NLP 中，在语料库中存在 N 个 Token，那就编码为 N 维的 one-hot 向量。但是 one-hot 向量有时候因为过度稀疏、维度过大，并且无法表示各个向量之间的关系，比如相近语义的词语在向量表示时应当给予更接近的距离，而非 one-hot 中，所有向量都是单位正交的。所以，有一种常用的方法，就是利用线性变换，即乘上一个参数矩阵，来对每一词语重新编码，这个过程叫做 embedding。经过这样的 embedding，每一个词语会获得新的表示想浪。如上图所示，将每一个特征值都从原来的3维向量编码成了2维向量。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230819213112.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>而在很多图任务中，结点特征以及边特征的每一维取值也是离散的，也就是说特征的每一维都可以进行 ont-hot 编码，比如结点的第一维特征可能取值是0和1，那么它可以编码为 <span class="math inline">\(2 \times 2\)</span> 的 one-hot 矩阵，同时也可以将其做一个 embedding 的操作。那么我们对特征的每一维都可以做相同的操作，将每一维的特征的每一个取值都编码成相同维度的向量。如上图所示，假设输入特征，第一维有2种取值，第2维有3种取值，第3维有2种取值。对每一维的特征都做一个 embedding，使得每一维的特征的每一个特征取值都对应到一个维度为2的 embedding 向量。那么最后输入的特征，根据每一维的特征取值，将对应的 embedding 向量取出相加，就是最后的特征向量了。</p>
<p>这样的操作，同时作用在结点特征和边特征上，使他们最后的 embedding 向量维度保持一致，这样就能更容易进行特征融合，比如把边的特征加到结点特征上，得到最终的 message。</p>
<p>需要注意的是，在做 embedding 的时候，也就是做了一个线性变换，但变换的参数矩阵中的参数是不知道的，有的可能会使用通过一些手段预训练的参数。但总之，一般会跟随整个模型一起训练。</p>
<h2 id="generalized-aggregator">Generalized Aggregator</h2>
<p>该文的一个核心内容就是作者提出了一个通用的信息聚合器。我们知道，常用的聚合器有mean, max, sum等。作者提出了2个可以根据参数连续变化的聚合器，并且它的变化范围是mean ~ max之间。但其中并不包含 sum，作者说 sum 容易被包括，但事实上他在附录中将其作为 Future Work。</p>
<p>首先是 Softmax 聚合器的公式如下： <span class="math display">\[
\operatorname{SoftMax\_Agg}_{\beta}(\cdot)=\sum_{u\in \mathcal{N}(v)}\frac{\exp(\beta \mathbf{m}_{vu})}{\sum_{i\in \mathcal{N}(v)}\exp(\beta\mathbf{m}_{vi})}\cdot \mathbf{m}_{vu}
\]</span> 其中，<span class="math inline">\(m_{vu}\)</span> 为 message。不过这里需要注意的是，以上是论文的形式，但在代码中发现一些区别，具体参考 <em>[[Code for Collection 2#SoftMax - Max Firstly|SoftMax - Max Firstly]]</em>。</p>
<p>可以发现，当 <span class="math inline">\(\beta =0\)</span> 时，它是 mean，<span class="math inline">\(\beta \rightarrow +\infty\)</span> 时，它是 max（直观的理解就是，当趋向于无穷时，最大的数和其他数的差距拉到了无穷大，所以只有最大数前的系数趋向于1，其余为0）。</p>
<p>此外，作者还提出了 PowerMean 聚合器： <span class="math display">\[
\operatorname{Power\_Agg}(\cdot)=\bigg(\frac{1}{|\mathcal{N}(v)}\sum_{u\in\mathcal{N}{v}}\mathbf{m}^{p}_{vu}\bigg)^{\frac{1}{p}}
\]</span> 这里 <span class="math inline">\(p\)</span> 是个非0值，当 <span class="math inline">\(p =1\)</span> 时，它是 mean，<span class="math inline">\(p \rightarrow +\infty\)</span> 时，它是 max，且当 <span class="math inline">\(p=-1\)</span> 时是几何均值，当 <span class="math inline">\(p\rightarrow 0\)</span> 是调和均值。具体可参考 <em><a target="_blank" rel="noopener" href="https://mathworld.wolfram.com/PowerMean.html">PowerMean</a></em>。</p>
<p>值得注意的是，PowerMean 聚合器的特征值不能为0。实际上的实现，也和公式的表示略有区别，具体可参考 <em>[[Code for Collection 2#PowerMean - Clamp Firstly|PowerMean - Clamp Firstly]]</em>。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230818220732.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>另外作者认为，作者用以上的图来表示它所提出的聚合器所覆盖的范围。按照上图所示，SoftMax 和 PowerMean 仅有 Mean，Max 和 Min 的交集[[[WHY]]]。</p>
<p>另外，作者还尝试将这2个聚合器往 sum 上靠，然后它提出了以下的聚合器形式： <span class="math display">\[
∣\mathcal{N}(v)∣^y \cdot \operatorname{Agg}(\cdot)
\]</span> 他发现，当 <span class="math inline">\(y=1\)</span>，且 Agg 为 Mean 时，聚合器为 Sum。另外，在他实现的代码中，也做了进一步的调整，具体可参考 <em>[[Code for Collection 2#How to get Sum|How to get Sum]]</em>.</p>
<h2 id="generalized-aggregation-networks-gen">GENeralized Aggregation Networks (GEN)</h2>
<p>论文中，作者提出了一个新的消息传播（Message Passing）模型，或者也可将其看作是神经网络中的一个 Layer，并命名为 GEN。</p>
<p>第一步是 Message Construction，正如在 [[#Massage Passing|Message Passing]] 一节中所说，作者的 Message Passing，先通过了 embedding，然后 <span class="math display">\[
\mathbf m^{(l)}_{vu} = \rho^{(l)}(\mathbf h^{(l)}_v , \mathbf h^{(l)}_u , \mathbf h^{(l)}_{e_{vu}} ) = \operatorname{ReLU}(\mathbf h^{(l)}_u + \mathbb{1}(\mathbf h^{(l)} _{e_{vu}} ) \cdot (\mathbf h^{(l)}_{e_{vu}} ) + \epsilon, u \in \mathcal{N} (v)
\]</span> 第二步是 Message Aggregation，也就是进行消息传播，使用的聚合器可以是普通的 Mean/Sum/Max，同样可以设置为在该论文中提出的新型聚合器：Softamax、PowerMean。</p>
<p>第三步是 Vertex Update，作者首先对特征进行了 Normalization，再将其通过 MLP。其公式如下。其中 <span class="math inline">\(s\)</span> 是一个可学习的参数（作者也比较了采用固定参数对性能的影响，结果说明效果和聚合器有关，整体上使用可学习参数更好）。注意这里的 <span class="math inline">\(\mathbf h_v\)</span> 指的是经过<strong>第一步前</strong>的表示向量，而 <span class="math inline">\(\mathbf m_v\)</span> 则是经过<strong>第二步后</strong>的表示向量。 <span class="math display">\[
\mathbf h^{(l+1)}_v = \phi^{(l)}(\mathbf h^{(l)}_v , \mathbf m^{(l)}_v ) = \operatorname{MLP}(\mathbf h^{(l)}_v + s\cdot\Vert \mathbf h^{(l)}_v\Vert_2 \cdot \frac{\mathbf m^{(l)}_v }{\Vert \mathbf m^{(l)}_v \Vert_2 })
\]</span> 那么以上就是作者提出的整个 GEN Layer了。</p>
<p>另外作者还认为 Normalization (BatchNorm/LayerNorm) 拜访位置也会影响性能，他认为 Norm -&gt; ReLU -&gt; GEN 可以带来更好的性能。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230818202859.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>接着作者将 GEN Layer 和其他结构混合，提出了5个模型，如上图所示。可以看到，主要的区别在于 Normalization (BatchNorm/LayerNorm) 以及 ReLU 的位置不同、是否有残差连接、使用的聚合器是否为论文提出的SoftMax和PowerMean、聚合器的参数是固定的还是可学习的。</p>
<p>通过这种组合方式，旨在说明每一个变化是否能够提高性能。那么这里要说的是，哪些属于作者的模型。某种程度了上来说都属于。就算是 Plain GCN，它使用的 GEN 采用的是 Mean / Max / Sum 这类朴素的聚合器，但 GEN 中第一步的 Message Construction 和第三步的 Vertex Update 的方式都和其他模型有所不同，因此只要这 5 个模型有一个性能高即可。另外这 5 个模型并不一定是进化的关系，可以将其视作是模型的超参数。</p>
<h2 id="limitation-1">Limitation</h2>
<p>对于聚合器中 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(\beta\)</span> 参数，他们的变化范围最大可以到正无穷，即无边界。这是非常不好的，因为最佳参数可能造成计算溢出。</p>
<h2 id="conclusion-3">Conclusion</h2>
<p>本文的核心主要有以下几点： 1. 提出了新的 Message Passing 的模型（或者 Layer）：GEN，它包含 1. 新的 Message Construction 的方式 2. 新的聚合器，SoftMax 和 PowerMean，他们可以在 Mean 和 Max 聚合器中连续变化 3. 新的 Vertex Update 的方式，即引入了 Message Normalization 2. 提出了新的 Normalization (BatchNorm / LayerNorm) 的摆放位置 3. 将以上 2 点和残差连接相互组合，得到5个不同的模型。</p>
<h1 id="grand-graph-random-neural-networks-for-semi-supervised-learning-on-graphs"><strong>GRAND</strong> Graph Random Neural Networks for Semi-Supervised Learning on Graphs</h1>
<h2 id="drop-nodes-and-random-propagation">Drop Nodes and Random Propagation</h2>
<p>第一步：和 [[#<strong>DropEdge</strong> Towards Deep Graph Convolutional Networks On Node Classification|DropEdge]] 的想法相似，该论文采用 Drop Nodes 的方法来增强原数据集。也就是说，每个结点特征 <span class="math inline">\(x\)</span> 将以概率 <span class="math inline">\(p\)</span> 随机置0，由于采样符合伯努利分布，为了使数据的期望和原数据保持一致，我们会再乘上因子 <span class="math inline">\(\frac{1}{1-p}\)</span>。这一操作事实上在 dropout 中是默认的，可参考 pytorch 文档 <em><a target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/generated/torch.nn.Dropout.html?highlight=dropout#torch.nn.Dropout">dropout</a></em>。但是要注意 Drop Nodes 是将某一结点的特征全置为0，而 Dropout 是将特征矩阵中的某一元素置为0，其细粒度不同。</p>
<p>第二步：DropNode 之后，作者提出了另一个操作 Random Propagation。事实上就是将 0 到 K 阶的传播矩阵求个平均值，最后和特征矩阵相乘，这个操作没什么新奇的，它可以比较大程度地保留临近结点的特征。</p>
<p>第三步：结束以上2个操作后，将其输入到 MLP 预测。</p>
<p>以上过程可以用如下公式表示： <span class="math display">\[
\begin{align}
M =&amp; \operatorname{drop}(\mathbf{1},p)\times \mathbf{1}^T\\
% &amp;符号要放在等号后面？？
\widetilde{X} =&amp; \frac{M\cdot X}{1-p} \tag{Drop Nodes}\\
\overline{A}^{(s)} =&amp; \frac{1}{s+1}\sum_{i=0}^s \hat A^i\\
\overline{X}^{(s)} =&amp; \overline{A}^{(s)}\widetilde{X}\tag{Random Propagation}\\
\widetilde{Z}^{(s)} =&amp; \operatorname{MLP}(\overline{X},\Theta) \tag{Prediction}
\end{align}
\]</span></p>
<p>其中 Drop Nodes 可以首先获取一个 0/1 的 mask，在让 mask 和原数据相乘。 <span class="math inline">\(M\)</span> 为 Mask，<span class="math inline">\(\operatorname{drop}(\cdot,p)\)</span> 就是以 <span class="math inline">\(p\)</span> 的概率将元素随机置 0 的操作，<span class="math inline">\(\mathbf{1}\in \mathbb{R}^{N\times 1}\)</span> 是一个全 1 向量，输入的特征矩阵 <span class="math inline">\(X\in \mathbb{R}^{N\times F}\)</span>， <span class="math inline">\(\hat A\)</span> 为传播矩阵。</p>
<p>值得注意的是，以上公式中，假设总共传播 <span class="math inline">\(S\)</span> 次，那么可以得到 <span class="math inline">\(S\)</span> 个预测结果。</p>
<h2 id="sharpening-and-regularization">Sharpening and Regularization</h2>
<p>从前面一小节得到的 <span class="math inline">\(S\)</span> 个预测结果后，在经过以下的求均值和 sharpening 的操作。 <span class="math display">\[
\begin{align}
\overline{Z}&amp;=\frac{1}{S}\sum_{s=1}^{S}\widetilde Z^{(s)}\\
\overline{Z}_{ij}'&amp;= \overline{Z}^{\frac{1}{T}}_{ij}\bigg/\sum_{c=0}^{C-1}\overline{Z}_{ic}^{\frac{1}{T}},(j=0,1,...,C-1)
\end{align}
\]</span> 求均值是好理解的，但是可能对 sharpening 不是很能理解。该操作可以让原来的概率分布更极端化，使小的更小，大的更大，尤其当 <span class="math inline">\(T\rightarrow \infty\)</span> 时，对于每个结点对应的预测将是一个 one-hot 向量。我猜测是因为上述求均值的原因，平滑化了结点预测的概率分布，不利于优化，并且得到的分类器也是不合理的。需要注意的是 <span class="math inline">\(T\)</span> 是个超参数。</p>
<p>那么最后在训练时有 2 个损失，1个是各个 <span class="math inline">\(\widetilde Z^{(s)}\)</span> 和真实标签的交叉熵损失，还有一个则是各个预测如 <span class="math inline">\(\widetilde{Z}^{(s_1)}\)</span> 和 <span class="math inline">\(\widetilde{Z}^{(s_2)}\)</span> 的距离，我们成为一致性 (Consistency) 损失，即我们希望各个层次的预测应当不能相差太多，要尽量的接近。后一项损失我们可以看作是一个正则化项。总的损失可表示为如下公式。 <span class="math display">\[
\begin{align}
\mathcal{L}_{con} &amp;= \frac{1}{S}\sum_{s=1}^{S}\sum_{i=0}^{m-1} Y^T_i \log\widetilde{Z}_i^{(s)}\\
\mathcal{L}_{con} &amp;= \frac{1}{S}\sum_{s=1}^{S}\sum_{i=0}^{n-1}\Vert \overline{Z}_{i}'-\widetilde{Z}^{(x)}_i \Vert_2^2\\
\mathcal{L} &amp;= \mathcal{L}_{sup} + \lambda\mathcal{L}_{con}\\
\end{align}
\]</span></p>
<h2 id="grand">GRAND</h2>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230822115150.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>最后我们在整体看一下论文提出的模型，它可以用以上的图来表示，尤其是 DropNode 一块表现的是比较清晰的。</p>
<p>但更具体的，还可以用如下的伪代码来表示</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230822115204.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="three-issues">Three Issues</h2>
<p>该论文从开始就提出了 GCN 广泛存在的 3 个问题：1. 过拟合；2. 鲁棒性差；3. 过度平滑。</p>
<p>我们来看一下该模型是否有一定程度上缓解了这些问题。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230822144103.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>首先是过拟合，也就是模型的泛化能力（generalization），上图中的 Figure 2 表现了不同模型训练损失和验证集损失的关系，可以看到 GRAND 模型在添加了 RP（Random Propagation） 和 CR（Consistency Regularization）模块后，训练损失和验证集损失是比较接近的。</p>
<figure>
<img src="https://imagehost.vitaminz-image.top/20230822144111.png" srcset="/img/loading.gif" lazyload alt="image.png"><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>另外我们再来看一下鲁棒性，作者通过往数据集中随机增加伪边，以及基于元学习[[[WHAT]]]的增减边来对原数据集进行破坏，从 Figure 3 可以看出 GAT 对破坏后的数据集是比较敏感的，而GRAND展现出比较优良的性能。</p>
<h2 id="limitation-2">Limitation</h2>
<p>关于缺陷，在论文中也有提到，GRAND 是基于同配性假设的，即物以类聚。假如图缺乏同配性，即相似的结点并没有相互连接，那么效果可能会不好。这是很多半监督学习以及图神经网络共同的缺陷。</p>
<h2 id="conclusion-4">Conclusion</h2>
<p>作者的模型可以归为2个技术，一个是数据增强技术，即作者所谓的 Drop Nodes 和 Random Propagation，另一个则是正则化技术，通过让多种预测结果尽量接近，而制定正则化项。作者也确实一定程度上缓解了它提出的3个问题。</p>
<h1 id="附录">附录</h1>
<h2 id="vapnikchervonenkis-dimension">Vapnik–Chervonenkis dimension</h2>
<section class="footnotes">
<div class="footnote-list">
<ol>
<li>
<span id="fn:1" class="footnote-text"><span>Y. Rong, W. Huang, T. Xu, and J. Huang, “DropEdge: Towards Deep Graph Convolutional Networks on Node Classification.” arXiv, Mar. 12, 2020. doi: <a target="_blank" rel="noopener" href="https://doi.org/10.48550/arXiv.1907.10903">10.48550/arXiv.1907.10903</a>. <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:2" class="footnote-text"><span>Q. Li, Z. Han, and X.-M. Wu, “Deeper insights into graph convolutional networks for semi-supervised learning,” in <em>Proceedings of the AAAI conference on artificial intelligence</em>, 2018. <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:3" class="footnote-text"><span>A. Fout, J. Byrd, B. Shariat, and A. Ben-Hur, “Protein Interface Prediction using Graph Convolutional Networks,” in <em>Advances in Neural Information Processing Systems</em>, Curran Associates, Inc., 2017. Accessed: Aug. 06, 2023. [Online]. Available:<a target="_blank" rel="noopener" href="https://proceedings.neurips.cc/paper_files/paper/2017/hash/f507783927f2ec2737ba40afbd17efb5-Abstract.html">https://proceedings.neurips.cc/paper_files/paper/2017/hash/f507783927f2ec2737ba40afbd17efb5-Abstract.html</a> <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:4" class="footnote-text"><span>T. Hastie, S. Rosset, J. Zhu, and H. Zou, “Multi-class AdaBoost,” <em>Stat. Interface</em>, vol. 2, no. 3, pp. 349–360, 2009, doi: <a target="_blank" rel="noopener" href="https://doi.org/10.4310/SII.2009.v2.n3.a8">10.4310/SII.2009.v2.n3.a8</a>. <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:5" class="footnote-text"><span>M. Hardt and T. Ma, “Identity Matters in Deep Learning.” arXiv, Jul. 20, 2018. doi: <a target="_blank" rel="noopener" href="https://doi.org/10.48550/arXiv.1611.04231">10.48550/arXiv.1611.04231</a>. <a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
</ol>
</div>
</section>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/GNN/" class="category-chain-item">GNN</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%9B%BE/">#图</a>
      
        <a href="/tags/GNN/">#GNN</a>
      
        <a href="/tags/%E7%BB%BC%E8%BF%B0/">#综述</a>
      
        <a href="/tags/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/">#论文解读</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>GNN论文精选-第二组</div>
      <div>http://vitaminzl.com/2023/08/30/gnn/notes-for-collection-2/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>vitaminzl</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年8月30日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/09/02/gnn/lun-wen-su-du-2-gnn-xi-lie/" title="论文速读&lt;二&gt;：GNN系列">
                        <span class="hidden-mobile">论文速读&lt;二&gt;：GNN系列</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"N5b4uVEvRE5UcVcWvkv2ln10-gzGzoHsz","appKey":"KJFp10KGLr5F9HxFUUsL2AeD","path":"window.location.pathname","placeholder":"你的意见至关重要！","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
