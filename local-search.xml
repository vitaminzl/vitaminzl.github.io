<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>论文速读&lt;二&gt;：GNN系列</title>
    <link href="/2022/09/02/gnn/lun-wen-su-du-2-gnn-xi-lie/"/>
    <url>/2022/09/02/gnn/lun-wen-su-du-2-gnn-xi-lie/</url>
    
    <content type="html"><![CDATA[<h1 id="论文速读gnn系列">论文速读&lt;二&gt;：GNN系列</h1><p>论文速读系列的第二期，论文速读主要提取论文的Key Idea，本期为GNN系列的论文速读，选取了4篇经典论文和3篇近期的论文。<a href="https://vitaminzl.com/2022/07/16/kg/lun-wen-su-du-1-guan-xi-chou-qu/">上期</a>为知识图谱领域的关系抽取。</p><h2 id="key-idea">Key Idea</h2><h3 id="semi-supervised-classification-with-graph-convolutional-networks1"><em>Semi-supervised Classification with Graph Convolutional Networks</em><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Kipf T N, Welling M. Semi-supervised classification with graph convolutional networks[J]. arXiv preprint arXiv:1609.02907, 2016.](https://arxiv.org/abs/1609.02907)">[1]</span></a></sup></h3><p>GCN的核心公式如下，其中<span class="math inline">\(\sigma\)</span>表示激活函数，<span class="math inline">\(\tilde A=A+I\)</span>，也就是给每个结点加个自环，<span class="math inline">\(\tilde D=\sum_i A_{ij}\)</span>。<span class="math inline">\(H^{(l)}\)</span>为第<span class="math inline">\(l\)</span>层的embedding，<span class="math inline">\(W\)</span>是参数矩阵。它的形式看起来非常简单。 <span class="math display">\[H^{(l+1)}=\sigma (\tilde D^{-\frac{1}{2}}\tilde A\tilde D^{-\frac{1}{2}}H^{(l)}W^{(l)})\]</span> 从卷积的参数共享角度来看，其实就是每个结点的将自己与附近的参数聚合。第1次聚合后每个结点获取了直接邻居结点的特征，但第2次聚合就可以获取间接邻居的特征（因为直接邻居包含了它的邻居的特征）。所以在多层聚合下，每个结点可以获得全局的信息。</p><p><img src="https://imagehost.vitaminz-image.top/li-spectral-cluster-21.png" style="zoom:50%;"></p><h3 id="graph-attention-networks2"><em>Graph Attention Networks</em><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Veličković P, Cucurull G, Casanova A, et al. Graph attention networks[J]. arXiv preprint arXiv:1710.10903, 2017.](https://arxiv.org/abs/1710.10903)">[2]</span></a></sup></h3><p>GAN就是在GNN中加入注意力机制</p><p><img src="https://imagehost.vitaminz-image.top/gnn-note-3.png" style="zoom:50%;"></p><p>以下是注意力的计算公式，其中<span class="math inline">\(\vec h_i,shape(F,1);W,shape(F',F);\vec a,shape(2F',1)\)</span>。<span class="math inline">\(||\)</span>表示连接。看起来就是对2个向量进行线性变换后连接，再通过<span class="math inline">\(\vec a\)</span>他们获取之间的相关性，再做一个归一化。</p><p><span class="math display">\[\alpha_{ij}=\frac{\exp(LeakyReLU(\vec a^T[W\vec h_i|| W\vec h_j]))}{\sum_{k\in N_i}\exp(LeakyReLU(\vec a^T[W\vec h_i||W\vec h_j]))}\]</span> 和普通神经网络的注意力机制相同，GAN中也分为多头和单头的注意力机制。</p><p><span class="math inline">\(\vec h_i\)</span>的更新，单头注意力 <span class="math display">\[\vec h'_i = \sigma(\sum_{j\in N_i} \alpha_{ij}W\vec h^i)\]</span> 2种多头注意力的实现 <span class="math display">\[\vec h'_i = ||^{K}_{k=1} \sigma(\sum_{j\in N_i} \alpha^k_{ij}W^k\vec h^i)\\\vec h'_i = \sigma(\frac{1}{K}\sum^{K}_{k=1}\sum_{j\in N_i} \alpha^k_{ij}W^k\vec h^i)\]</span></p><h3 id="how-powerful-are-graph-neural-networks3"><em>How Powerful are Graph Neural Networks?</em><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Xu K, Hu W, Leskovec J, et al. How powerful are graph neural networks?[J]. arXiv preprint arXiv:1810.00826, 2018.](https://arxiv.org/abs/1810.00826)">[3]</span></a></sup></h3><p>这篇文章理论方面证明了GNN的上限是WL test(图同构测试)的上接，总结了信息聚合的方法以及对GNN的评价指标。 <span class="math display">\[h_{k+1}(u) = MLP((1+\epsilon) h_k(u) + \sum_{(u,v) \in E} h_k(v))\]</span> 其中<span class="math inline">\(\epsilon\)</span>是一个可学习的无理数参数。该论证证明了其可以达到WL test的上界。</p><h3 id="inductive-representation-learning-on-large-graphs4"><em>Inductive Representation Learning on Large Graphs</em><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Hamilton W, Ying Z, Leskovec J. Inductive representation learning on large graphs[J]. Advances in neural information processing systems, 2017, 30.](https://proceedings.neurips.cc/paper/2017/hash/5dd9db5e033da9c6fb5ba83c7a7ebea9-Abstract.html)">[4]</span></a></sup></h3><p><img src="https://imagehost.vitaminz-image.top/gnn-note-12.png"></p><p>如上图所示，GraphSAGE可以分为3个步骤：1. 对图中每个顶点邻居顶点进行采样；2. 根据聚合函数聚合邻居顶点蕴含的信息；3. 得到图中各顶点的向量表示供下游任务使用。</p><p><img src="https://imagehost.vitaminz-image.top/gnn-note-14.png"></p><p>每层的embedding生成可以用如上图的伪代码表示。其中AGGREGATE可以使用均值、池化以及LSTM函数。</p><h3 id="finding-global-homophily-in-graph-neural-networks-when-meeting-heterophily5"><em>Finding Global Homophily in Graph Neural Networks When Meeting Heterophily</em><sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Li X, Zhu R, Cheng Y, et al. Finding Global Homophily in Graph Neural Networks When Meeting Heterophily[J]. arXiv preprint arXiv:2205.07308, 2022.](https://arxiv.org/abs/2205.07308)">[5]</span></a></sup></h3><p>全局同质性、异质图。现有的网络通过多次的领域聚合获取远距离的信息。本文通过相关系数矩阵（类似于注意力机制）获取全局信息。且相关系数矩阵可转换为有闭式解的优化问题，经过简化，可将计算复杂度缩小至线性。</p><p>GloGNN，GloGNN++（系数矩阵加上了自相关）。</p><p><img src="https://imagehost.vitaminz-image.top/gnn-note-2.png" style="zoom:50%;"></p><p>核心公式 <span class="math display">\[H^{(0)}=(1-\alpha)MLP_1(X)+\alpha MLP_2(A)\\H^{(l+1)}=(1-\gamma)Z^{(l)*}H^{(l)}+\gamma H^{(0)}\\\]</span> <span class="math inline">\(Z^{(l)*}\)</span>通过求解优化问题的闭式解获得。</p><p>Grouping Effect：通过证明可得，<span class="math inline">\(Z^{(l*)},(Z^{(l*)})^T,H^{(l+1)}\)</span>都具有grouping effect。即当特征足够接近、结构足够接近时，对应结点的特征表示也足够接近，相关系数也足够接近。</p><h3 id="large-scale-learning-on-non-homophilous-graphs-new-benchmarks-and-strong-simple-methods6"><em>Large Scale Learning on Non-Homophilous Graphs: New Benchmarks and Strong Simple Methods</em><sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Lim D, Hohne F, Li X, et al. Large scale learning on non-homophilous graphs: New benchmarks and strong simple methods[J]. Advances in Neural Information Processing Systems, 2021, 34: 20887-20902.](https://proceedings.neurips.cc/paper/2021/hash/ae816a80e4c1c56caa2eb4e1819cbb2f-Abstract.html)">[6]</span></a></sup></h3><p><img src="https://imagehost.vitaminz-image.top/gnn-note-4.png" style="zoom:50%;"></p><p>LINKX是一个看起来很简单的模型，是基于MLP，并没有作卷积操作。它首先将结点的特征矩阵与邻接矩阵经过分别经过2个MLP，然后再做一个连接，接着与参数矩阵<span class="math inline">\(W\)</span>相乘，和前面经过MLP层的输出（类似于ResNet）</p><p>相加，接着经过一个激活函数和MLP，输出结果。</p><h3 id="gnnautoscale-scalable-and-expressive-graph-neural-networks-via-historical-embeddings7"><em>Gnnautoscale: Scalable and expressive graph neural networks via historical embeddings</em><sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Fey M, Lenssen J E, Weichert F, et al. Gnnautoscale: Scalable and expressive graph neural networks via historical embeddings[C]//International Conference on Machine Learning. PMLR, 2021: 3294-3304.](http://proceedings.mlr.press/v139/fey21a.html)">[7]</span></a></sup></h3><p><img src="https://imagehost.vitaminz-image.top/gnn-note-13.png"></p><p>改论文主要聚焦于如何减小大型图数据训练的计算和内存开销。</p><p>GAS 框架有两个主要组成部分：</p><p>首先，第一部分是构建一个小批量节点（执行快速随机子采样）并修剪 GNN 计算图以仅保留小批量内的节点及其 1 跳邻居节点——这意味着 GAS 的尺度独立于 GNN 深度。其次，每当 GNN 聚合需要小批量节点嵌入时，GAS 就会从存储在 CPU 上的历史嵌入中检索它们。同时，当前小批量节点的历史嵌入也不断更新。</p><p>第二部分是与子采样的关键区别——能够使 GNN 最大限度地表达信息，并将当前的小批量数据和历史嵌入组合起来，得到完整的邻域信息并加以利用，同时确保对大型图的可扩展性。</p><p>GAS 的作者还将他们的想法整合到流行的 PyTorch 几何库中。于是可以在非常大的图上训练大多数的消息传递 GNN，同时降低 GPU 内存需求并保持接近全批次的性能（即在全图上训练时的性能）。</p><h2 id="参考资料">参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://arxiv.org/abs/1609.02907">Kipf T N, Welling M. Semi-supervised classification with graph convolutional networks[J]. arXiv preprint arXiv:1609.02907, 2016.</a> <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://arxiv.org/abs/1710.10903">Veličković P, Cucurull G, Casanova A, et al. Graph attention networks[J]. arXiv preprint arXiv:1710.10903, 2017.</a> <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://arxiv.org/abs/1810.00826">Xu K, Hu W, Leskovec J, et al. How powerful are graph neural networks?[J]. arXiv preprint arXiv:1810.00826, 2018.</a> <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://proceedings.neurips.cc/paper/2017/hash/5dd9db5e033da9c6fb5ba83c7a7ebea9-Abstract.html">Hamilton W, Ying Z, Leskovec J. Inductive representation learning on large graphs[J]. Advances in neural information processing systems, 2017, 30.</a> <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://arxiv.org/abs/2205.07308">Li X, Zhu R, Cheng Y, et al. Finding Global Homophily in Graph Neural Networks When Meeting Heterophily[J]. arXiv preprint arXiv:2205.07308, 2022.</a> <a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://proceedings.neurips.cc/paper/2021/hash/ae816a80e4c1c56caa2eb4e1819cbb2f-Abstract.html">Lim D, Hohne F, Li X, et al. Large scale learning on non-homophilous graphs: New benchmarks and strong simple methods[J]. Advances in Neural Information Processing Systems, 2021, 34: 20887-20902.</a> <a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="http://proceedings.mlr.press/v139/fey21a.html">Fey M, Lenssen J E, Weichert F, et al. Gnnautoscale: Scalable and expressive graph neural networks via historical embeddings[C]//International Conference on Machine Learning. PMLR, 2021: 3294-3304.</a> <a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>GNN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GNN</tag>
      
      <tag>图</tag>
      
      <tag>论文速读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谱在聚类中的应用</title>
    <link href="/2022/08/30/gnn/pin-pu-zai-ju-lei-zhong-de-ying-yong/"/>
    <url>/2022/08/30/gnn/pin-pu-zai-ju-lei-zhong-de-ying-yong/</url>
    
    <content type="html"><![CDATA[<h1 id="谱在聚类中的应用">谱在聚类中的应用</h1><p>本文主要对谱聚类的几篇论文进行解读，并对一部分的结果进行复现。本文首先从谱聚类的一般过程入手，介绍传统的谱聚类方法NCuts、NJW。针对传统方法的相似度量的缺陷，引入改进方法ZP；又针对特征向量的选择问题，引入改进方法PI。结合以上2种方式，加入TKNN，引入改进方法ROSC，接着对ROSC中修正相似度矩阵的缺陷，结合trace lasso正则项，引入改进方法CAST。最后，对于ROSC和CAST中都提到的Group Effect进行解读。文章结尾补充了幂代法和矩阵求导的内容。其中我分别对PI方法和ROSC方法进行代码复现。</p><p>代码的仓库地址：<a href="https://github.com/vitaminzl/SpectralCluster">https://github.com/vitaminzl/SpectralCluster</a></p><p>备用镜像：<a href="https://gitee.com/murphy_z/spectral-cluster">https://gitee.com/murphy_z/spectral-cluster</a></p><h2 id="pipeline">Pipeline</h2><p><img src="https://imagehost.vitaminz-image.top/gnn-note-10.png"></p><p>谱聚类的一般过程如上图所示<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Li X, Kao B, Shan C, et al. CAST: a correlation-based adaptive spectral clustering algorithm on multi-scale data[C]//Proceedings of the 26th ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining. 2020: 439-449.](https://dl.acm.org/doi/abs/10.1145/3394486.3403086)">[2]</span></a></sup>。对于一系列的数据，我们首先计算数据之间的相似度矩阵<span class="math inline">\(S\)</span>，常用的相似度度量为高斯核<span class="math inline">\(S_{ij}=\exp(-\frac{||\vec x_i-\vec x_j||^2}{2\sigma^2})\)</span>，然后求其拉普拉斯矩阵<span class="math inline">\(L=D-S\)</span>，其中<span class="math inline">\(D\)</span>为对角矩阵，且<span class="math inline">\(D_{ii}=\sum A_{ij}\)</span>。然后求出拉普拉斯矩阵的特征向量，选择特征值<span class="math inline">\(k\)</span>小的特征向量进行k-means聚类。</p><p>以上过程可以理解为，将原数据利用相似度度量转化为图数据，即使得每个数据间连着一条”虚边“，相似度即为边的权重。接下来将数据转换到频域上，选择一些低频作为数据的特征向量，这是因为低频成分往往具有更高层次、更具信息量的特征，而高频成分则更可能是噪声。然后对这些特征向量进行聚类。</p><p>而这种一般的方法在多尺度的数据聚类中往往表现不佳。</p><h2 id="ncuts">NCuts</h2><p><img src="https://imagehost.vitaminz-image.top/li-spectral-cluster-4.png" style="zoom: 33%;"></p><p>我们首先介绍一些远古的谱聚类方法。Normalized Cut<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Shi J, Malik J. Normalized cuts and image segmentation[J]. IEEE Transactions on pattern analysis and machine intelligence, 2000, 22(8): 888-905.](https://ieeexplore.ieee.org/abstract/document/868688)">[8]</span></a></sup>的想法来源于最小割。如果存在连通图<span class="math inline">\(\mathcal G=\{\mathcal V, \mathcal E\}\)</span>，每条边<span class="math inline">\(e_i\in \mathcal E\)</span>有着权重<span class="math inline">\(w_i\)</span>，为了使得连通图分割成2个连通子图，那么需要移掉一些边。若移掉这些边权之和最小，那么我们称这样的分割方法为最小割。这和聚类非常相似，边权可以表示点和点的联系，若存在两个类，那么类之间的联系应当是比较小的，类内的联系比较大。</p><p>所以一种可行的想法是，首先对连通图进行一次取最小割，然后再对连通子图进一步地取最小割，直到到达某一阈值为止。但显然这样存在一个问题，如上图所示，要使去掉边权之和最小，那每次分割肯可能都会倾向于指割掉一条边，这自然不合理。</p><p>一种自然的想法使对权重进行归一化处理 <span class="math display">\[NCut(A,B)=\frac{cut(A,B)}{assoc(A,V)}+\frac{cut(A,B)}{assoc(B,V)}\]</span> 其中<span class="math inline">\(assoc(A,V)\)</span>表示<span class="math inline">\(A\)</span>到所有连接的结点权重之和，<span class="math inline">\(cut(A,B)\)</span>则是分割后移掉边权之和。所以假如当某一侧的结点非常少时，那么这<span class="math inline">\(cut\)</span>的值可能比<span class="math inline">\(assoc\)</span>大，极端情况下值分割一个点，那么分母就是0了，则最后的结果是无穷大。</p><p>因此利用前面的想法，每次使用<span class="math inline">\(NCut\)</span>，然后再对子图进行<span class="math inline">\(NCut\)</span>，不断进行二分就可以了。</p><p>听起来很简单，但很遗憾的是，求最小割是一个NP难的问题，因此只能求其近似解。</p><p>通过一系列的复杂推导（太难了哈哈），可以得到<span class="math inline">\(D^{-\frac{1}{2}}LD^{-\frac{1}{2}}\)</span>第2小的特征向量就是对应的最小割。当然这里需要设定一个阈值，因为特征向量求出来是浮点数，但其数据会偏向两级。然后利用上面的二分法求解即可。</p><p>但是现在多数使用的NCuts是<span class="math inline">\(\min NCut(A,B)\)</span>问题转化为以下优化问题。 <span class="math display">\[\min \vec x^T(D^{-\frac{1}{2}}LD^{-\frac{1}{2}})\vec x\\st. \vec x^T\vec x=1\]</span> 上面这个形式其实就是瑞丽熵，那么只要取<span class="math inline">\(k\)</span>个最小的特征值对应的特征向量进行聚类即可。</p><h2 id="njw">NJW</h2><p>NJW算法<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Ng A, Jordan M, Weiss Y. On spectral clustering: Analysis and an algorithm[J]. Advances in neural information processing systems, 2001, 14.](https://proceedings.neurips.cc/paper/2001/hash/801272ee79cfde7fa5960571fee36b9b-Abstract.html)">[6]</span></a></sup>是取3个人名的首字母命名的。该算法和NCuts非常类似，甚至可以看作是其变形。 <span class="math display">\[\begin{align*}D^{-\frac{1}{2}}LD^{-\frac{1}{2}}&amp;=D^{-\frac{1}{2}}(D-S)D^{-\frac{1}{2}}\\&amp;=I-D^{-\frac{1}{2}}SD^{\frac{1}{2}}\end{align*}\]</span> 所以我们可以转而去求<span class="math inline">\(D^{-\frac{1}{2}}SD^{\frac{1}{2}}\)</span>最大的<span class="math inline">\(k\)</span>个特征向量，然后进行聚类。</p><h2 id="zp">ZP</h2><p>前面提到计算相似度矩阵时，我们常用高斯核<span class="math inline">\(S_{ij}=\exp(-\frac{||\vec x_i-\vec x_j||^2}{2\sigma^2})\)</span>，而高斯核中<span class="math inline">\(\sigma\)</span>的选取是需要考虑的，很多时候常常人工设定<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Zelnik-Manor L, Perona P. Self-tuning spectral clustering[J]. Advances in neural information processing systems, 2004, 17.](https://proceedings.neurips.cc/paper/2004/hash/40173ea48d9567f1f393b20c855bb40b-Abstract.html)">[3]</span></a></sup>。但更重要的是<span class="math inline">\(\sigma\)</span>是一个全局的参数，这在多尺度数据中具有一些缺陷。如设定的值较大时，稠密图的数据会趋于相似，设定较小时，稀疏图的数据则相似度过小。</p><p><img src="https://imagehost.vitaminz-image.top/li-spectral-cluster-8.png"></p><p>ZP方法提出里一种局部调整<span class="math inline">\(\sigma\)</span>的设定，距离度量修正为<span class="math inline">\(S_{ij}=\exp(-\frac{||\vec x_i-\vec x_j||^2}{2\sigma_i\sigma_j})\)</span>。其中<span class="math inline">\(\sigma_i, \sigma_j\)</span>是依附于<span class="math inline">\(\vec x_i, \vec x_j\)</span>的是一种局部的参数。这一参数的设定应通过样本的特征取选取。在论文中<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Zelnik-Manor L, Perona P. Self-tuning spectral clustering[J]. Advances in neural information processing systems, 2004, 17.](https://proceedings.neurips.cc/paper/2004/hash/40173ea48d9567f1f393b20c855bb40b-Abstract.html)">[3]</span></a></sup>中选择的方法是<span class="math inline">\(\vec x_i\)</span>到第<span class="math inline">\(K\)</span>个邻居的欧式距离，实验表明<span class="math inline">\(K\)</span>取7在多个数据集上的效果表现良好。如上图所示，结点之间的边厚度表示数据间的权重大小（仅显示周围数据的权重）。图b是原来的高斯核距离度量，图c是修正后的。可以看到图b中靠近蓝点的边仍然比较厚，而图c则避免了的这种现象。</p><h2 id="pi">PI</h2><p>PI(Power Iteration)为幂迭代法<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Lin F, Cohen W W. Power iteration clustering[C]//ICML. 2010.](https://openreview.net/forum?id=SyWcksbu-H)">[5]</span></a></sup>。其灵感来源于幂迭代法用求主特征值（在<a href="##Dominant%20Eigenvalue">文章的后面部分</a>会更详细地说明）。</p><p>我们设<span class="math inline">\(W=D^{-1}A\)</span>，该矩阵有时候叫转移矩阵，因为它和马尔可夫的状态转移矩阵非常类似。每行的和为1，每个元素<span class="math inline">\(W_{i,j}\)</span>可以看作是<span class="math inline">\(i\)</span>结点到<span class="math inline">\(j\)</span>结点转移的概率。它和归一化随机游走矩阵<span class="math inline">\(L_r=I-W\)</span>有着重要的联系。NCuts算法证明了<span class="math inline">\(L_r\)</span>第2小的特征值所对应的特征向量可以作为NCuts算法的一种近似。</p><p>这里需要说明的是，<span class="math inline">\(L_r\)</span>最小的特征值为0，容易证明<span class="math inline">\(\vec 1=[1, 1, ..., 1]\)</span>是<span class="math inline">\(L_r\)</span>的0所对应的特征向量。而对于<span class="math inline">\(W\)</span>来说则，其最大的特征值为1，且<span class="math inline">\(\vec 1\)</span>是对应的特征向量。需要说明的是，<span class="math inline">\(L_r\)</span>最小的几个特征向量或<span class="math inline">\(W\)</span>最大的几个特征向量是有效的，其余可能是噪声。</p><p>首先给定一个向量<span class="math inline">\(\vec v^{(0)}= c_1\vec e_1 + c_2\vec e_2,..., +c_n\vec e_n\)</span>，其中<span class="math inline">\(\vec e_i\)</span>为<span class="math inline">\(W\)</span>的特征向量。且<span class="math inline">\(\vec e_i\)</span>所对应的特征值<span class="math inline">\(\lambda_i\)</span>满足<span class="math inline">\(1=\lambda_1 &gt; \lambda_2&gt;...&gt;\lambda_n\)</span>。</p><p><span class="math display">\[\vec v^{(t+1)} = \frac{W\vec v^{(t)}}{||W\vec v^{(t)}||_1}\]</span> 假如我们按照如上的迭代公式进行迭代，则有如下过程（暂且忽略迭代公式的分母归一化项） <span class="math display">\[\begin{align*}\vec v^{(1)} &amp;= W \vec v^{(0)} \\&amp;=c_1W\vec  e_1 + c_2W\vec e_2,..., +c_nW\vec e_n\\&amp;=c_1\lambda_1  e_1 + c_2\lambda_2\vec e_2,..., +c_n\lambda_n\vec e_n\end{align*}\]</span> 则 <span class="math display">\[\begin{align*}\vec v^{(t)} &amp;= Wv^{(t−1)} = W^2v^{(t−2)} = ... = W^tv^{(0)}\\&amp;=c_1W^t\vec  e_1 + c_2W^t\vec e_2,..., +c_nW^t\vec e_n\\&amp;=c_1\lambda_1^t  e_1 + c_2\lambda_2^t\vec e_2,..., +c_n\lambda_n^t\vec e_n\\&amp;=c_1\lambda_1^t\bigg[e_1+\sum\frac{c_2}{c_1}\bigg(\frac{\lambda_i}{\lambda_1}\bigg)^t\vec e_i)\bigg]\end{align*}\]</span> 当<span class="math inline">\(t\rightarrow +\infty\)</span>时，<span class="math inline">\(\frac{c_2}{c_1}(\frac{\lambda_i}{\lambda_1})^t\)</span>会趋向于0。该方法的提出者认为，在有效成分<span class="math inline">\(\vec e_i\)</span>的<span class="math inline">\(\lambda_i\)</span>往往会接近于<span class="math inline">\(\lambda_1\)</span>，而高频的一些噪声成分<span class="math inline">\(\lambda_j\)</span>会接近于0。在迭代过程中使得有效成分<span class="math inline">\(\vec e_i\)</span>前面的权重和噪声成分前的权重的差距会迅速扩大。</p><p>但是迭代的次数不宜过多，因为最后的结果会趋向于<span class="math inline">\(k\vec 1\)</span>，因为<span class="math inline">\(W\)</span>的主特征向量就是<span class="math inline">\(\vec 1\)</span>。因此我们需设置一个迭代的门限值，以截断迭代过程。具体的算法如下。</p><p><img src="https://imagehost.vitaminz-image.top/gnn-note-11.png" style="zoom: 40%;"></p><p>这里以论文中开始提到的3圆圈数据集为例子，进行结果的复现，如下图所示。</p><p><img src="https://imagehost.vitaminz-image.top/li-spectral-cluster-5.png" style="zoom:50%;"></p><p>通过以上的算法，我选取几次的迭代结果<span class="math inline">\(\vec v^{(t)}\)</span>进行可视化，同一个类别在后面的迭代过程中逐渐局部收敛到一个值。</p><p><img src="https://imagehost.vitaminz-image.top/li-spectral-cluster-7.png" style="zoom: 60%;"></p><p>在实验中发现，其结果和许多因素有关，其中包括高斯核距离度量中的<span class="math inline">\(\sigma\)</span>，初始的向量<span class="math inline">\(\vec v^{(0)}\)</span>（论文中取<span class="math inline">\(\vec v^{(0)}= \frac{\sum_j A_{ij}}{\sum_i\sum_j A_{ij}}\)</span>），结束时的<span class="math inline">\(\hat\epsilon\)</span>设置，甚至发现使用<span class="math inline">\(W^T\)</span>具有更好的效果，这是因为<span class="math inline">\(W^T\)</span>的主特征值的特征向量就已经具有分类的效果（其意义尚待研究），而<span class="math inline">\(W\)</span>的主特征向量是<span class="math inline">\(\vec 1\)</span>，但这仅仅针对于3圆圈这一数据集而言。在<a href="#问题与总结">问题与总结</a>中，会提到这一点。此外还有计算机的运算精度也会影响结果。</p><p>该方法的一个重要优点是简单高效，其收敛速度快，在百万级别的数据中也能在几秒内收敛。缺陷是过分拔高了特征值大的部分，在多尺度数据中存在一些低特征值但仍然重要的信息。</p><p>以下是主函数的代码，完整代码见：https://github.com/vitaminzl/SpectralCluster/blob/master/PI.py</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    data, labels = get3CircleData(radius=[<span class="hljs-number">0.1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">17</span>], nums=[<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">80</span>])<br>    draw3CircleData(x=data[:, <span class="hljs-number">0</span>], y=data[:, <span class="hljs-number">1</span>], labels=labels, title=<span class="hljs-string">"Data Set"</span>)<br>    S_mtx = getSimilarMatrix(data, sigma=<span class="hljs-number">1.8</span>)<br>    W = np.diag(<span class="hljs-number">1</span> / np.<span class="hljs-built_in">sum</span>(S_mtx, axis=<span class="hljs-number">0</span>)) @ S_mtx<br>    v_t = PowerIter(W, iter_nums=<span class="hljs-number">300</span>, eps=<span class="hljs-number">1e-5</span>, labels=labels)<br>    plt.show()<br></code></pre></td></tr></tbody></table></figure><h2 id="tknn">TKNN</h2><p><img src="https://imagehost.vitaminz-image.top/li-spectral-cluster-10.png"></p><p>聚类问题转化为图问题时，需要解决邻接问题。定义结点之间的连接常常有2种方式<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[https://csustan.csustan.edu/~tom/Clustering/GraphLaplacian-tutorial.pdf](https://csustan.csustan.edu/~tom/Clustering/GraphLaplacian-tutorial.pdf)">[4]</span></a></sup>。第一种如上图左，每个数据选择自己最近的K个邻居相邻接，得到的图被称为K邻接图（K Nearest Neighbor Graph）；第二种如上图右，每个结点选择半径<span class="math inline">\(\epsilon\)</span>的邻居相邻接。</p><p><img src="https://imagehost.vitaminz-image.top/li-spectral-cluster-14.png"></p><p>假如我们使用KNN的方法，K取4。如上图a所示，红色结点的4个最近邻用红线连接，绿色结点的4个最近邻用绿线连接。我们会发现，虽然红色的最近邻包括绿色，但绿色不包括红色，我们称红色和绿色不是<strong>相互近邻</strong>。但如图b所示，则红色和绿色则为相互近邻。若2个结点是相互近邻，则称这2个结点<strong>相互可达</strong>。如图c所示，红色与绿色是相互近邻，绿色和黄色相互近邻，那么红色和绿色也<strong>相互可达</strong>。</p><p>Transitive K Nearest Neighbor(TKNN) Graph 是指当2个结点时相互可达的，则二者连接一条边。因此其邻接矩阵<span class="math inline">\(W\)</span>中，若2个点<span class="math inline">\(i,j\)</span>相互可达，<span class="math inline">\(W_{i,j}=W_{j,i}=1\)</span>。</p><p>构造的过程可描述如下：</p><ul><li>step1: 构造K邻接矩阵<span class="math inline">\(A\)</span>，对于结点<span class="math inline">\(i\)</span>由<span class="math inline">\(k\)</span>个邻居<span class="math inline">\(j\)</span>，则<span class="math inline">\(A_{i, j}=1\)</span></li><li>step2: 构造相互近邻矩阵<span class="math inline">\(A'=A A^T\)</span>，若为相互近邻，则为1，否则为0。</li><li>step3: 寻找<span class="math inline">\(A'\)</span>的所有连通分量<span class="math inline">\(S\)</span></li><li>step4: 对于连通分量<span class="math inline">\(S_i\)</span>中的每2个元素<span class="math inline">\(S_{i,j}, S_{i,k}\)</span>，令<span class="math inline">\(W_{S_{i,j},S_{i,k}}=W_{S_{i,k},S_{i,j}}=1\)</span>，其余为0。</li></ul><p>代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getTKNN_W</span>(<span class="hljs-params">S_mtx, K</span>):<br>    N = S_mtx.shape[<span class="hljs-number">0</span>]<br>    KNN_A = np.zeros((N, N), dtype=np.int32)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>        idx = np.argsort(S_mtx[i, :])<br>        KNN_A[i, idx[(N-K):]] = <span class="hljs-number">1</span><br>    MKNN_A = KNN_A * KNN_A.T<br>    G = nx.from_numpy_array(MKNN_A)<br>    compo_list = [c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> nx.connected_components(G)]<br>    TKNN_W = np.zeros((N, N), dtype=np.int32)<br>    <span class="hljs-keyword">for</span> c_i <span class="hljs-keyword">in</span> compo_list:<br>        c = np.array(<span class="hljs-built_in">list</span>(c_i), dtype=np.int32)<br>        idx_c = np.tile(c, (<span class="hljs-built_in">len</span>(c), <span class="hljs-number">1</span>))<br>        TKNN_W[idx_c.T, idx_c] = <span class="hljs-number">1</span> - np.identity(<span class="hljs-built_in">len</span>(c))<br><br>    <span class="hljs-keyword">return</span> TKNN_W<br></code></pre></td></tr></tbody></table></figure><h2 id="rosc">ROSC</h2><p><img src="https://imagehost.vitaminz-image.top/li-spectral-cluster-9.png"></p><p>如上图所示为ROSC方法的流程图。ROSC方法<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Li X, Kao B, Luo S, et al. Rosc: Robust spectral clustering on multi-scale data[C]//Proceedings of the 2018 World Wide Web Conference. 2018: 157-166.](https://dl.acm.org/doi/abs/10.1145/3178876.3185993)">[1]</span></a></sup>结合了以上2种方法，但相比于PI方法不同的是，它并不是将PI得到的输出直接作为k-means聚类的输入，而是增加了一个求修正相似矩阵的过程。</p><p>首先随机设置不同的<span class="math inline">\(\vec v^{(0)}\)</span>获取<span class="math inline">\(p\)</span>个“伪特征向量”，拼成一个<span class="math inline">\(p\times n\)</span>的矩阵矩阵<span class="math inline">\(X\)</span>，并对<span class="math inline">\(X\)</span>进行标准化，即使得<span class="math inline">\(XX^T=I\)</span>。</p><p>ROSC论文中认为，相似度矩阵的意义可以表示为某一个实体能够被其他实体所描述的程度。即任何一个实体<span class="math inline">\(x_{i}=\sum Z_{i,j}x_j\)</span>，这里<span class="math inline">\(Z_{i,j}\)</span>即为修正相似度矩阵。因此就有： <span class="math display">\[X=XZ+O\]</span> 其中<span class="math inline">\(O\)</span>表示噪声矩阵。</p><p>定义优化问题 <span class="math display">\[\min_{Z}||X-XZ||_F^2+\alpha_1||Z||_F+\alpha_2||W-Z||_F\]</span> 优化问题的第一项表示最小化噪声，第二项则是<span class="math inline">\(Z\)</span>的Frobenius 范数<sup id="fnref:12" class="footnote-ref"><a href="#fn:12" rel="footnote"><span class="hint--top hint--rounded" aria-label="[https://mathworld.wolfram.com/FrobeniusNorm.html](https://mathworld.wolfram.com/FrobeniusNorm.html)">[12]</span></a></sup>），为正则化项，用于平衡其他2项，第三项则是减小与前文中TKNN的邻接矩阵<span class="math inline">\(W\)</span>的差距。<span class="math inline">\(\alpha_1,\alpha_2\)</span>是平衡参数，需要人工设置。</p><p>求解以上优化问题，可以先对<span class="math inline">\(Z\)</span>求导（<a href="##Derivatives%20of%20Matrix">文章的后面</a>还会做一些补充），使导数为0即可。对三项项求导有 <span class="math display">\[\begin{align*}\frac{\partial ||X-XZ||^2_F}{\partial Z}&amp;=-2X^T(X-XZ)\\\frac{\partial\alpha_1||Z||^2_F}{\partial Z}&amp;=2\alpha_1Z\\\frac{\partial\alpha_2||W-Z||^2_F}{\partial Z}&amp;=-2\alpha_2(W-Z)\end{align*}\]</span> 三项相加有 <span class="math display">\[-X^T(X-XZ)+\alpha_1Z-\alpha_2(W-Z)=0\]</span> 整理可得 <span class="math display">\[Z^*=(2X^TX+\alpha_1 I+\alpha_2 I)^{-1}(X^TX+\alpha_2W)\]</span> 但这样求出来的<span class="math inline">\(Z^*\)</span>可能使不对称的，且可能存在负数。所以这里再次做了一个修正<span class="math inline">\(\tilde Z=(|Z^*|+|Z^*|^T)/2\)</span>。</p><p>接下来就可以执行一般的谱聚类方法了。具体的算法流程可以用如下图所示：</p><p><img src="https://imagehost.vitaminz-image.top/li-spectral-cluster-12.png" style="zoom: 33%;"></p><p>算法第4行中的whiten为白化处理<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="[https://en.wikipedia.org/wiki/Whitening_transformation](https://en.wikipedia.org/wiki/Whitening_transformation)">[9]</span></a></sup>，是数据预处理的一种常用方法。它类似于PCA，但与PCA不同的是，PCA往往用来降维，而白化则是利用PCA的特征向量，将数据转换到新的特征空间，然后对新的坐标进行方差归一化，目的是去除输入数据的冗余信息。</p><p>根据上述算法，以下使用python对其进行复现。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ROSC</span>(<span class="hljs-params">S, C_k, t_k, alpha1, alpha2</span>):<br>    W_tknn = getTKNN_W(S, K=t_k)<br>    W = np.diag(np.<span class="hljs-built_in">sum</span>(S, axis=<span class="hljs-number">0</span>)) @ S<br>    X = prep.PIC_k(W, k=C_k)<br>    X = prep.whiten(X)<br>    X = prep.norm(X)<br>    Z = getROSC_Z(X.T, W_tknn, alpha1, alpha2)<br>    Z = (np.<span class="hljs-built_in">abs</span>(Z) + np.<span class="hljs-built_in">abs</span>(Z.T)) / <span class="hljs-number">2</span><br>    C = postp.ncuts(Z, C_k)<br>    <span class="hljs-keyword">return</span> C<br></code></pre></td></tr></tbody></table></figure><p>主函数的代码如下</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">data_name</span>):<br>    path = <span class="hljs-string">"dataset/"</span> + data_name + <span class="hljs-string">".txt"</span><br>    data = np.loadtxt(<span class="hljs-string">"dataset/Syn.txt"</span>, delimiter=<span class="hljs-string">','</span>, dtype=np.float64)<br>    label = np.loadtxt(<span class="hljs-string">"dataset/SynLabel.txt"</span>, dtype=np.int32)<br>    C_k = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(label))<br>    S = prep.getSimilarMatrix2(data=data)<br>    C = ROSC(S, C_k=C_k, t_k=t, alpha1=<span class="hljs-number">1</span>, alpha2=<span class="hljs-number">0.01</span>)<br>    prt, AMI, RI = postp.assess(label_true=label, label_pred=C)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{data_name}</span>\nPurity: <span class="hljs-subst">{prt}</span>\nAMI: <span class="hljs-subst">{AMI}</span>\nRI: <span class="hljs-subst">{RI}</span>\n"</span>)<br></code></pre></td></tr></tbody></table></figure><p>完整代码见https://github.com/vitaminzl/SpectralCluster/blob/master/ROSC.py</p><p><img src="https://imagehost.vitaminz-image.top/li-spectral-cluster-20.png"></p><p>我首先使用了人工合成的数据集，如上图左所示。使用论文中的参数效果并不是很好，然后调整了一下求解TKNN矩阵的K，原文使用的是4，我调整为8，结果效果猛增，甚至优于论文的结果，如上图右所示，只有极个别点分错。不过根据数据集调参还是不科学的哈哈哈😂。其中Purity=0.9861，AMI=0.9307，RI=0.9784。</p><p>然后我对TKNN的K参数从1到12开始调整，3个指标的变化曲线如下图所示。感觉变化还是蛮明显的。</p><p><img src="https://imagehost.vitaminz-image.top/li-spectral-cluster-17.png" style="zoom: 67%;"></p><p>以下是5个数据集的实验结果，参数除了TKNN是的K是8以外，其他都和原论文相同，即<span class="math inline">\(\alpha_1=1,\alpha_2=0.01\)</span>。大部分的数据集都没有论文的结果好（比论文结果好的加了粗），但也相差不多。除了MNist0127这个数据集是例外，其结果异常地差劲，也不知道是什么原因。</p><table><thead><tr class="header"><th>数据集</th><th>Purity</th><th>AMI</th><th>RI</th></tr></thead><tbody><tr class="odd"><td>COIL20</td><td>0.8486</td><td>0.9339</td><td>0.9683</td></tr><tr class="even"><td>Glass</td><td><strong>0.6074</strong></td><td>0.2949</td><td><strong>0.7233</strong></td></tr><tr class="odd"><td>MNIST0127</td><td>0.2767</td><td>0.0156</td><td>0.3981</td></tr><tr class="even"><td>Isolet</td><td>0.7067</td><td>0.6151</td><td>0.8459</td></tr><tr class="odd"><td>Yale</td><td>0.5636</td><td>0.3215</td><td>0.7704</td></tr></tbody></table><h2 id="trace-lasso">Trace Lasso</h2><p>Trace Lasso<sup id="fnref:13" class="footnote-ref"><a href="#fn:13" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Grave E, Obozinski G R, Bach F. Trace lasso: a trace norm regularization for correlated designs[J]. Advances in Neural Information Processing Systems, 2011, 24.](https://proceedings.neurips.cc/paper/2011/hash/33ceb07bf4eeb3da587e268d663aba1a-Abstract.html)">[13]</span></a></sup>是一种介于L1和L2正则的正则化项。其形式为 <span class="math display">\[\Omega(W)=||XDiag(W)||_*\]</span> 其中<span class="math inline">\(X\)</span>为已归一化的特征矩阵，即对于特征<span class="math inline">\(\vec x_i\)</span>有<span class="math inline">\(\vec x_i \vec x_i^T=1\)</span>。<span class="math inline">\(W\)</span>为待求参数。<span class="math inline">\(||·||_*\)</span>为核范数<sup id="fnref:14" class="footnote-ref"><a href="#fn:14" rel="footnote"><span class="hint--top hint--rounded" aria-label="[https://en.wikipedia.org/wiki/Matrix_norm](https://en.wikipedia.org/wiki/Matrix_norm)">[14]</span></a></sup>（或迹范数）,<span class="math inline">\(||Z||_*=tr(\sqrt{Z^TZ})\)</span>，表示所有奇异值之和。</p><p>Trace Lasso具有如下性质：</p><ul><li><p>当<span class="math inline">\(X^TX=I\)</span>时，即特征之间的相关性为0，或者正交，那么 <span class="math display">\[\Omega(W)=||W||_1\]</span> 即退化为1范式。</p></li><li><p>当<span class="math inline">\(X^TX=\vec 1^T\vec 1\)</span>时，即所有特征都完全相关，那么 <span class="math display">\[\Omega(W)=||W||_2\]</span> 即退化为2范式</p></li><li><p>其他情况下，在1范式和2范式之间。</p></li></ul><p>Trace Lasso的优点就是它可以根据数据的特征，接近合适的范式，这相比弹性网络更好。</p><h2 id="cast">CAST</h2><p>ROSC方法虽然可以加强类内数据的联系，但没有使得类间的间距增大。</p><p>而CAST相比于ROSC的区别就在于修改了优化函数<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Li X, Kao B, Shan C, et al. CAST: a correlation-based adaptive spectral clustering algorithm on multi-scale data[C]//Proceedings of the 26th ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining. 2020: 439-449.](https://dl.acm.org/doi/abs/10.1145/3394486.3403086)">[2]</span></a></sup>，成为如下形式： <span class="math display">\[\min_{Z} \frac{1}{2} ||\vec x-X\vec z||_2+\alpha_1||XDiag(\vec z)||_*+\frac{\alpha_2}{2}||W-\vec z||_2\]</span> 其中<span class="math inline">\(\vec x\)</span>是<span class="math inline">\(X\)</span>的其中一个特征向量，<span class="math inline">\(z\)</span>是修正相似度矩阵<span class="math inline">\(Z\)</span>中的一个向量。于ROSC的主要区别在于范数的选择，通过trace lasso可以使得其具有类内聚合也有类外稀疏的特性。</p><p>该优化问题的求解已经超出了我的能力范围，在此直接贴出论文中的算法流程</p><p><img src="https://imagehost.vitaminz-image.top/li-spectral-cluster-15.png" style="zoom: 50%;"></p><p>整个CAST算法的流程如下：</p><p><img src="https://imagehost.vitaminz-image.top/li-spectral-cluster-16.png" style="zoom:50%;"></p><p>对比ROSC，他们的区别就在于求解<span class="math inline">\(Z^*\)</span>的方法不同，其余都是一样的。</p><p>由于Inexcat ALM的算法超出了我的知识范畴，并且最近事情较多，CAST算法的代码并没有复现。若后面有时间再填补空缺。</p><h2 id="group-effect">Group Effect</h2><p>Group Effect在ROSC和CAST论文中都提及了，以及一篇关于GNN的论文<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[Li X, Zhu R, Cheng Y, et al. Finding Global Homophily in Graph Neural Networks When Meeting Heterophily[J]. arXiv preprint arXiv:2205.07308, 2022](https://arxiv.org/abs/2205.07308)">[7]</span></a></sup>中也提及了，可以说精髓所在了。</p><p>首先定义一些符号：若有一系列的实体<span class="math inline">\(X=\{x_1,x_2,...,x_n\}\)</span>，设<span class="math inline">\(w_q\)</span>为<span class="math inline">\(W\)</span>的第<span class="math inline">\(q\)</span>列，设<span class="math inline">\(x_i\rightarrow x_j\)</span>表示，<span class="math inline">\(x_i^Tx_j\rightarrow 1\)</span>且<span class="math inline">\(||w_i-w_j||_2\rightarrow 0\)</span>。</p><p>如果矩阵<span class="math inline">\(Z\)</span>满足当<span class="math inline">\(x_i\rightarrow x_j\)</span>时，有<span class="math inline">\(|Z_{ip}-Z_{jp}|\rightarrow 0\)</span>，则称<span class="math inline">\(Z\)</span>具有Group Effect。</p><p>翻译成人话就是当2个实体足够接近，<span class="math inline">\(Z\)</span>矩阵中实体对应的元素也足够的接近。这说明了<span class="math inline">\(Z\)</span>矩阵确实能够反映实体之间的联系紧密程度。2个实体足够接近，它可以指实体的特征足够接近，也可以指实体附近的结构接近。事实上在另一篇关于GNN的论文<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[Li X, Zhu R, Cheng Y, et al. Finding Global Homophily in Graph Neural Networks When Meeting Heterophily[J]. arXiv preprint arXiv:2205.07308, 2022](https://arxiv.org/abs/2205.07308)">[7]</span></a></sup>里还包括了实体附近的结构信息。</p><p>可以证明的是，ROSC和CAST中的稀疏矩阵都有Group Effect，证明的过程过于复杂，也超出了我的能力范围了😂。</p><h2 id="补充">补充</h2><h3 id="dominant-eigenvalue">Dominant Eigenvalue</h3><p>若一个方阵<span class="math inline">\(A\)</span>存在一系列特征值<span class="math inline">\(\lambda_1,\lambda_2,...,\lambda_n\)</span>，且满足<span class="math inline">\(|\lambda_1|&gt;|\lambda_2|\ge...\ge|\lambda_n|\)</span>，则称<span class="math inline">\(\lambda_1\)</span>为该方阵的主特征值<sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><span class="hint--top hint--rounded" aria-label="[https://www.cs.huji.ac.il/w~csip/tirgul2.pdf](https://www.cs.huji.ac.il/w~csip/tirgul2.pdf)">[10]</span></a></sup>。前文中的幂迭代法原本就是用来求主特征值的。 <span class="math display">\[\begin{align*} A^kq^{(0)} &amp;= A^{k-1}q^{(1)} = ... =Aq^{(k−1)} \\&amp;=a_1A^k\vec  e_1 + a_2A^k\vec e_2,..., +a_nA^k\vec e_n\\&amp;=a_1\lambda_1^k  e_1 + a_2\lambda_2^k\vec e_2,..., +a_n\lambda_n^k\vec e_n\\&amp;=a_1\lambda_1^k\bigg[e_1+\sum_{i=2}^{n}\frac{a_i}{a_1}\bigg(\frac{\lambda_i}{\lambda_1}\bigg)^k\vec e_i)\bigg]\end{align*}\]</span> 经过一系列迭代后又如上式子。显然，当<span class="math inline">\(k\rightarrow\infty\)</span>时，<span class="math inline">\(q^{(k)}=Aq^{(k−1)}=A^kq^{(0)}\rightarrow a_1\lambda^kx_1\)</span>。并且<span class="math inline">\([q^{k}]^TAq^{(k)}\approx [q^{(k)}]^T\lambda q^{(k)}=\lambda\|q^{(k)}\|_2=\lambda\)</span>，当<span class="math inline">\(\|q^{(k)}\|_2=1\)</span>。所以每次迭代需要对<span class="math inline">\(q\)</span>进行一次标准化。这样通过经过式子就可求出主特征值了。</p><h3 id="derivatives-of-matrix">Derivatives of Matrix</h3><p>矩阵求导是矩阵论中的相关知识<sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Petersen K B, Pedersen M S. The matrix cookbook[J]. Technical University of Denmark, 2008, 7(15): 510.](https://ece.uwaterloo.ca/~ece602/MISC/matrixcookbook.pdf)">[11]</span></a></sup>，这里仅对前文用到的Frobenius范式矩阵的求导过程进行介绍。</p><p>Frobenius范式可以表示成如下的迹形式 <span class="math display">\[||X||_F=\sqrt{tr(X^TX)}\]</span> 首先引入2个求导法则</p><ul><li><p>法则1：若<span class="math inline">\(A,X\)</span>为<span class="math inline">\(m\times n\)</span>的矩阵，有 <span class="math display">\[\frac{\partial tr(A^TX)}{\partial X}=\frac{\partial tr(X^TA)}{\partial X}=A\]</span></p></li><li><p>法则2：若<span class="math inline">\(A\)</span>为<span class="math inline">\(m\times m\)</span>的矩阵，<span class="math inline">\(X\)</span>为<span class="math inline">\(m\times n\)</span>的矩阵，有</p></li></ul><p><span class="math display">\[\frac{\partial tr(X^TAX)}{\partial X}=AX+A^TX\]</span></p><p>因此若求以下导数 <span class="math display">\[\frac{\partial ||A-BX||^2_F}{\partial X}\]</span> 利用以上法则有： <span class="math display">\[\begin{align*}\frac{\partial||A-BX||^2_F}{\partial X}&amp;=\frac{\partial tr[(A-BX)^T(A-BX)]}{\partial X}\\&amp;=\frac{\partial tr[(A^T-X^TB^T)(A-BX)]}{\partial X}\\&amp;=\frac{\partial[tr(A^TA)-2tr(A^TBX)+tr(X^TB^TBX)]}{\partial X}\\&amp;=0-2A^TB+B^TBX+B^TBX\\&amp;=-2B^T(A+BX)\end{align*}\]</span></p><h2 id="问题与总结">问题与总结</h2><p>在这次深入解读论文的过程中，有很多收获，学到了很多，但也发觉不明白的东西也很多。实验中也遇到各种问题，比如在PI方法的实验中，发现对<span class="math inline">\(W^T=D^{-1}S\)</span>的最小特征向量在3圆圈数据集中，具有明显的分层，其分层特征和类别基本一致，这是一次代码写错时发现的。以及论文中出现了非常多优化问题求解，也触及到了很多知识盲区。但同时也激发了我的求知欲望，需要学的东西还有很多。</p><h2 id="参考资料">参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://dl.acm.org/doi/abs/10.1145/3178876.3185993">Li X, Kao B, Luo S, et al. Rosc: Robust spectral clustering on multi-scale data[C]//Proceedings of the 2018 World Wide Web Conference. 2018: 157-166.</a> <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://dl.acm.org/doi/abs/10.1145/3394486.3403086">Li X, Kao B, Shan C, et al. CAST: a correlation-based adaptive spectral clustering algorithm on multi-scale data[C]//Proceedings of the 26th ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining. 2020: 439-449.</a> <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://proceedings.neurips.cc/paper/2004/hash/40173ea48d9567f1f393b20c855bb40b-Abstract.html">Zelnik-Manor L, Perona P. Self-tuning spectral clustering[J]. Advances in neural information processing systems, 2004, 17.</a> <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://csustan.csustan.edu/~tom/Clustering/GraphLaplacian-tutorial.pdf">https://csustan.csustan.edu/~tom/Clustering/GraphLaplacian-tutorial.pdf</a> <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://openreview.net/forum?id=SyWcksbu-H">Lin F, Cohen W W. Power iteration clustering[C]//ICML. 2010.</a> <a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://proceedings.neurips.cc/paper/2001/hash/801272ee79cfde7fa5960571fee36b9b-Abstract.html">Ng A, Jordan M, Weiss Y. On spectral clustering: Analysis and an algorithm[J]. Advances in neural information processing systems, 2001, 14.</a> <a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>[<a href="https://arxiv.org/abs/2205.07308">Li X, Zhu R, Cheng Y, et al. Finding Global Homophily in Graph Neural Networks When Meeting Heterophily[J]. arXiv preprint arXiv:2205.07308, 2022</a> <a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:8" class="footnote-text"><span><a href="https://ieeexplore.ieee.org/abstract/document/868688">Shi J, Malik J. Normalized cuts and image segmentation[J]. IEEE Transactions on pattern analysis and machine intelligence, 2000, 22(8): 888-905.</a> <a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:9" class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/Whitening_transformation">https://en.wikipedia.org/wiki/Whitening_transformation</a> <a href="#fnref:9" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:10" class="footnote-text"><span><a href="https://www.cs.huji.ac.il/w~csip/tirgul2.pdf">https://www.cs.huji.ac.il/w~csip/tirgul2.pdf</a> <a href="#fnref:10" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:11" class="footnote-text"><span><a href="https://ece.uwaterloo.ca/~ece602/MISC/matrixcookbook.pdf">Petersen K B, Pedersen M S. The matrix cookbook[J]. Technical University of Denmark, 2008, 7(15): 510.</a> <a href="#fnref:11" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:12" class="footnote-text"><span><a href="https://mathworld.wolfram.com/FrobeniusNorm.html">https://mathworld.wolfram.com/FrobeniusNorm.html</a> <a href="#fnref:12" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:13" class="footnote-text"><span><a href="https://proceedings.neurips.cc/paper/2011/hash/33ceb07bf4eeb3da587e268d663aba1a-Abstract.html">Grave E, Obozinski G R, Bach F. Trace lasso: a trace norm regularization for correlated designs[J]. Advances in Neural Information Processing Systems, 2011, 24.</a> <a href="#fnref:13" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:14" class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/Matrix_norm">https://en.wikipedia.org/wiki/Matrix_norm</a> <a href="#fnref:14" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>谱图理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>频域</tag>
      
      <tag>python</tag>
      
      <tag>聚类</tag>
      
      <tag>谱聚类</tag>
      
      <tag>多尺度数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图（Graph）数据的频域</title>
    <link href="/2022/08/20/gnn/tu-graph-shu-ju-de-pin-yu/"/>
    <url>/2022/08/20/gnn/tu-graph-shu-ju-de-pin-yu/</url>
    
    <content type="html"><![CDATA[<h1 id="图graph数据的频域">图（Graph）数据的频域</h1><p>图神经网络（GNN）是近年来愈发火热，用以对图（Graph）数据进行特征提取以及各种下游任务。注意这里的图（Graph）应和图像（Image）区分，图是一种由点集与边集组成的数据结构，常记作<span class="math inline">\(\mathcal{G}=(\mathcal{V,E})\)</span>。以下是我学习谱图理论时的一些记录。本文先先从基变换的角度入手，说明了标准正交基的性质，并从实数域拓展到了复数域，接着从基变换的角度阐述了傅里叶变换的原理，然后从特征值与特征向量入手，通过分析拉普拉斯算子的特征向量，理解其与傅里叶变换的等价性。最后使用图的数据结构表示图像，可视化其特征向量，直观感受低频到高频分量的差异。本人才疏学浅，错误难免，欢迎交流指正。</p><h2 id="内积与基">内积与基</h2><p>我们首先回顾一下线性代数的知识。本科第一次线性代数的时候，都是以繁杂的计算与证明为主，未曾有更直观、直觉的方式去理解。这里我想从线性变换的角度，讲述线性代数中与本文内容相关的知识。</p><p>我们定义实数向量<span class="math inline">\(\vec x=[x_1, x_2,...,x_n]^T\)</span>与实数向量的<span class="math inline">\(\vec x=[x_1, x_2,...,x_n]^T\)</span>内积为<span class="math inline">\(&lt;\vec x,\vec y&gt;=\sum x_iy_i\)</span>。这是高中就学过的知识。但这里，我需要对向量的内积做一些扩充，即复数向量内积的定义。根据hermitian内积的定义<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://mathworld.wolfram.com/HermitianInnerProduct.html">[1]</span></a></sup>，复平面内积定义为<span class="math inline">\(&lt;\vec x,\vec y&gt;=\sum x_i\bar y_i\)</span>。</p><p>如果我们将向量内积扩展到函数空间，我们可以将函数视为无限长的向量，如<span class="math inline">\(f(x)=[f(x_1),f(x_2),...]\)</span>，可以定义函数的内积<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://mathworld.wolfram.com/HilbertSpace.html">[2]</span></a></sup><span class="math inline">\(&lt;f,g&gt;=\int_a^b f(x)g(x)dx\)</span>。若函数在复平面上，则可定义为<span class="math inline">\(&lt;f,g&gt;=\int_a^b f(x)\overline{g(x)}dx\)</span>（有时共轭会放在左边）。</p><p>然后我们来回顾一下向量空间中的基。由一组线性无关的向量可以张成一个向量空间，空间中的任意向量都可以使用这一组向量的线性组合表示。这组向量称作基向量。如果基向量构成的矩阵<span class="math inline">\(A=[\vec\alpha_1,\vec\alpha_2,...,\vec\alpha_n]^T\)</span>满足<span class="math inline">\(AA^T=E\)</span>，则这组基向量称为正交基，若还满足<span class="math inline">\(||\vec\alpha_i||=1,(i=1,2,...,n)\)</span>，则称为标准正交基。如，二维向量<span class="math inline">\([1,0]^T,[0,1]^T\)</span>构成一组标准正交基。在复平面中<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://math.mit.edu/~gs/linearalgebra/">[6]</span></a></sup>，转置被描述为<span class="math inline">\((A^H)_{ij}=\overline{A_{ji}}\)</span>，相比实数域，处了转置还要做一次共轭，称为共轭转置。那么正交基构成的矩阵<span class="math inline">\(A\)</span>应满足<span class="math inline">\(AA^H=E\)</span>。</p><p>假如有标准正交基<span class="math inline">\(\vec e_1, \vec e_2,...,\vec e_n\)</span>，若该空间中向量 <span class="math display">\[\vec v=w_1\vec e_1+w_2\vec e_2+,...+w_n\vec e_n=[\vec e_1,\vec e_2,..., \vec e_n][w_1,w_2,...,w_m]^T\]</span> 则 <span class="math display">\[[w_1,w_2,...,w_m]^T=[\vec e_1,\vec e_2,... ,\vec e_n]^{-1}\vec v=[\vec e_1,\vec e_2,... ,\vec e_n]^{T}\vec v\]</span> 可以看到，若想获得一组某向量在一组标准正交基上的表示，只需要让该向量与这组正交基做内积即可。</p><p>函数也存在着基的概念，若函数<span class="math inline">\(f(x)=a_ng(x)+b_nh(x)\)</span>。那么<span class="math inline">\(g(x)\)</span>和<span class="math inline">\(h(x)\)</span>就是<span class="math inline">\(f(x)\)</span>的基。若内积<span class="math inline">\(&lt;g,h&gt;=0\)</span>，<span class="math inline">\(g\)</span>和<span class="math inline">\(h\)</span>是一组正交基。</p><h2 id="傅里叶变换">傅里叶变换</h2><p><img src="https://imagehost.vitaminz-image.top/gnn-note-5.png"></p><p>在学习傅里叶变换时，想必类似上面的图大家已经见过很多次了，这里我们暂且不从几何的角度去解释，从基的角度去阐述。大多数教材都会先从傅里叶级数入手，周期函数可以表示为许多正弦信号的叠加，有如下形式 <span class="math display">\[f(t)=\frac{a_0}{2}+\sum_{n=1}^{+\infty} [a_n\sin(\frac{n\pi}{l} t )+b_n\cos({\frac{n\pi}{l} t})]\]</span> 其中，<span class="math inline">\(n\)</span>是整数，<span class="math inline">\(l\)</span>为半周期。<span class="math inline">\(1,\sin(n\omega t ),\cos({n\omega t})\)</span>可以看作是<span class="math inline">\(f(t)\)</span>许许多多相互正交的基。这是因为<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="《高等数学》同济第七版下册">[3]</span></a></sup>：<span class="math inline">\(\int^{\pi}_{-\pi}\cos nxdx=0\)</span>,<span class="math inline">\(\int^{\pi}_{-\pi}\sin nxdx=0\)</span>, <span class="math inline">\(\int^{\pi}_{-\pi}\cos n_1x\sin n_2xdx=0\)</span>, <span class="math inline">\(\int^{\pi}_{-\pi}\cos n_1x\cos n_2xdx=0\)</span>,<span class="math inline">\(\int^{\pi}_{-\pi}\sin n_1x\sin n_2xdx=0\)</span>。</p><p>如果使用Euler公式替换， 可以转换为如下形式 <span class="math display">\[f(t)=\sum^{+\infty}_{n=-\infty}c_ne^{i\omega t}\]</span> 其中，<span class="math inline">\(c_n=\frac{1}{l}\int_{-l}^{l}f(t)e^{-i\omega t}dt\)</span>。<span class="math inline">\(l\)</span>为半周期，<span class="math inline">\(\omega=\frac{n\pi}{l}\)</span>，即频率（有些地方会将<span class="math inline">\(\omega\)</span>视作角速度，指数项写作<span class="math inline">\(e^{2i\pi\omega t}\)</span>）。这里<span class="math inline">\(e^{i\omega t}\)</span>也是许多的标准正交基，这是因为<span class="math inline">\(\int e^{i\omega_1 t}e^{-i\omega_2 t}=0\)</span>，<span class="math inline">\(||e^{i\omega}||=1\)</span>。那么当<span class="math inline">\(l\rightarrow +\infty\)</span>时，<span class="math inline">\(c_n\)</span>就是傅里叶变换的形式了。即 <span class="math display">\[\mathcal{F}[f(t)]=\hat f(\omega)=\int_{-\infty}^{+\infty}f(t)e^{-i\omega t}dt\]</span> 所以像函数<span class="math inline">\(\hat f(\omega)\)</span>其实就是<span class="math inline">\(\omega\)</span>对应的傅里叶基<span class="math inline">\(e^{i\omega t}\)</span>的系数。上述式子也可以看作是<span class="math inline">\(f(t)\)</span>与正交基<span class="math inline">\(e^{i\omega t}\)</span>的内积，在上一节中提到了，若某个向量希望使用某组正交基来表示，拿就让这个向量和这组标准正交基做内积，标准正交基就像一个筛子，把基方向的分量提取出来了。</p><p>在计算机中，使用离散傅里叶变换（DFT）的算法计算：被描述为<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://en.wikipedia.org/wiki/Discrete_Fourier_transform">[8]</span></a></sup> <span class="math display">\[X_k=\sum_{n=0}^{N-1}x_n \cdot e^{-\frac{i2\pi}{N}kn}\]</span> 实际计算时如快速傅里叶变换（FFT），使用如下DFT矩阵<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://en.wikipedia.org/wiki/DFT_matrix">[9]</span></a></sup>与向量<span class="math inline">\(\vec x=[x_1,x_2,...,x_n]^T\)</span>相乘。 <span class="math display">\[W = \frac{1}{\sqrt{N}} \begin{bmatrix}1&amp;1&amp;1&amp;1&amp;\cdots &amp;1 \\1&amp;\omega&amp;\omega^2&amp;\omega^3&amp;\cdots&amp;\omega^{N-1} \\1&amp;\omega^2&amp;\omega^4&amp;\omega^6&amp;\cdots&amp;\omega^{2(N-1)}\\ 1&amp;\omega^3&amp;\omega^6&amp;\omega^9&amp;\cdots&amp;\omega^{3(N-1)}\\\vdots&amp;\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;\omega^{N-1}&amp;\omega^{2(N-1)}&amp;\omega^{3(N-1)}&amp;\cdots&amp;\omega^{(N-1)(N-1)}\end{bmatrix}\]</span> 其中<span class="math inline">\(\omega = e^{-2\pi i/N}\)</span>。易证明<span class="math inline">\(WW^H=E\)</span>，即它由一组标准正交基构成。具体的计算方法使用快速傅里叶变换，可以将复杂度降至<span class="math inline">\(O(n\log n)\)</span>，具体过程可以参考<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.bilibili.com/video/BV1za411F76U?spm_id_from=333.337.search-card.all.click&amp;vd_source=3eafcac5a31e0009a6433cea9bc7ab45">[4]</span></a></sup>。</p><h2 id="特征值与特征向量">特征值与特征向量</h2><p>简单地回顾一些特征值与特征向量的定义，设有矩阵<span class="math inline">\(A\)</span>，若存在<span class="math inline">\(\lambda,\vec x\)</span>，使得<span class="math inline">\(A\vec x=\lambda \vec x\)</span>，则<span class="math inline">\(\lambda\)</span>称为<span class="math inline">\(A\)</span>的特征值，<span class="math inline">\(\vec x\)</span>则称为特征向量，<span class="math inline">\(\lambda\)</span>的值可以不止一个，同一个<span class="math inline">\(\lambda\)</span>可以对应多个线性无关的<span class="math inline">\(\vec x\)</span>。如果想了解特征值与特征向量的几何解释，可以参考<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.bilibili.com/video/BV1ys411472E?p=14&amp;vd_source=3eafcac5a31e0009a6433cea9bc7ab45">[5]</span></a></sup>，这不是本文的重点。</p><p>接下啦我想说明的是一种特殊的矩阵：实对称矩阵，即由实数组成的对称矩阵（若<span class="math inline">\(A=A^T\)</span>则称<span class="math inline">\(A\)</span>为对称矩阵）。该矩阵有很多优良的性质。首先，<span class="math inline">\(N\)</span>阶是对称矩阵，具有<span class="math inline">\(N\)</span>个特征值以及<span class="math inline">\(N\)</span>个正交的特征向量。且实对称矩阵一定可以相似对角化，即<span class="math inline">\(Q^{-1}AQ=Q^TAQ=\Lambda\)</span>。对角矩阵<span class="math inline">\(\Lambda\)</span>对角线上为特征值<span class="math inline">\(\lambda_1,\lambda_2,...\)</span>，分别对应<span class="math inline">\(Q=[\vec q_1, \vec q_2,...]\)</span>中的特征向量<span class="math inline">\(\vec q_1,\vec q_2,...\)</span>。</p><p>由于其<span class="math inline">\(Q\)</span>由一组线性无关的正交特征向量组成，他们可以构成一组正交基，特征向量组成的基也成为特征基。我们举个相似对角化的简单应用。假如要求实对称矩阵<span class="math inline">\(A\)</span>的幂次预算，如<span class="math inline">\(A^{100}\)</span>。直接计算是很麻烦的，若首先将其转化为对角矩阵<span class="math inline">\(Q^{-1}AQ=\Lambda\)</span>，那么<span class="math inline">\(Q^{-1}AQ...Q^{-1}AQQ^{-1}AQ=Q^{-1}A^{100}Q=\Lambda^{100}\)</span>。则<span class="math inline">\(A^{100}=Q\Lambda^{100}Q^{-1}\)</span>。对角矩阵的100次幂是非常容易计算的，这就使得计算量大大减小。</p><p>特征值与特征向量在微分方程中也有着重要应用<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://math.mit.edu/~gs/linearalgebra/">[6]</span></a></sup>。如对一个一阶微分方程<span class="math inline">\(\frac{du}{dt}=\lambda u\)</span>。它的特解为<span class="math inline">\(e^{\lambda t}\)</span>，通解为<span class="math inline">\(u(t)=Ce^t\)</span>。假如<span class="math inline">\(A\)</span>是一个常数矩阵，<span class="math inline">\(\vec u=[u_1,u_2,...,u_n]\)</span>。<span class="math inline">\(\frac{d\vec u}{dt}=A \vec u\)</span>，那么这就是在求解一个微分线性方程组。我们可以验证的是（将以下2式子带入原方程就可以证得），当<span class="math inline">\(A\vec x= \lambda \vec x\)</span>时，<span class="math inline">\(\vec u\)</span>的一个特解为<span class="math inline">\(\vec u = e^{\lambda t}\vec x\)</span>，<span class="math inline">\(\vec x\)</span>是一个常数向量。那么解原方程组转化为求<span class="math inline">\(A\vec x= \lambda \vec x\)</span>的问题求出特征值与特征向量，最后的通解即为<span class="math inline">\(C_1e^{\lambda_1 t}\vec x_1+C_2e^{\lambda_2 t}\vec x_2,....\)</span>。</p><p>若我们将一阶微分记作<span class="math inline">\(\nabla\)</span>，则<span class="math inline">\(\frac{d\vec u}{dt} = \nabla \vec u\)</span>，带入一个特解可以得到<span class="math inline">\(\nabla \vec u=\nabla e^{\lambda t}\vec x = \lambda e^{\lambda t}\vec x\)</span>。我们可以将<span class="math inline">\(\lambda\)</span>视为<span class="math inline">\(\Delta\)</span>的特征值，<span class="math inline">\(e^{\lambda t}\)</span>为特征向量。假如是二阶微分方程<span class="math inline">\(\frac{d^2\vec u}{dt^2}=A \vec u\)</span>，会有所不同，若满足<span class="math inline">\(A\vec x= \lambda \vec x\)</span>，其特解为<span class="math inline">\(\lambda e^{i\omega t} \vec x\)</span>，其中<span class="math inline">\(\omega^2=-\lambda\)</span>。同上，若我们将二阶微分算子记为<span class="math inline">\(\Delta\)</span>，则有<span class="math inline">\(\Delta \vec u =\Delta e^{i\omega t}\vec x= \lambda e^{i\omega t}\vec x\)</span>。那么<span class="math inline">\(e^{i\omega t}\vec x\)</span>就是<span class="math inline">\(\Delta\)</span>的特征向量。</p><h2 id="拉普拉斯矩阵">拉普拉斯矩阵</h2><p><img src="https://imagehost.vitaminz-image.top/gnn-note-7.png"></p><p>对于如上的图数据，它的拉普拉斯矩阵如下。其计算方法是<span class="math inline">\(D-A\)</span>。<span class="math inline">\(D\)</span>是每个结点的度组成的对角矩阵，<span class="math inline">\(A\)</span>是图的邻接矩阵。 <span class="math display">\[L=\left(\begin{array}{rrrrrr}   2 &amp; -1 &amp;  0 &amp;  0 &amp; -1 &amp;  0\\  -1 &amp;  3 &amp; -1 &amp;  0 &amp; -1 &amp;  0\\   0 &amp; -1 &amp;  2 &amp; -1 &amp;  0 &amp;  0\\   0 &amp;  0 &amp; -1 &amp;  3 &amp; -1 &amp; -1\\  -1 &amp; -1 &amp;  0 &amp; -1 &amp;  3 &amp;  0\\   0 &amp;  0 &amp;  0 &amp; -1 &amp;  0 &amp;  1\\\end{array}\right)\]</span> 拉普拉斯矩阵是拉普拉斯算子在图数据中的表示方式<sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://csustan.csustan.edu/~tom/Clustering/GraphLaplacian-tutorial.pdf">[10]</span></a></sup>，也被称为离散拉普拉斯算子。拉普拉斯算子是一个二阶微分算子，记作<span class="math inline">\(\Delta f = \sum_{i=1}^n \frac {\partial^2 f}{\partial x^2_i}\)</span>，在上一节的结尾，我们其实提到了这个算子。它的特征向量其实就是傅里叶变换中的正交基。实际上，实际上函数的傅里叶变换是定义在所有欧几里得空间上的函数的分解到其在拉普拉斯算子连续谱中的分量<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://en.wikipedia.org/wiki/Hilbert_space#Fourier_analysis">[7]</span></a></sup>。</p><p>拉普拉斯矩阵是一个实对称矩阵，上一节中提到实对称矩阵的一些优良性质，存在标准正交基构成的矩阵<span class="math inline">\(U\)</span>及其对应的特征值对角矩阵<span class="math inline">\(\Lambda\)</span>使得拉普拉斯矩阵<span class="math inline">\(L\)</span>满足<span class="math inline">\(U^TLU=\Lambda\)</span>。其中<span class="math inline">\(U=[\vec u_1, \vec u_2,..., \vec u_n]\)</span>中的<span class="math inline">\(\vec u_i\)</span>可以视为离散的傅里叶基，而所对应的特征值则为频率。如果每个结点的特征（简单起见，每个结点只有一维特征）组成的向量<span class="math inline">\(\vec x=[x_1,x_2,...,x_n]\)</span>，那么如果我们将其转化为频域向量<span class="math inline">\(\vec y=U^T\vec x\)</span>，正如我们在第一节、第二节提到的方式一样。然后就可以在频域中操作，再转换为时域即可。</p><h2 id="图的频域分量">图的频域分量</h2><p>在讲图（Graph）之前，我们可以先聊聊图像（Image）。图像通常由一个矩阵表示，矩阵中的每一个值为像素点的值。根据通道数，图像又可以分为彩色图像和灰度图像。</p><p>事实上图像它也可表示称图的结构。如下图所示<sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://distill.pub/2021/gnn-intro/">[11]</span></a></sup>：</p><p><img src="https://imagehost.vitaminz-image.top/gnn-note-8.png"></p><p>其中，每个像素与上下左右对角线相邻接。</p><p>为了方便可视化图数据的频域分量，我们使用上述图数据的结构，即讲图像转化为图。具体执行如下操作<sup id="fnref:12" class="footnote-ref"><a href="#fn:12" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://distill.pub/2021/understanding-gnns/#learning">[12]</span></a></sup>：</p><ul><li>step1. 选择(10, 10)尺寸的图像结构，</li><li>step2. 根据每个像素与上下左右对角线相邻接的规则构造邻接矩阵A, shape: (100, 10)</li><li>step3. 根据邻接矩阵A构造拉普拉斯矩阵L, shape: (100, 100)</li><li>step4. 对拉普拉斯矩阵进行对角化, 求得特征基矩阵U, shape(100, 100)，对角矩阵P, shape(100, 100)，注意上述2个矩阵均按特征值的大小升序排序。</li><li>step5. 取特征值大小前10的特征基，每个特征基重构为图像结构Image, shape(10, 10)，进行可视化</li></ul><p>经过以上的操作后，最后的结果如下图所示，特征值按从小到大排序。这就是每个频率所对应的分量。可以看到图像一开始是纯色的，后来开始出现了类似波形的渐变过程，随着频率的增加，其波形也越复杂。</p><p><img src="https://imagehost.vitaminz-image.top/gnn-note-9.png"></p><p>以下为实现代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getLaplacianOfImage</span>(<span class="hljs-params">M, N</span>):<br>    idx = np.array([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(M * N)]).reshape((M, N))<br>    tmp = np.ones((M+<span class="hljs-number">2</span>, N+<span class="hljs-number">2</span>), dtype=np.int32) * M * N<br>    tmp[<span class="hljs-number">1</span>:M+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>:N+<span class="hljs-number">1</span>] = idx<br>    <span class="hljs-comment"># print(tmp)</span><br>    directH = [<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]<br>    directV = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>    A = np.zeros((M * N + <span class="hljs-number">1</span>, M * N + <span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, M+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, N+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> h, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(directH, directV):<br>                A[tmp[i, j], tmp[i+h, j+v]] = <span class="hljs-number">1</span><br>    A = A[<span class="hljs-number">0</span>:M*N, <span class="hljs-number">0</span>:M*N]<br>    L = np.diag(np.<span class="hljs-built_in">sum</span>(A, axis=<span class="hljs-number">1</span>)) - A<br>    <span class="hljs-keyword">return</span> L<br><br>M, N = <span class="hljs-number">10</span>, <span class="hljs-number">10</span><br>L = getLaplacianOfImage(M, N)<br><span class="hljs-comment"># print(L)</span><br><span class="hljs-comment"># print(np.prod(L == L.T))</span><br><span class="hljs-comment"># plt.imshow(L)</span><br>eigenvalue, featurevector = np.linalg.eigh(L)<br>eigenbase = featurevector.T<br><br>min_val, max_val = np.<span class="hljs-built_in">min</span>(eigenbase), np.<span class="hljs-built_in">max</span>(eigenbase)<br>plt.figure(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">15</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>    fv = eigenbase[i].reshape((M, N))<br>    plt.subplot(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, i+<span class="hljs-number">1</span>)<br>    plt.imshow(fv, vmin=min_val, vmax=max_val)<br>    plt.colorbar(fraction=<span class="hljs-number">0.045</span>)<br></code></pre></td></tr></tbody></table></figure><h2 id="总结">总结</h2><p>写该博客的起因是学习GNN时，不理解为什么使用<span class="math inline">\(L\)</span>矩阵，而不是用邻接矩阵或者其他实对称矩阵，以及在文献中<sup id="fnref:13" class="footnote-ref"><a href="#fn:13" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Li X, Zhu R, Cheng Y, et al. Finding Global Homophily in Graph Neural Networks When Meeting Heterophily[J]. arXiv preprint arXiv:2205.07308, 2022.](https://arxiv.org/abs/2205.07308)">[13]</span></a></sup>看到<span class="math inline">\(L\)</span>矩阵的谱分解其实就是傅里叶变换在图领域的应用。为了深入了解这二者的关系，捡起了以前学过但又未深入理解的知识。完成这篇博客，还是很有收获的。</p><p><span id="ckwx"> </span></p><h2 id="参考资料">参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://mathworld.wolfram.com/HermitianInnerProduct.html <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>https://mathworld.wolfram.com/HilbertSpace.html <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>《高等数学》同济第七版下册 <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>https://www.bilibili.com/video/BV1za411F76U?spm_id_from=333.337.search-card.all.click&amp;vd_source=3eafcac5a31e0009a6433cea9bc7ab45 <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>https://www.bilibili.com/video/BV1ys411472E?p=14&amp;vd_source=3eafcac5a31e0009a6433cea9bc7ab45 <a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>https://math.mit.edu/~gs/linearalgebra/ <a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>https://en.wikipedia.org/wiki/Hilbert_space#Fourier_analysis <a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>https://en.wikipedia.org/wiki/Discrete_Fourier_transform <a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:9" class="footnote-text"><span>https://en.wikipedia.org/wiki/DFT_matrix <a href="#fnref:9" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:10" class="footnote-text"><span>https://csustan.csustan.edu/~tom/Clustering/GraphLaplacian-tutorial.pdf <a href="#fnref:10" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:11" class="footnote-text"><span>https://distill.pub/2021/gnn-intro/ <a href="#fnref:11" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:12" class="footnote-text"><span>https://distill.pub/2021/understanding-gnns/#learning <a href="#fnref:12" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:13" class="footnote-text"><span><a href="https://arxiv.org/abs/2205.07308">Li X, Zhu R, Cheng Y, et al. Finding Global Homophily in Graph Neural Networks When Meeting Heterophily[J]. arXiv preprint arXiv:2205.07308, 2022.</a> <a href="#fnref:13" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>谱图理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>频域</tag>
      
      <tag>谱图理论</tag>
      
      <tag>傅里叶变换</tag>
      
      <tag>线性代数</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构知识点整理</title>
    <link href="/2022/07/20/dsandalg/shu-ju-jie-gou-zhi-shi-dian-zheng-li/"/>
    <url>/2022/07/20/dsandalg/shu-ju-jie-gou-zhi-shi-dian-zheng-li/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构">数据结构</h1><h2 id="树">树</h2><h3 id="概念">概念</h3><p>结点的深度（自顶向下）、结点的高度（自底向上）、树的高度（最大层树）、结点的度、树的度（最大）、有序树和无序树、路径（树的路径长度=所有结点路径长度总和）、分支结点（度不为0）、叶子结点</p><h3 id="儿子-兄弟表示法">儿子-兄弟表示法</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>{</span><br>Element<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">FirstChild</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">NextSibling</span>;</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>一般的树可以用儿子-兄弟法表示。森林也同样可以，原因是显然的，因为任何一颗树都可以看作是根节点下的几棵子树构成。</p><p>因此一般的树都可以用<strong>二叉树</strong>来存储实现。</p><p>此外还有<strong>双亲表示法</strong>【见并查集】。</p><p>以及<strong>孩子表示法</strong>。下图摘自王道考研ppt。</p><p><img src="http://imagehost.vitaminz-image.top/DS-6.png" style="zoom:33%;"></p><h3 id="二叉树">二叉树</h3><ul><li><p>定义：与度为2的有序树间的区别，度为2的有序树至少有3个结点，二叉树可以为空。二叉树的有序性与另一个孩子无关，即若只有一个孩子，那他要么是左孩子，要么是有孩子；而度为2的有序树在该情况下则没有左右之分。</p></li><li><p>类型：斜二叉树（退化为链表）、完美二叉树（或满二叉树）、完全二叉树。</p></li></ul><p><img src="http://imagehost.vitaminz-image.top/DS-1.webp" style="zoom: 67%;"></p><ul><li><p>性质</p><ul><li><p>第<span class="math inline">\(i\)</span>层的最大结点数<span class="math inline">\(2^{i-1}\)</span>。</p></li><li><p>深度为<span class="math inline">\(k\)</span>的二叉树最大结点数<span class="math inline">\(2^{k}-1\)</span>。如满二叉树可以达到</p><ul><li>推广，对于<span class="math inline">\(m\)</span>叉树，其最大结点数为<span class="math inline">\((m^k-1)/(m-1)\)</span>，等比数列求和。</li></ul></li><li><p>最小高度为<span class="math inline">\(\lceil log_2(n+1)\rceil\)</span>，由以上的最大结点公式可以推得。</p><ul><li>推广，对于<span class="math inline">\(m\)</span>叉树，其最大结点数为<span class="math inline">\(\lceil log_m(n(m-1)+1)\rceil\)</span>。</li></ul></li><li><p><span class="math inline">\(n_0, n_2\)</span>分别表示叶结点个数与度为2的结点个数，则有<span class="math inline">\(n_0=1+n_2\)</span>。利用该公式可以计算完全二叉树的结点，因为对于完全二叉树来说，<span class="math inline">\(n_1\)</span>要么是1要么是0。同时还可以求空指针数，控制指针数为<span class="math inline">\(2n_0+n_1=n_0+n_1+n_2+1=n+1\)</span></p><ul><li><p>简单地证明一下：</p></li><li><p><span class="math display">\[n_0+n_1+n_2-1 = 0*n_0+1*n_1+2*n_2\]</span></p></li><li><p>如上，等式两边表示边的数量，左边表示边的个数等于所有结点的数减1，这是显然的，除了根结点，所有的结点都有且仅有一个入边。等式右边则通过出边来计算总的边数。</p></li><li><p>该性质的推广：在m叉树中，叶结点总数是<span class="math inline">\(n_0\)</span>，有一个儿子的结点总数是<span class="math inline">\(n_1\)</span>，有2个儿子的结点总数是<span class="math inline">\(n_2\)</span>，有3个儿子的结点总数是<span class="math inline">\(n_3\)</span>，...。那么，<span class="math inline">\(n_i\)</span>之间存在什么关系？</p></li><li><p><span class="math display">\[n_0=1+n_2+2n_3+...+(m-1)n_m\]</span></p></li></ul></li></ul></li></ul><h3 id="存储方式">存储方式</h3><h4 id="顺序">顺序</h4><p>对于<strong>完全二叉树</strong></p><p>对于非根结点，(<span class="math inline">\(i\)</span>从1开始)，父节点的编号为<span class="math inline">\(\lfloor i/2\rfloor\)</span>。左孩子为<span class="math inline">\(pos_{left}=2*i,(pos_{left}&lt;=n)\)</span>，右孩子为<span class="math inline">\(pos_{right}=2*i+1,(pos_{right}&lt;=n)\)</span>。</p><p>推广：对于完全m叉树，子女<span class="math inline">\(k(k=1,2,..,m)\)</span>的位置为<span class="math inline">\(pos_{k}=(i-1)*m+k+1,(pos_{k}&lt;=n)\)</span>。父节点的编号为<span class="math inline">\(\lfloor (i-2)/m\rfloor+1\)</span>。</p><p>对于<strong>一般二叉树</strong></p><p>将一般二叉树补成完全二叉树（浪费太多空间）。</p><h4 id="链式">链式</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>{</span><br>ElemType data<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">left</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">right</span>;</span><br>}*BinTree;<br><span class="hljs-comment">// 也可以用静态链表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>{</span><br>ElemType data<br><span class="hljs-type">int</span> left;<br><span class="hljs-type">int</span> right;<br>}tree[MAXSIZE];<br></code></pre></td></tr></tbody></table></figure><h3 id="遍历">遍历</h3><p>traversal</p><p>遍历的核心问题是二维结构线性化，如何保存暂时不访问的结点：堆栈（前后中序）、队列（层序遍历）</p><h4 id="前中后序">前中后序</h4><p>下图摘自浙大的数据结构慕课ppt。先序(pre-order)、中序(in-order)、后序(post-order)的区别在于，在行走路线的过程中，碰到第一次就打印的为前序，第二此猜打印的为中序，碰到第三次打印的为后序。也可以理解为，前序是打印时左右子树都没打印过，中序为打印时左子树打印过（或者不存在）而右子树没有打印过，后序为打印时左右子树都打印过了（或者都不存在）。</p><p><img src="http://imagehost.vitaminz-image.top/DS-2.png" style="zoom: 50%;"></p><p>以下为实现，分为递归实现与非递归实现。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 递归实现*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(BinTree T)</span>{<br>    <span class="hljs-keyword">if</span>(T){<br>        print(T-&gt;data);<br>        preorderTraversal(T-&gt;left);<br>        preorderTraversal(T-&gt;right);<br>    }<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(BinTree T)</span>{<br>    <span class="hljs-keyword">if</span>(T){<br>        inorderTraversal(T-&gt;data);<br>        print(T-&gt;data);<br>        inorderTraversal(T-&gt;right);<br>    }<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(BinTree T)</span>{<br>    <span class="hljs-keyword">if</span>(T){<br>        postorderTraversal(T-&gt;left);<br>        postorderTraversal(T-&gt;right);<br>        print(T-&gt;data);<br>}<br>}<br><br><span class="hljs-comment">/* 非递归实现*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(BinTree T)</span>{<br>Stack s = initStack();<br>    <span class="hljs-keyword">while</span>(T || isEmpty(s)){<br>        <span class="hljs-keyword">while</span>(T){<br>            push(S, T);<br>            <span class="hljs-comment">/* 第一次碰到 */</span><br>            print(T-&gt;data);<br>            T = T-&gt;left;<br>}<br>        <span class="hljs-keyword">if</span>(isEmpty(s)){<br>            T = pop(s);<br>            T = T-&gt;right;<br>        }<br>    }<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(BinTree T)</span>{<br>Stack s = initStack();<br>    <span class="hljs-keyword">while</span>(T || isEmpty(s)){<br>        <span class="hljs-keyword">while</span>(T){<br>            push(S, T);<br>            T = T-&gt;left;<br>}<br>        <span class="hljs-keyword">if</span>(!isEmpty(s)){<br>            T = pop(s);<br>            <span class="hljs-comment">/* 第二次碰到 */</span><br>            <span class="hljs-comment">/* 每次打印的要么是无左孩子的结点，要么是左孩子已经打印过了 */</span><br>            print(T-&gt;data);<br>            T = T-&gt;right;<br>        }<br>    }<br>}<br><span class="hljs-comment">// 难点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(BinTree T)</span>{<br>Stack s = initStack();<br>    BinTree printed = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(T || isEmpty(s)){<br>        <span class="hljs-keyword">while</span>(T &amp;&amp; T-&gt;left != printed &amp;&amp; T-&gt;right != printed){<br>            push(S, T);<br>            T = T-&gt;left;<br>}<br>        <span class="hljs-keyword">if</span>(isEmpty(s)){<br>            T = getTop(s);<br>            <span class="hljs-comment">/* 打印的时候要么没有右子树，要么右子树已经打印过 */</span><br>            <span class="hljs-keyword">if</span>(T-&gt;right &amp;&amp; T-&gt;right != printed){<br>                T = T-&gt;right;<br>            }<br>            <span class="hljs-keyword">else</span>{<br>             T = pop(s);                <br>                print(T-&gt;data);  <br>                printed = T;<br>                T = getTop(s);<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>拓展：</strong></p><p>一般树的先根遍历、后根遍历、层序遍历。先根遍历=转化成二叉树后的先序遍历；后根遍历=转化成二叉树后的中序遍历。</p><p>森林的先序遍历、中序遍历。森林的先序遍历就是依次对各个树的先根遍历，森林的中序遍历就是依次对各个树的后根遍历。</p><p>至于具体实现，完全可以将他们转化为二叉树，利用遍历的等价性来解决。如下表所示</p><table><thead><tr class="header"><th>树</th><th>森林</th><th>二叉树</th></tr></thead><tbody><tr class="odd"><td>先根遍历</td><td>先序遍历</td><td>先序遍历</td></tr><tr class="even"><td>后根遍历</td><td>中序遍历</td><td>中序遍历</td></tr></tbody></table><h4 id="层序遍历">层序遍历</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">levelorderTraversal</span><span class="hljs-params">(BinTree T)</span>{<br>    <span class="hljs-keyword">if</span>(!T)<br>        <span class="hljs-keyword">return</span>;<br>Queue q = initQueue(q);<br>    BinTree t;<br>    pushBack(q, T);<br>    <span class="hljs-keyword">while</span>(!isEmpty(q)){<br>        t = popFront(q);<br>        print(t-&gt;data);<br>        <span class="hljs-keyword">if</span>(t-&gt;left)<br>        pushBack(q, t-&gt;left);<br>        <span class="hljs-keyword">if</span>(t-&gt;right)<br>            pushBack(q, t-&gt;right);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="应用">应用</h4><p>输出所有叶子结点（修改一下先序遍历）</p><p>求树的高度（<span class="math inline">\(当前高度=max(左子树高度, 右子树高度)+1\)</span>）</p><p>二元运算的表达式树（先序【前缀表达式】、中序【后缀表达式，需要加括号】、后序【后缀表达式】）</p><p>两种遍历序列确定一课二叉树：必须要有中序遍历。先序+中序：先序确定根，中序分左右。</p><p>树的同构问题。若一棵树可以通过若干次左右孩子交换得到另一棵树，则称这两棵树是同构的。</p><h3 id="线索二叉树">线索二叉树</h3><p>线索二叉树是一种物理结构。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadTreeNode</span>{</span><br>ElemType data<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadTreeNode</span>* <span class="hljs-title">left</span>, * <span class="hljs-title">right</span>;</span><span class="hljs-comment">// 左右孩子或者左右线索</span><br>    <span class="hljs-type">int</span> ltag, rtag;<span class="hljs-comment">// 用于区分孩子与线索，1表示线索</span><br>}ThreadTreeNode, *ThreadBinTree;<br></code></pre></td></tr></tbody></table></figure><p>线索又分为前序、中序、后序线索。下图摘自王道考研网课。紫色为后继、黄色为前驱。他们都是拿着空指针做文章。</p><p><img src="http://imagehost.vitaminz-image.top/DS-3.jpg" style="zoom: 33%;"></p><p>线索化，注意前序与中序、后序的区别</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*-------------- 中序 --------------*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">threadling</span><span class="hljs-params">(ThreadBinTree q, ThreadBinTree* preptr)</span>{<br>    <span class="hljs-comment">/* 如果没有左孩子，那就链接为上一结点 */</span><br>    <span class="hljs-keyword">if</span> (!q-&gt;left){<br>    q-&gt;left = pre;<br>        q-&gt;ltag = <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-comment">/* 如果上一结点（如果存在的话）没有孩子 */</span><br>    <span class="hljs-keyword">if</span> (*preptr &amp;&amp; (*preptr)-&gt;left){<br>        (*preptr)-&gt;right = q;<br>        (*preptr)-&gt;rtag = <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-comment">/* 每次结束更新pre，使得每次开始时</span><br><span class="hljs-comment">    pre为遍历序列中该结点的上一个结点 */</span><br>    *preptr = q;<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">inorderThreadAux</span><span class="hljs-params">(ThreadBinTree T)</span>{<br>    <span class="hljs-keyword">if</span>(T){<br>        inorderThread(T-&gt;left);<br>        threadling(T);<br>        inorderThread(T-&gt;right);<br>    }<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">inorderThread</span><span class="hljs-params">(ThreadBinTree T)</span>{<br>    ThreadBinTree pre = <span class="hljs-literal">NULL</span>;<br>    ThreadBinTree* preptr = &amp;pre;<br>    <span class="hljs-keyword">if</span> (T){<br>        inorderThreadAux(T, preptr);<br>    pre-&gt;rtag = <span class="hljs-number">1</span>;<br>    }<br>}<br><br><span class="hljs-comment">/*-------------- 前序 --------------*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">preorderThreadAux</span><span class="hljs-params">(ThreadBinTree T)</span>{<br>    <span class="hljs-keyword">if</span>(T){<br>        threadling(T);<br>        <span class="hljs-comment">/* 注意这一段处理</span><br><span class="hljs-comment">        关键子在于访问结点的孩子是不是可能已经线索化了，</span><br><span class="hljs-comment">        并且考虑的是前驱（左孩子）的线索化（后继的线索化必然是在访问之后）</span><br><span class="hljs-comment">        在前序中，由于线索化的操作在最上面，左孩子有可能先线索化再访问 </span><br><span class="hljs-comment">        对于中序遍历，是先访问左孩子，再线索化处理，</span><br><span class="hljs-comment">        而后序遍历则更不用说，左右孩子都访问后才处理。 */</span><br>        <span class="hljs-keyword">if</span> (!pre-&gt;ltag)<br>        inorderThread(T-&gt;left);<br>        inorderThread(T-&gt;right);<br>    }<br>}<br><br><span class="hljs-comment">/*-------------- 后序 --------------*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">postorderThreadAux</span><span class="hljs-params">(ThreadBinTree T)</span>{<br>    <span class="hljs-keyword">if</span>(T){<br>        inorderThread(T-&gt;left);<br>        inorderThread(T-&gt;right);<br>        threadling(T);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>寻找前驱和后继结点</p><table><thead><tr class="header"><th></th><th>中序</th><th>前序</th><th>后序</th></tr></thead><tbody><tr class="odd"><td>找前驱</td><td>Yes</td><td>No, 需借助父节点</td><td>Yes</td></tr><tr class="even"><td>找后继</td><td>Yes</td><td>Yes</td><td>No，需借助父节点</td></tr></tbody></table><p>代码实现</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*-------------- 中序 --------------*/</span><br>ThreadBinTree <span class="hljs-title function_">mostLeftNode</span><span class="hljs-params">(ThreadBinTree p)</span>{<br>    <span class="hljs-keyword">while</span> (!p-&gt;ltag)<br>        p = p-&gt;left;<br>    <span class="hljs-keyword">return</span> p<br>}<br>ThreadBinTree nextNode(ThreadBinTree p){<br>    <span class="hljs-comment">// 右孩子的最左边的一个结点</span><br>    <span class="hljs-keyword">if</span> (!p-&gt;rtag)<br>        <span class="hljs-keyword">return</span> mostLeftNode(p-&gt;right);<br>    <span class="hljs-keyword">return</span> p-&gt;right;<br>}<br><span class="hljs-comment">// 空间复杂度O(1)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(ThreadBinTree T)</span>{<br>    <span class="hljs-keyword">for</span>(TheradBinTree p = mostLeftNode(T); p != Null; p = nextNode(p))<br>        print(p-&gt;data);<br>}<br>ThreadBinTree <span class="hljs-title function_">mostRightNode</span><span class="hljs-params">(ThreadBinTree p)</span>{<br>    <span class="hljs-keyword">while</span> (p-&gt;rlag)<br>        p = p-&gt;right;<br>    <span class="hljs-keyword">return</span> p;<br>}<br>ThreadBinNode <span class="hljs-title function_">preNode</span><span class="hljs-params">(ThreadBinTree p)</span>{<br>    <span class="hljs-comment">// 左孩子的最右边的一个结点</span><br>    <span class="hljs-keyword">if</span> (!p-&gt;ltag)<br>        <span class="hljs-keyword">return</span> mostRightNode(p-&gt;left);<br>    <span class="hljs-keyword">return</span> p-&gt;left;<br>}<br><span class="hljs-comment">/*-------------- 前序 --------------*/</span><br>ThreadBinTree <span class="hljs-title function_">nextNode</span><span class="hljs-params">(ThreadBinTree p)</span>{<br>    <span class="hljs-comment">// 根 左(根左右) 右</span><br>    <span class="hljs-keyword">if</span> (!p-&gt;rtag)<br>        <span class="hljs-keyword">return</span> mostLeftNode(p-&gt;right);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;left)<br>        <span class="hljs-keyword">return</span> p-&gt;left;<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> p-&gt;right;<br>}<br><span class="hljs-comment">// 引入parent结点</span><br>ThreadBinTree <span class="hljs-title function_">mostRightNode</span><span class="hljs-params">(ThreadBinTree p)</span>{<br>    <span class="hljs-keyword">while</span> (p-&gt;rlag)<br>        p = p-&gt;right;<br>    <span class="hljs-keyword">return</span> p;<br>}<br>ThreadBinTree <span class="hljs-title function_">preNode</span><span class="hljs-params">(ThreadBinTree p)</span>{<br>    <span class="hljs-comment">// 根 左(根左右) 右</span><br>    <span class="hljs-keyword">if</span> (!p-&gt;parent)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!p-&gt;ltag){<br>        <span class="hljs-comment">// 如果是左孩子</span><br><span class="hljs-keyword">if</span> (p-&gt;parent-&gt;left == p || p-&gt;parent-&gt;ltag)<br>            <span class="hljs-keyword">return</span> p-&gt;parent;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 根 左(根左右(根左右(..右))) 右</span><br>            <span class="hljs-keyword">return</span> mostRightNode(p-&gt;parent-&gt;left);<br>    }<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> p-&gt;left;<br>}<br><span class="hljs-comment">/*-------------- 后序 --------------*/</span><br>ThreadBinTree <span class="hljs-title function_">preNode</span><span class="hljs-params">(ThreadBinTree p)</span>{<br>    <span class="hljs-comment">// 右孩子的最左边的一个结点</span><br>    <span class="hljs-comment">// 左 右(左右根) 根</span><br>    <span class="hljs-keyword">if</span> (!p-&gt;rtag)<br>        <span class="hljs-keyword">return</span> mostLeftNode(p-&gt;right);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;right)<br>        <span class="hljs-keyword">return</span> p-&gt;right;<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> p-&gt;left;<br>}<br>ThreadBinTree <span class="hljs-title function_">mostLeftNode</span><span class="hljs-params">(ThreadBinTree p)</span>{<br>    <span class="hljs-keyword">while</span> (!p-&gt;ltag)<br>        p = p-&gt;left;<br>    <span class="hljs-keyword">return</span> p<br>}<br><span class="hljs-comment">// 引入parent结点</span><br>ThreadBinTree nextNode(ThreadBinTree p){<br>    <span class="hljs-keyword">if</span> (!p-&gt;parent)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!p-&gt;rtag){<br><span class="hljs-keyword">if</span> (p-&gt;parent-&gt;right == p || p-&gt;parent-&gt;rtag)<br>            <span class="hljs-keyword">return</span> p-&gt;parent;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 左 ((左..)左右根)右 根</span><br>            <span class="hljs-keyword">return</span> mostLeftNode(p-&gt;parent-&gt;right);<br>    }<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> p-&gt;right;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="应用-1">应用</h3><h4 id="哈夫曼编码">哈夫曼编码</h4><p>概念：WPL-带权路径长度。哈夫曼树的WPL是最小的。</p><p>哈夫曼(Huffman)树的特性：</p><ul><li>没有度为1的结点。</li><li><span class="math inline">\(n_0\)</span>个叶子结点的哈夫曼树有<span class="math inline">\(n=2n_0-1\)</span>个结点</li><li>任意非叶节点左右子树交换仍是哈夫曼树</li><li>对于同一组权值，存在2个不同构的哈夫曼树</li></ul><p>前缀码(Prefix Code): 任何字符的编码都不是另一个字符编码的前缀。在一课树中，前缀码说明每一个字符的编码都在叶子结点结束，而不是在非叶子结点。，</p><h4 id="并查集">并查集</h4><p>disjoint set.</p><p>双亲表示法。下图摘自浙大数据结构mooc。</p><p><img src="http://imagehost.vitaminz-image.top/DS-4.png" style="zoom:30%;"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SetType</span>{</span><br>ElemType data;<br>    <span class="hljs-type">int</span> parent;<br>}SetType;<br></code></pre></td></tr></tbody></table></figure><p>主要操作为查找与合并。他们都有优化版本。其优化的核心思想是尽量减少树的高度。</p><p>王道当中推荐了这样一个算法可视化的网站：</p><p>https://www.cs.usfca.edu/~galles/visualization/DisjointSets.html</p><p>https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</p><ul><li><p>查找</p><p>下图摘自王道考研的ppt</p><p><img src="http://imagehost.vitaminz-image.top/DS-5.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">( SetType s[], <span class="hljs-type">int</span> MaxSize, ElemType X )</span> {<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">/* 顺序查找X的下标 */</span><br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; MaxSize &amp;&amp; s[i].data != X; i++ );<br>    <span class="hljs-keyword">if</span> ( i &gt;= MaxSize ) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">/* 找出根节点 */</span><br>    <span class="hljs-keyword">for</span> ( ; s[i].parent &gt;= <span class="hljs-number">0</span>; i = s[i].parent );<br>    <span class="hljs-keyword">return</span> i;<br>} <br><br><span class="hljs-comment">/* 优化 压缩路径 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">( SetType s[], <span class="hljs-type">int</span> MaxSize, ElemType X )</span> {<br>    <span class="hljs-type">int</span> r, x_idx;<br>    <span class="hljs-comment">/* 顺序查找X的下标 */</span><br>    <span class="hljs-keyword">for</span> ( r = <span class="hljs-number">0</span>; r &lt; MaxSize &amp;&amp; s[r].data != X; r++ );<br>    <span class="hljs-keyword">if</span> ( r &gt;= MaxSize ) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    x_idx = r;<br>    <span class="hljs-comment">/* 找出根节点 */</span><br>    <span class="hljs-keyword">for</span> ( ; s[r].parent &gt;= <span class="hljs-number">0</span>; r = s[r].parent );<br>    <span class="hljs-keyword">while</span> ( x_idx != r ) {<br>        <span class="hljs-type">int</span> temp = s[x_idx].parent;<br>        s[x_idx].parent = r;<br>        x_idx = temp;<br>    }<br>    <span class="hljs-keyword">return</span> i;<br>} <br></code></pre></td></tr></tbody></table></figure></li><li><p>并</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(SetType s[], <span class="hljs-type">int</span> MaxSize, ElemType X, ElemType, Y)</span> {<br>    <span class="hljs-type">int</span> r1 = find(S, MaxSize, X);<br>    <span class="hljs-type">int</span> r2 = find(s, MaxSize, Y);<br>    <span class="hljs-keyword">if</span> ( r1 != r2 )<br>    s[r2].parent = r1;<br>}<br><br><span class="hljs-comment">/* 利用优化根节点的绝对值表示树的结点数，如-3表示高度为3，然后让小树合并到大树上</span><br><span class="hljs-comment">   可以保证树的高度不超过$\lfoor log_2 n \rfloor +1$ */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(SetType s[], <span class="hljs-type">int</span> MaxSize, ElemType X, ElemType, Y)</span> {<br>    <span class="hljs-type">int</span> r1 = find(S, MaxSize, X);<br>    <span class="hljs-type">int</span> r2 = find(s, MaxSize, Y);<br>    <span class="hljs-keyword">if</span> ( r1 == r2 )<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> ( s[r1].parent != s[r2].parent ) {<br>    s[r1].parent += s[r2].parent;<br>        s[r2].parent = r1;<br>    }<br>    <span class="hljs-keyword">else</span> {<br>        s[r2].parent += s[r1].parent;<br>        s[r1].parent = r2;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure></li></ul><h4 id="查找">查找</h4><p>此外，在查找中，大量使用了树的数据结构，请看下一章。</p><h4 id="排序">排序</h4><h5 id="堆">堆</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HNode</span> {</span><br>    ElemType *data; <span class="hljs-comment">/* 存储元素的数组 */</span><br>    <span class="hljs-type">int</span> size;          <span class="hljs-comment">/* 堆中当前元素个数 */</span><br>    <span class="hljs-type">int</span> capacity;      <span class="hljs-comment">/* 堆的最大容量 */</span><br>}HNode, *Heap;<br><span class="hljs-keyword">typedef</span> Heap MaxHeap; <span class="hljs-comment">/* 最大堆 */</span><br><span class="hljs-keyword">typedef</span> Heap MinHeap; <span class="hljs-comment">/* 最小堆 */</span><br></code></pre></td></tr></tbody></table></figure><p>优先级队列。除了堆，可以使用插入排序的方式来维持。</p><p>堆是一种完全二叉树。</p><p>从根到任意结点都是有序的，最大堆是降序，最小堆则是升序。</p><p>或者也可以说堆中，任意结点都大于等于（或小于等于）它的孩子结点。</p><p>与其他队列相同，在尾部插入、头部删除，不一样的是插入、删除后还要进行一系列操作，以维持堆的特性。</p><ul><li><p>插入</p><p>自下而上地调整。核心思想在于，对插入结点位置祖宗构成的路径进行插入排序。根节点集体下移，能够保证其依旧是个堆，因为下移后的根，必然比原来的根要大，也就必然比原来的孩子要大。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">( MaxHeap H, ElemType X )</span>{ <br>    <span class="hljs-comment">/* 将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵 */</span><br>    <span class="hljs-comment">/* 哨兵为X的最大可能值 */</span><br>    <span class="hljs-keyword">if</span> (isFull(H)) { <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"最大堆已满"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br><span class="hljs-type">int</span> i = ++H-&gt;size;<br>    <span class="hljs-keyword">for</span> ( ; H-&gt;data[i] &lt; X; i /= <span class="hljs-number">2</span> ) {<br>        H-&gt;data[i] = H-&gt;data[i/<span class="hljs-number">2</span>];<br>    }<br>    H-&gt;data[i] = X;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p>删除</p><p>自上而下地调整。将最后一个数据赋值给根节点，然后进行调整。核心思想在于，如果一个完全二叉树的左子树是个最大堆，右子树也是个最大堆，而自己不是一个最大堆。那么如何将其调整为一个最大堆。根结点与左右孩子结点进行比较，取左孩子与右孩子的较大者，与根结点进行交换，那么可以保证根结点大于左右孩子，对于被交换的子树，继续执行相同操作，每次操作由于是将较小者换到上面去，既可以保证原来上方满足堆，那么交换后依旧满足。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">ElemType <span class="hljs-title function_">DelMaxElem</span><span class="hljs-params">( MaxHeap H )</span> {<br>    <span class="hljs-keyword">if</span> (isFull(H)) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"最大堆已满"</span>);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    ElemType MaxElem = H-&gt;data[<span class="hljs-number">1</span>];<br>    ElemType temp = H-&gt;data[H-&gt;size--];<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">/* mooc上用了2个变量，不知道这样写是不是一样的 */</span><br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">2</span>; i &lt;= H-&gt;size; i *= <span class="hljs-number">2</span> ) {<br>        <span class="hljs-keyword">if</span> ( (i &lt; H-&gt;size) &amp;&amp; (H-&gt;data[i] &lt; H-&gt;data[i+<span class="hljs-number">1</span>]) )<br>            i++;<br>        <span class="hljs-keyword">if</span> ( temp &lt; H-&gt;data[i] )<br>        H-&gt;data[i/<span class="hljs-number">2</span>] = H-&gt;data[i];<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">break</span>;<br>    }<br>H-&gt;data[i] = temp;<br>    <span class="hljs-keyword">return</span> MaxElem;<br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p>建堆</p><p>自下而上+自上而下。利用删除的核心思想，如果左右子树是堆，如何调整整颗二叉树为堆。自下而上的都构造堆，再自上而下地调整。<strong>O(n)的时间复杂度</strong>，所有结点的高度之和。稍微求一下时间复杂度，设高度为<span class="math inline">\(h\)</span>，则所有结点高度之和为<span class="math inline">\(S=h\times1+(h-1)\times2+(h-2)\times 2^2+...+1\times 2^{h-2}\)</span>。这是一个差比数列，根据差比数列求法，可得<span class="math inline">\(S=-h+2^{h-3}-1+2^{h-1}\)</span>。又<span class="math inline">\(h=\log_2n\)</span>，因此<span class="math inline">\(S=O(n)\)</span>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*----------- 建造最大堆 -----------*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">percDown</span><span class="hljs-params">( MaxHeap H, <span class="hljs-type">int</span> p )</span> { <br>    <span class="hljs-comment">/* 下滤：将H中以H-&gt;Data[p]为根的子堆调整为最大堆 */</span><br>    ElementType temp = H-&gt;data[p]; <span class="hljs-comment">/* 取出 根结点存放的值 */</span><br>    <span class="hljs-type">int</span> parent, child;<br>    <span class="hljs-comment">/* mooc上用了2个变量，可读性更高 */</span><br>    <span class="hljs-keyword">for</span> (parent = p; parent * <span class="hljs-number">2</span> &lt;= H-&gt;size; parent = child) {<br>        child = parent * <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> ((child &lt; H-&gt;size) &amp;&amp; (H-&gt;data[child] &lt; H-&gt;data[child+<span class="hljs-number">1</span>]))<br>            child++;<br>        <span class="hljs-keyword">if</span> (temp &lt; H-&gt;data[child])<br>        H-&gt;data[parent] = H-&gt;data[child];<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">break</span>;<br>    }<br>H-&gt;data[parent] = temp;<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildHeap</span><span class="hljs-params">( MaxHeap H )</span> { <br>    <span class="hljs-comment">/* 调整H-&gt;data[]中的元素，使满足最大堆的有序性  */</span><br>  <span class="hljs-comment">/* 这里假设所有H-&gt;size个元素已经存在H-&gt;data[]中 */</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">/* 从最后一个结点的父节点开始，到根结点1 */</span><br>    <span class="hljs-keyword">for</span>( i = H-&gt;size/<span class="hljs-number">2</span>; i&gt;<span class="hljs-number">0</span>; i-- )<br>        percDown( H, i );<br>}<br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="查找-1">查找</h2><p>查找的基本概念</p><p>ASL (Average Search Length) : 平均查找长度。</p><p>查找成功、查找失败的ASL。</p><h3 id="顺序查找">顺序查找</h3><p>带哨兵的顺序查找，其实就是少了一个判断，稍微提高了点效率</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span><br>ElemType data;<br>    <span class="hljs-type">int</span> len;<br>}table;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(table t, ElemType x)</span> {<br>    <span class="hljs-comment">/* 哨兵 */</span><br>    t.data[<span class="hljs-number">0</span>] = x;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> ( i = t.len; x != t.data[i]; i-- );<br>    <span class="hljs-keyword">return</span> i;<br>}<br></code></pre></td></tr></tbody></table></figure><p>等概率的情况。</p><p>成功：<span class="math inline">\(ASL_{成功} = (n+1)/2 = O(n)；\)</span></p><p>失败：<span class="math inline">\(ASL_{失败} = (n+1) = O(n)\)</span>（存在失败每个元素比较n+1次，1为与哨兵的比较）；也可以优化为<span class="math inline">\(ASL_{失败} = (1+2+...+n+n) / (n+1)\)</span>。</p><h3 id="折半查找">折半查找</h3><p>适合于<strong>静态查找</strong>（即不涉及插入删除数据）</p><p>查找判定树。下图摘自王道考研ppt。</p><p><img src="http://imagehost.vitaminz-image.top/DS-7.png" style="zoom:33%;"></p><p>如上图所示的查找判定树。mid向下取整，是右撇类型，即同一层中，先有右孩子，并自右向左添加。再添左孩子，同时也是自右向左添加。</p><p>构造方式很简单，就是自顶向下，每次取中作为根结点，分成左右两个集合。那么当集合中只有2个元素，由于向下取整，小的为根，大的就是叶子了。</p><p><span class="math inline">\(ASL_{成功}=(1*1+2*2+3*4+4*4)/11=3\)</span>，分子=<span class="math inline">\(\sum\)</span>每个结点的高度，分母=绿色结点数=11，</p><p><span class="math inline">\(ASL_{失败}=(3*4+4*8)/12=11/3\)</span>，分子=<span class="math inline">\(\sum\)</span><strong>每个空指针所在结点的高度</strong>，分母=空指针数=12。</p><p>对于<span class="math inline">\(mid=\lfloor (l+r)/2 \rfloor\)</span>的计算方式来说，其查找判定数的右子树结点数-左子树结点数=0或1。</p><p>只有最后一层的结点数是不满的，该性质与完全二叉树相同。</p><p>查找效率<span class="math inline">\(O(log_2n)\)</span>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">binSearch</span><span class="hljs-params">(table t, ElemType x)</span> {<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, t = t.len - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> mid;<br><span class="hljs-keyword">while</span> (l &lt;= r) {<br>mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> ( x &gt; t.data[mid] )<br>            l = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( x &lt; t.data[mid] )<br>            r = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> mid;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>查找失败的话变量l和r分别在什么位置呢？</p><p>首先在 l &gt; r 前，必然要经历 mid == l 。简单地说明一下，可设 r = l + k，可得mid = (l + r) / 2 = l + k/2。那么当l + k/2 - 1 &lt; l 或者 l + k/2 + 1 &gt; r = l + k 时，必然地，k == 1 或 0，此时mid == l。那么如果查找失败，可以肯定当(mid == l &amp;&amp; l &lt;= r)即(mid == l &amp;&amp; l +1 == r)时，t.data[l] &lt; x, t.data[r] &gt; x，那么下一步，t.data[l] &gt; x, t.data[r] &lt; x，因此最终形态是，l 指向的是<strong>第一个大于</strong> x 的数，而r指向的是<strong>最后一个小于</strong> x 的数。</p><h3 id="分块查找">分块查找</h3><p>也叫索引顺序查找，也属于静态查找（也可使用链接存储达到动态查找的效果）。块内无序、块间有序。如下图所示，摘自王道ppt。</p><p><img src="http://imagehost.vitaminz-image.top/DS-27.png" style="zoom:50%;"></p><p>块间可以使用顺序查找，也可以使用折半查找。块内使用顺序查找。</p><p>如果块间使用折半查找，mid采用向下取整的方式，可使用折半查找中查找失败的结论，利用 l 来定位。因为查找失败的话，则说明 l 所在的位置是第一个大于 x 的数，正是 x 可能存在的块中。</p><p><img src="http://imagehost.vitaminz-image.top/DS-28.png" style="zoom:50%;"></p><p>假若将块的大小设置为固定值如上图所示（摘自王道ppt），那么有如下分析。</p><p>假设都是用顺序查找的方式，<span class="math inline">\(ASL_{成功}=\frac{\sum_{i=1}^{b}\sum_{i,j=1}^s (Block_i+Elem_{i,j})}{b\times s}=\frac{b\times sum_{块内}+ s\times\sum_{i=1}^bBlock_i}{b\times s}=ASL_{块内}+ASL_{块间}\)</span>。</p><p>进一步得：<span class="math inline">\(ASL_{成功}=\frac{b+1}{2}+\frac{s+1}{2}=\frac{s^2+2s+n}{2s}=\frac{s}{2}+\frac{n}{2s}+1\)</span>，利用基本不等式很快就能得到但他<span class="math inline">\(s=\sqrt{n}\)</span>时最小，且此时<span class="math inline">\(ASL_{成功}=\sqrt{n}+1\)</span>。</p><p>下图摘自王道ppt。即当动态查找时，可以使用链接存储的方式。</p><p><img src="http://imagehost.vitaminz-image.top/DS-29.png" style="zoom:50%;"></p><h3 id="二叉搜索树">二叉搜索树</h3><h4 id="bst">BST</h4><p>一般二叉搜索树要求不能有相同元素值。我们可以称这种元素为<strong>关键字(key)</strong>，与关键字关联的数据我们可以称为<strong>卫星数据</strong>(就像卫星一样跟着关键字)，这些数据包括左孩子、右孩子之类的指针，也可以包括与关键字相关联的<strong>记录</strong>。为了方便，以下的数据结构中，记录的数据结构暂且不考虑，因为这与查找无关。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 和普通的二叉树相同 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span>{<br>    ElemType key;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span>* left;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span>* right;    <br>}BSTNode, BST;<br></code></pre></td></tr></tbody></table></figure><ul><li><p>查找</p><p>ASL的分析与查找判定树的分析相同。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 非递归方法 */</span><br><span class="hljs-function">BSTNode* <span class="hljs-title">search</span><span class="hljs-params">(BST T, ElemType x)</span> </span>{<br>    <span class="hljs-keyword">while</span> (T &amp;&amp; x != T-&gt;data) {<br>        <span class="hljs-keyword">if</span> (x &lt; T-&gt;data) <br>            T = T-&gt;left;<br>        <span class="hljs-keyword">else</span> <br>            T = T-&gt;right;<br>    }<br>    <span class="hljs-keyword">return</span> T;<br>}<br><br><span class="hljs-comment">/* 递归方法，就硬递归，没有必要 */</span><br><span class="hljs-function">BSTNode* <span class="hljs-title">search</span><span class="hljs-params">(BST T, ElemType x)</span> </span>{<br>    <span class="hljs-keyword">if</span> (T) {<br><span class="hljs-keyword">if</span> (x == T-&gt;data)<br>            <span class="hljs-keyword">return</span> T;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &lt; T-&gt;data)<br>            <span class="hljs-built_in">search</span>(T-&gt;left, x);<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-built_in">search</span>(T-&gt;right, x);<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p>插入</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 非递归方法 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(BST T, ElemType x)</span> </span>{<br>    BST pre;<br>    <span class="hljs-keyword">while</span> (T) {<br>        pre = T;<br>        <span class="hljs-keyword">if</span> (x == T-&gt;data)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">"插入失败"</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; T-&gt;data)<br>            T = T-&gt;left;<br>        <span class="hljs-keyword">else</span> <br>            T = T-&gt;right;<br>    }<br>    <br>    BST node = <span class="hljs-keyword">new</span> BSTNode;<br>    node-&gt;data = x;<br>    node-&gt;left = node-&gt;right = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">if</span> (pre-&gt;left == <span class="hljs-literal">NULL</span>)<br>        pre-&gt;left = node;<br>    <span class="hljs-keyword">else</span><br>        pre-&gt;right = node;<br>}<br><br><span class="hljs-comment">/* 递归方法 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(BST&amp; T, ElemType x)</span> </span>{<br>    <span class="hljs-keyword">if</span> (T) {<br><span class="hljs-keyword">if</span> (x == T-&gt;data)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-string">"插入失败"</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &lt; T-&gt;data)<br>            <span class="hljs-built_in">insert</span>(T-&gt;left, x);<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-built_in">insert</span>(T-&gt;right, x);<br>    }<br>    <span class="hljs-keyword">else</span> {<br>        <span class="hljs-comment">/* 注意这里是传引用，所以传进来的就是那存储NULL的地址，而不是NULL本身 */</span><br>        T = <span class="hljs-keyword">new</span> BSTNode;<br>        T-&gt;data = x;<br>        T-&gt;left = T-&gt;right = <span class="hljs-literal">NULL</span>;<br>    }<br>}<br><br><span class="hljs-comment">/* 二叉树的构造，不断地插入 */</span><br><br></code></pre></td></tr></tbody></table></figure></li><li><p>删除</p><p>寻找该结点中序遍历的前驱或后继进行替代。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 非递归方法 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(BST T, ElemType x)</span> </span>{<br>    <span class="hljs-keyword">while</span> (!T &amp;&amp; T.data != x) {<br>        <span class="hljs-keyword">if</span> (x &lt; T.data)<br>            T = T-&gt;left;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; T.data)<br>            T = T-&gt;right;<br>    } <br>    <span class="hljs-keyword">if</span> (T) {<br>        <span class="hljs-comment">/* 2种方法，一种是往左找最右的结点，一种是往右找最左的结点 */</span><br>        <span class="hljs-comment">/* 第一种 */</span><br>        <span class="hljs-comment">/* 写的不太对，有空再改 */</span><br>        BST* ptr = &amp;(T-&gt;left);<br>        <span class="hljs-keyword">if</span> (*ptr){<br>        <span class="hljs-keyword">while</span> ((*ptr) &amp;&amp; (*ptr)-&gt;right) <br>            ptr = &amp;((*ptr)-&gt;right);<br>        BST tmp = (*ptr);<br>        (*ptr) = (*ptr)-&gt;left; <br>        T-&gt;data = tmp-&gt;dat<br>        <span class="hljs-keyword">delete</span> tmp;<br>        <span class="hljs-comment">/* 第二种略 */</span><br>    }<br>    <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">"该元素不存在"</span>;<br>    }<br>}<br><br><span class="hljs-comment">/* 删除 递归写法 */</span><br><br><span class="hljs-function">BST <span class="hljs-title">mostRightNode</span><span class="hljs-params">(BST p)</span></span>{<br>    <span class="hljs-keyword">while</span> (p-&gt;right)<br>        p = p-&gt;right;<br>    <span class="hljs-keyword">return</span> p;<br>}<br><br><span class="hljs-function">BST <span class="hljs-title">remove</span><span class="hljs-params">(BST T, ElemType x)</span> </span>{<br>    <span class="hljs-type">int</span> tmp;<br>    <span class="hljs-keyword">if</span> (!T)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">"没有该元素"</span>;<br>    <span class="hljs-keyword">if</span> (x &lt; BST-&gt;data)<br>        T-&gt;left = <span class="hljs-built_in">remove</span>(BST-&gt;left, x);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; BST-&gt;data)<br>        T-&gt;right = <span class="hljs-built_in">remove</span>(BST-&gt;right, x);<br>    <span class="hljs-keyword">else</span>{<br>        <span class="hljs-keyword">if</span> (BST-&gt;left &amp;&amp; BST-&gt;right) {<br>            BST tmp = <span class="hljs-built_in">mostRightNode</span>(BST-&gt;left);<br>            T-&gt;data = tmp-&gt;data;<br>            T-&gt;left = <span class="hljs-built_in">remove</span>(T-&gt;left, T-&gt;data)<br>        }<br>        <span class="hljs-keyword">else</span> {<br>            BST tmp = T;<br>            <span class="hljs-keyword">if</span> (!T-&gt;left)<br>                T = T-&gt;right;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (T-&gt;right)<br>                T = T-&gt;left;<br>            <span class="hljs-keyword">delete</span> tmp;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> T;<br>}<br></code></pre></td></tr></tbody></table></figure></li></ul><h4 id="avl">AVL</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AVLNode</span>{<br>    ElemType data; <span class="hljs-comment">/* 结点数据 */</span><br>    AVLNode* left;     <span class="hljs-comment">/* 指向左子树 */</span><br>    AVLNode* right;    <span class="hljs-comment">/* 指向右子树 */</span><br>    <span class="hljs-type">int</span> height;       <span class="hljs-comment">/* 树高 */</span><br>}AVLNode, *AVLTree;<br></code></pre></td></tr></tbody></table></figure><p>平衡二叉树，任意结点的左子树和右子树高度不超过1。</p><p>结点的平衡因子=左子树高度-右子树高度。下图摘自浙大数据结构mooc，有趣的证明。以及下面的高度是从0开始的，我们使用的是<strong>从1开始</strong>，这点要注意。</p><p><img src="http://imagehost.vitaminz-image.top/DS-8.png" style="zoom:33%;"></p><p><img src="http://imagehost.vitaminz-image.top/DS-9.png" style="zoom:33%;"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 更新树高 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{<br>    <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(AVLTree T)</span> </span>{<br>    <span class="hljs-keyword">if</span> (!T)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">getMax</span>(<span class="hljs-built_in">getHeight</span>(T-&gt;left), <span class="hljs-built_in">getHeight</span>(T-&gt;right));<br>}<br></code></pre></td></tr></tbody></table></figure><p>4种调整方式：LL(左孩子的左子树中插入导致不平衡)、RR、LR、RL。下图摘自浙大mooc。关于左右单旋的说法：采用《算法导论》中的说法，LL采取的方法是右旋，RR采用的是左旋；LR则是左、右旋，RL是右、左旋。这与mooc上的说法正好相反，但实际操作是相同的。</p><p><img src="http://imagehost.vitaminz-image.top/DS-10.png" style="zoom:33%;"></p><p><img src="http://imagehost.vitaminz-image.top/DS-11.png" style="zoom:33%;"></p><p><img src="http://imagehost.vitaminz-image.top/DS-12.png" style="zoom:33%;"></p><p><img src="http://imagehost.vitaminz-image.top/DS-13.png" style="zoom:33%;"></p><ul><li><p>插入</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 采用递归的写法 */</span><br><span class="hljs-function">AVLTree <span class="hljs-title">rightRotate</span><span class="hljs-params">(AVLTree T)</span> </span>{<br>    AVLTree Tl = T-&gt;left;<br>    T-&gt;left = Tl-&gt;right;<br>    Tl-&gt;right = T;<br>    T-&gt;height = <span class="hljs-built_in">getHeight</span>(T);<br>    Tl-&gt;height = <span class="hljs-built_in">getHeight</span>(Tl);<br>    <span class="hljs-keyword">return</span> Tl;<br>}<br><br><span class="hljs-function">AVLTree <span class="hljs-title">leftRotate</span><span class="hljs-params">(AVLTree T)</span> </span>{<br>    AVLTree Tr = T-&gt;right;<br>    T-&gt;right = Tr-&gt;left;<br>    Tr-&gt;left = T;<br>    T-&gt;height = <span class="hljs-built_in">getHeight</span>(T);<br>    Tr-&gt;height = <span class="hljs-built_in">getHeight</span>(Tr);<br>    <span class="hljs-keyword">return</span> Tr;<br>}<br><br><span class="hljs-function">AVLTree <span class="hljs-title">leftRightRotate</span><span class="hljs-params">(AVLTree T)</span> </span>{<br>A-&gt;left = <span class="hljs-built_in">leftRotate</span>(A-&gt;left);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(A);<br>}<br><br><span class="hljs-function">AVLTree <span class="hljs-title">rightLeftRotate</span><span class="hljs-params">(AVLTree T)</span> </span>{<br>A-&gt;right = <span class="hljs-built_in">rightRotate</span>(A-&gt;right);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(A);<br>}<br><br><span class="hljs-function">AVLTree <span class="hljs-title">insert</span><span class="hljs-params">(AVLTree T, ElemType x)</span> </span>{<br>    <span class="hljs-keyword">if</span> (!T){<br>        AVLTree T = <span class="hljs-keyword">new</span> AVLNode;<br>        T-&gt;data = x;<br>        T-&gt;left = T-&gt;right = <span class="hljs-literal">NULL</span>;<br>    }<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &lt; T-&gt;data) {<br>        <span class="hljs-comment">/* 先插进去 */</span><br>        T = <span class="hljs-built_in">insert</span> (T-&gt;left, x);<br>        <span class="hljs-comment">/* 插完后发现，不平衡，进行LL或LR */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getHeight</span>(T-&gt;left) - <span class="hljs-built_in">getHeight</span>(T-&gt;right) == <span class="hljs-number">2</span>){<br>            <span class="hljs-keyword">if</span> (x &lt; x-&gt;left-&gt;data)<br>                <span class="hljs-comment">/* LL 右旋 */</span><br>                <span class="hljs-built_in">rightRotate</span>(T);<br>            <span class="hljs-keyword">else</span> <br>                <span class="hljs-built_in">leftRightRotate</span>(T);<br>        }<br>    }<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; T-&gt;data) {<br>        <span class="hljs-comment">/* 先插进去 */</span><br>        T = <span class="hljs-built_in">insert</span> (T-&gt;left, x);<br>        <span class="hljs-comment">/* 插完后发现，不平衡，进行RR或RL */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getHeight</span>(T-&gt;left) - <span class="hljs-built_in">getHeight</span>(T-&gt;right) == <span class="hljs-number">-2</span>){<br>            <span class="hljs-keyword">if</span> (x &gt; x-&gt;right-&gt;data)<br>                <span class="hljs-built_in">leftRotate</span>(T);<br>            <span class="hljs-keyword">else</span> <br>                <span class="hljs-built_in">rightLeftRotate</span>(T);<br>        }        <br>    }<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">"存在该元素"</span>;<br>    T-&gt;Height = <span class="hljs-built_in">getHeight</span>(T);<br>    <br>    <span class="hljs-keyword">return</span> T;<br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p>删除</p><ul><li>如普通BST相同的方法，先进行删除</li><li>从删除的结点向上，找到最小的不平衡子树</li><li>找到最高的儿子，再找到儿子的最高儿子（即最高孙子）。</li><li>最高的儿子-最高的孙子构成LL, LR, RR, RL这4种可能，利用上述规律进行调整。</li><li>继续往上找最小的不平衡子树，重复操作。</li></ul></li></ul><h4 id="红黑树">红黑树</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RBTNode</span>{<br>ElemType data;<br>RBTNode* parent;<br>RBTNode* left;<br>RBTNode* right;<br><span class="hljs-type">int</span> color;<span class="hljs-comment">// 结点的颜色，0/1表示红黑</span><br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedBlackTree</span> {<br><span class="hljs-keyword">private</span>:<br>    RBTNode* root;<br>    <span class="hljs-type">static</span> RBTNode* NIL;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RedBlcakTree</span>();<br>    ~<span class="hljs-built_in">RedBlackTree</span>();<br>    <span class="hljs-built_in">insert</span>(ElemType x);<br>    <span class="hljs-built_in">remove</span>(ElemType x);<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>定义<ul><li>它首先是一棵二叉排序树</li><li>根节点和叶结点是黑色的</li><li>叶结点是NULL结点，或叫外部结点（对应的，非空结点为<strong>内部节点</strong>）</li><li>不存在2个相邻的红色结点</li><li>任一结点到叶结点的路径上，所经过的黑结点的数量（<strong>黑高</strong>，不包含该结点）是相同的。</li></ul></li></ul><p>下图摘自《算法导论》，图(a)即为一棵红黑树，在实际编程中，为了方便同时节省空间，我们会用一个统一的哨兵来表示外部结点，如图(b)所示。</p><p><img src="http://imagehost.vitaminz-image.top/DS-14.png" style="zoom: 50%;"></p><ul><li><p>性质</p><ul><li><p>一棵有<span class="math inline">\(n\)</span>个内部结点的红黑树的高度至多为<span class="math inline">\(2log_2(n+1)\)</span>。</p><ul><li>小小地证明一下，首先需要知道的一个结论，对于黑高为<span class="math inline">\(h\)</span>的树，其结点数最少为<span class="math inline">\(2^h-1\)</span>。其原因是显然的，为了是在黑高为一定时，应当使黑色结点尽量多，红色结点尽量少，即没有红色结点。而当全部为黑色结点时，其必然是一棵满二叉树（也是显然的），其内部结点的高度为<span class="math inline">\(h-1+1=h\)</span>，根据满二叉树的性质，结点数量为<span class="math inline">\(2^h-1\)</span>。</li><li>又由于没有2个相邻的红色结点，根节点又是黑色。因此对于高度为<span class="math inline">\(h\)</span>的红黑树，其黑高至少为<span class="math inline">\(h/2\)</span>，因此<span class="math inline">\(n\ge 2^{\frac{h}{2}}-1\)</span>，因此<span class="math inline">\(h\le 2log_2(n+1)\)</span>，证毕。</li><li>由此可见，红黑树是一棵不错的搜索二叉树，因为其搜索的效率为<span class="math inline">\(O(log_2n)\)</span>。</li></ul></li><li><p>任意结点到NIL结点的最长路径不超过最短路径的2倍。该定理不需要证明，下图一目了然。也可以说，任意结点的左右子树高度之差不超过2倍。</p><p><img src="http://imagehost.vitaminz-image.top/DS-34.png" style="zoom: 25%;"></p></li></ul></li><li><p>插入</p><p>首先考虑插入结点之后会破坏红黑树的哪些性质。答案是仅有“不存在相邻2个红结点”这一性质会受到破坏（显然）。那么只需当插入的结点与父结点同为红色时，才需要进行调整。为了简化过程，<strong>以下仅考虑父亲为祖父左孩子的情况，另一种情况同理可得</strong>。而该情况调整又可分为以下情况。</p><ul><li><p>如果插入结点的叔叔是红色：如下图所示，以插入到左孩子为例。那么为了保持“不存在相邻2个红结点”这一性质，自然地能想到将父亲改为黑色。而又为了保证“树高相同”性质，叔叔也得染成黑色。这样虽然能保持结点C的左右子树树高相同，但C的父结点则又被破坏了（因为多了1），为了抵消，自然应当将C改为红色。值得注意的是，这样的更改是递归的，一直改到根节点，但我们知道，根节点没有父结点，且必须为黑色，因此<strong>对于根节点应当保持黑色</strong>。</p><p><img src="http://imagehost.vitaminz-image.top/DS-16.png" style="zoom: 50%;"></p></li><li><p>如果插入结点的叔叔是黑色或者不存在，又分为</p><ul><li>自己是父亲的左孩子，与AVL的LL调整方式一样，即使用右旋，如【图(c)-&gt;图(d)】过程。然后，我们需要考虑的是，如何对结点重新着色，为了保持左右子树的黑高相等，原本的根节点需要转换为红色，而为了向上保持平衡，有变红就有变黑，旋转后的根节点变黑即可。</li><li>自己是孩子的右节点，与AVL的LL调整方式一样，即使用左右旋。对根节点的左孩子进行左旋操作，接下来就是上一种情况了。总的过程如【图(b)-&gt;图(d)】所示。</li></ul><p><img src="http://imagehost.vitaminz-image.top/DS-17.png" style="zoom: 50%;"></p></li></ul></li><li><p>删除</p><p>不考？？</p></li></ul><h3 id="b树和b树">B树和B+树</h3><h4 id="b树">B树</h4><p>磁盘、数据库中常常使用的数据结构。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BTreeNode</span>{<br>    ElemType key[m<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BtreeNode</span> *parent;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BTreeNode</span> *child[m];<br>    <span class="hljs-type">int</span> key_num;<span class="hljs-comment">// 记录实际存储的孩子个数</span><br>}; <span class="hljs-comment">// m阶查找树</span><br></code></pre></td></tr></tbody></table></figure><p>下图摘自王道考研ppt。</p><p><img src="http://imagehost.vitaminz-image.top/DS-18.png" style="zoom:50%;"></p><ul><li><p>定义</p><ul><li>若为m阶B树，则每个结点最多有m个孩子，关键字的个数比孩子的个数少1，除根结点（因为如果只有一个数据，则不可能做到）以外最少有<span class="math inline">\(\lceil m/2\rceil\)</span>个孩子，注意关键字的数量是<span class="math inline">\(\lceil m/2\rceil-1\ne \lfloor m/2\rfloor\)</span>。孩子数量的下限是为了保证树高不宜过高。</li><li>每个结点内部数据是有序排放的。</li><li>叶子结点、终端节点如上图所示。</li></ul></li><li><p>性质</p><ul><li><p>树高的上下限：计算方法 <span class="math inline">\(n=\sum 结点*关键字个数\)</span></p><ul><li><p>上限：设<span class="math inline">\(t=\lceil m/2 \rceil\)</span> ，上限即每层结点数最少。</p><p>则有<span class="math inline">\(n\ge 1*1+(t-1)*(2+2t+2t^2+...+2t^{h-1})\)</span>，</p><p>即<span class="math inline">\(n\ge 2t^{h-1}-1\)</span>。</p><p>则<span class="math inline">\(h\le log_t (\frac{n+1}{2})+1\)</span></p></li><li><p>下限：就是一个满m叉树</p><p><span class="math inline">\(n\le \frac{m^h-1}{m-1}*(m-1)=m^h-1\)</span>，</p><p>则<span class="math inline">\(h\ge log_m(n+1)\)</span></p></li></ul></li><li><p>若所有关键字的数量为<span class="math inline">\(n\)</span>，则叶结点的数量为<span class="math inline">\(n+1\)</span>。</p><ul><li>当<span class="math inline">\(i&gt;1\)</span>时，<span class="math inline">\(第i层的孩子数=第i层的关键字数+结点数\)</span>，而<span class="math inline">\(第i层的结点数=第i-1层的孩子数\)</span>。则可得<span class="math inline">\(第i层的孩子数=第i层的关键字数+第i-1层的孩子数\)</span>。</li><li>当<span class="math inline">\(i=1\)</span>时，则可得<span class="math inline">\(第i层的孩子数=第i层的关键字数+1\)</span>。</li><li>因此<span class="math inline">\(第j层的孩子数=\sum_{i=1}^{i=j}{第i层关键字数+1}\)</span>。</li><li>根据以上结论，显然可得叶子结点为<span class="math inline">\(n+1\)</span>。</li></ul></li></ul></li><li><p>搜索</p><p>结点内有序排放，固既可以用顺序查找（有序版），也可以使用二分查找。以下为顺序查找版本的伪码。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 顺序查找，递归，伪码 */</span><br><span class="hljs-function">Btree <span class="hljs-title">search</span><span class="hljs-params">(Btree T, ElemType x)</span> </span>{<br>    <span class="hljs-keyword">if</span> (T){<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-comment">/* 找到第一个比它小或相等的数 */</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; T-&gt;key_num &amp;&amp; x &gt; T-&gt;key[i] ; i++);<br>        <span class="hljs-keyword">if</span> (i &lt; T-&gt;key_num &amp;&amp; x == T-&gt;key[i])<br>            <span class="hljs-keyword">return</span> T;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">search</span>(T-&gt;child[i], x);<br>}<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p>插入</p><p>所有的关键字（如果树中不存在的话）<strong>插入都应插入在终端结点中</strong>。对应的为查找失败的情况。下入摘自王道考研ppt。</p><p><img src="http://imagehost.vitaminz-image.top/DS-22.png" style="zoom:50%;"></p><p>为了保证B树的特性，我们首先向根结点逐个插入数据，一旦满了就执行分裂。如下图所示。下图摘自《算法导论》。这是根节点的情况。</p><p><img src="http://imagehost.vitaminz-image.top/DS-20.png" style="zoom:50%;"></p><p>如果是非根结点，则如下图所示。<strong>取中、上提、分两边</strong>。</p><p><img src="http://imagehost.vitaminz-image.top/DS-21.png" style="zoom: 50%;"></p><p>这种分裂，显然是向上递归进行的。</p><p>一个连续的过程如下（摘自《算法导论》）。有点<strong>小问题</strong>：如图（d）所示，插入L时，从根结点出发，发现根结点是满的，则分裂。但实际上，L的插入并不会使根结点溢出。而<em>王道</em>的网课中，则是每次插入后查看有没有溢出，溢出则进行分裂。</p><p><img src="http://imagehost.vitaminz-image.top/DS-23.png" style="zoom:50%;"></p></li><li><p>删除</p><p>如果被删除的结点为非终端结点，则于BST相同，利用该结点的前驱或后继代替。然后再删除前驱或者后继。由于前驱和后继必定处于终端结点，因此非终端结点的删除又可以转化为终端结点的删除。<strong>以下只需讨论终端结点的删除。</strong></p><p>如果删除关键字后，依旧<span class="math inline">\(\lceil m/2\rceil -1\)</span>的数量下限，则直接删除，并注意移位处理。如下图（b）情况。摘自《算法导论》。</p><p>如果删除关键字后，不满足则（下图摘自王道书）</p><ul><li>相邻兄弟是否可以移动一个元素给他，若可以则顺势移动</li><li>若不够则合并</li></ul><p><img src="http://imagehost.vitaminz-image.top/DS-31.png" style="zoom: 25%;"></p></li></ul><h4 id="b树-1">B+树</h4><p><img src="http://imagehost.vitaminz-image.top/DS-19.png" style="zoom: 40%;"></p><p>主要明确B+树与B树之间的区别即可。如下图所示，摘自王道ppt。</p><p><img src="http://imagehost.vitaminz-image.top/DS-30.png" style="zoom:50%;"></p><h3 id="散列查找">散列查找</h3><p>基本思想：设计对象到位置的映射（哈希函数，不一定是一一映射，因此可能产生<strong>冲突</strong>）。2个关键词：<strong>哈希函数、冲突</strong></p><ul><li><p>常用的哈希函数</p><ul><li>直接定址法：<span class="math inline">\(h(key)=a\times key+b\)</span></li><li>除留余数法：<span class="math inline">\(h(key)=key \mod p\)</span>，<span class="math inline">\(p\)</span>都是素数。之所以取素数</li><li>数字分析法：取比较随机的位作为散列地址。比如手机号的后四位、身份证号的特定位组合</li><li>折叠法：如对数字拆成几部分然后相加</li><li>平方取中法：平方数取中间几位，该方法上面2种的目的都是希望充分利用数字的各位信息</li><li>ascii码相加法：并不是很理想，如字母位置不同。改进：移位法</li></ul></li><li><p>常见的冲突处理</p><ul><li><p>开放地址法</p><p>注意开放地址法使用<strong>懒惰删除</strong>，并未实际释放存储空间。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cell</span>{<br>    <span class="hljs-type">int</span> empty;<span class="hljs-comment">// 存在位</span><br>    ElemType data;<br>};<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hash</span> {<br>    <span class="hljs-type">int</span> size;<br>    Cell * elem;<br>}Hash, * HashTable;<br></code></pre></td></tr></tbody></table></figure><ul><li><p>线性探测：冲突后，偏移量<span class="math inline">\(\Delta_i=i\)</span>，缺陷：<strong>聚集现象</strong>。ASL分析：<span class="math inline">\(ASL_{失败}\)</span>可以利用哈希值的所有可能值进行分类，分别求其比较次数再取平均。</p></li><li><p>平方探测：冲突后，偏移量<span class="math inline">\(\Delta_i= \pm i^2\)</span>，缺陷：<strong>可能找不到空闲，但可以避免：只要表长是某个4k+3形式的素数，平方探测就可以探查到整个表</strong>。</p></li><li><p>双散列：再设计一个哈希函数，<span class="math inline">\(\Delta_i= i*h_2(key)\)</span>。较好的<span class="math inline">\(h_2\)</span>设计：<span class="math inline">\(h_2(key)=p-(key \mod p)\)</span>，<span class="math inline">\(p\)</span>和表长都是素数。</p></li><li><p>再散列：扩大散列表。如当装填因子<span class="math inline">\(0.5\le\alpha\le0.85\)</span>的范围左右，可能就要重新设计散列表。扩大散列表后，并不是直接把原来的数复制进去，而是要进行重新的散列计算装填到新的散列表中。</p></li></ul></li><li><p>分离链接法（王道中叫拉链法）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> {<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>* next;<br>}ListNode, *List;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hash</span> {<br>    <span class="hljs-type">int</span> size;<br>    List list;<br>}<br></code></pre></td></tr></tbody></table></figure><p>王道中的小优化。</p><p><img src="http://imagehost.vitaminz-image.top/DS-26.png" style="zoom:50%;"></p></li></ul></li><li><p>性能评估</p><ul><li><p>评估指标</p><ul><li><p>查找效率ASL</p><p><span class="math inline">\(ASL_{成功}=\sum{已装填元素查找次数}/元素个数\)</span></p><p><span class="math inline">\(ASL_{失败}=\sum{所有可能的哈希值在找不到的情况下查找次数}/哈希值取值数量\)</span></p></li><li><p>存储效率</p><p>暂时没有找到这个定义，不过根据浙大mooc推测，开放地址法的存储效率比链地址法要高，好像就跟顺序存储和链接存储有关。</p></li></ul></li><li><p>影响因素</p><ul><li><p>装填因子<span class="math inline">\(\alpha\)</span>：散列表的空间为m，实际装入散列表为n。装填因子为m/n。装填因子越大，冲突越多，在超过一定大小的装填因子后，冲突数量可能急剧上升。因此散列查找可以视作一种<strong>空间换时间</strong>的查找手段。</p></li><li><p>散列函数是否均匀</p></li><li><p>冲突处理的方法</p></li></ul></li><li><p>各种冲突处理方法与装填因子的ASL期望值（考试应该会给）</p><ul><li>线性探测法：<span class="math inline">\(ASL_{成功}=\frac{1}{2}(1+\frac{1}{1-\alpha}), ASL_{失败}=\frac{1}{2}(1+\frac{1}{(1-\alpha)^2})\)</span></li><li>平方探测与双散列探测：<span class="math inline">\(ASL_{成功}=-\frac{1}{\alpha}\ln(1-\alpha) , ASL_{失败}=\frac{1}{1-\alpha}\)</span></li><li>分离链接：<span class="math inline">\(ASL_{成功}=1+\frac{\alpha}{2} , ASL_{失败}=\alpha+e^{-\alpha}\)</span></li></ul><p>下图来看的话再0.5之前没有什么区别，而后的差距急剧上升，线性探测平均要劣于双散列与平方探测。</p><p><img src="http://imagehost.vitaminz-image.top/DS-32.png" style="zoom: 33%;"></p></li></ul></li></ul><h2 id="图">图</h2><h3 id="概念-1">概念</h3><ul><li><p>定义</p><ul><li><strong>非空</strong>顶点集合V和有限边集合E组成。</li></ul></li><li><p>类型</p><ul><li>有向图、无向图。带权图（网络）</li></ul></li><li><p>子图</p><ul><li><span class="math inline">\(V'\sube V,E'\sube E\)</span>，子图前提得是图，边须有顶点关联</li><li>生成子图：<span class="math inline">\(V'=V\)</span>时。</li></ul></li><li><p>完全图</p><ul><li>无向图：n个点，n(n-1)/2条边</li><li>有向图：n个点，n(n-1)条边</li></ul></li><li><p>路径</p><ul><li>顶点构成的序列，且顶点间需要有边关联</li><li>简单路径：顶点不重复出现</li><li>简单回路：除起点的顶点不重复出现</li></ul></li><li><p>连通性</p><ul><li><p>连通：2个点存在一条路径</p></li><li><p>连通图：任意两个点连通</p></li><li><p>连通分量：无向图的<strong>极大</strong>连通子图【极大体现在加一个顶点就不连通了，子图种所有顶点相连的边】</p></li><li><p>强连通：2个顶点存在双向路径</p></li><li><p>强连通图：任意两个顶点都是强连通</p></li><li><p>强连通分量：有向图的极大强连通子图</p></li></ul></li></ul><h3 id="表示法">表示法</h3><p>图有多种存储方式，而不同的存储方式效率会有所不同，因此下述有关图的算法都使用伪代码来表示，屏蔽了图在存储结构不同时所带来的区别。</p><ul><li><p>邻接矩阵</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">GNode</span>{<br>    <span class="hljs-type">int</span> Nv;<span class="hljs-comment">// 顶点数</span><br>    <span class="hljs-type">int</span> Ne;<span class="hljs-comment">// 边数</span><br>WeightType Graph[MaxVertexNum][MaxVertexNum];<br>    DataType Data[MaxVertexNum];<br>}GNode, *MGraph;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Vertex;<br><br><span class="hljs-function">MGraph <span class="hljs-title">initGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> VertexNum)</span> </span>{<br>    MGraph G;<br>    G = (MGraph)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> GNode));<br>    G-&gt;Nv = VertexNum;<br>    G-&gt;Ne = <span class="hljs-number">0</span>;<br>    <br>    Vertex V, W;<br>    <span class="hljs-keyword">for</span> (V = <span class="hljs-number">0</span>; V &lt; G-&gt;Nv; V++) {<br>        <span class="hljs-keyword">for</span> (W = <span class="hljs-number">0</span>; W &lt; G-&gt;Nv; V++)<br>            G-&gt;Graph[V][W] = <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-keyword">return</span> G;<br>}<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ENode</span> {<br>    Vertex V1, V2;<br>    WeightType Weight;<br>}*Edge;<br><br><span class="hljs-function">MGraph <span class="hljs-title">insertEdge</span><span class="hljs-params">(MGraph G, Edge E)</span> </span>{<br>G-&gt;Graph[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;<br>    G-&gt;Graph[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>无向图可用三角矩阵，构建原矩阵索引到物理存储数组的映射</li><li>邻接结点、度</li><li>空间复杂度<span class="math inline">\(O(|V|^2)\)</span></li></ul></li><li><p>邻接表</p><p>下图摘自王道ppt</p><p><img src="http://imagehost.vitaminz-image.top/DS-47.png" style="zoom: 40%;"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> AdjVNode * PtrAdjVNode;<br><span class="hljs-keyword">typedef</span> AdjVNode {<br>    Vertex AdjV;<span class="hljs-comment">// 该结点编号</span><br>    WeightType Weight;<br>    PtrToAdjVNode Next;<br>};<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VNode</span> {<br>    PtrToAdjVNode FirstNode;<br>    DataType data;<br>}AdjList[MaxVerTexNum];<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">GNode</span>{<br>    <span class="hljs-type">int</span> Nv;<span class="hljs-comment">// 顶点数</span><br>    <span class="hljs-type">int</span> Ne;<span class="hljs-comment">// 边数</span><br>AdjList Graph;<br>}GNode, *LGraph;<br><br><br><span class="hljs-function">LGraph <span class="hljs-title">initGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> VertexNum)</span> </span>{<br>    LGraph G;<br>    G = (LGraph)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> GNode));<br>    G-&gt;Nv = VertexNum;<br>    G-&gt;Ne = <span class="hljs-number">0</span>;<br>    <br>    Vertex V;<br>    <span class="hljs-keyword">for</span> (V = <span class="hljs-number">0</span>; V &lt; G-&gt;Nv; V++) {<br>        G-&gt;Graph[V] = <span class="hljs-literal">NULL</span>;<br>    }<br>    <span class="hljs-keyword">return</span> G;<br>}<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ENode</span> {<br>    Vertex V1, V2;<br>    WeightType Weight;<br>}*Edge;<br><br><span class="hljs-function">MGraph <span class="hljs-title">insertEdge</span><span class="hljs-params">(MGraph G, Edge E)</span> </span>{<br>AdjNode* NewNode = <span class="hljs-keyword">new</span> AdjVNode;<br>    NewNode-&gt;AdjV = E-&gt;V2;<br>    NewNode-&gt;Weight = E-&gt;Weight;<br>    NewNode-&gt;Next = G-&gt;Graph[E-&gt;V1].FirstNode;<br>    G-&gt;Graph[E-&gt;V1].FirstNode = NewNode;<br>    <br>    <span class="hljs-comment">/* 如果是无向图还要反一反再插，以下省略 */</span><br>}<br><br></code></pre></td></tr></tbody></table></figure><ul><li>无向图：空间复杂度<span class="math inline">\(O(|V|+2|E|)\)</span></li><li>有向图：空间复杂度<span class="math inline">\(O(|V|+|E|)\)</span></li></ul></li><li><p>此外还有十字链表法（<strong>有向图</strong>）和邻接多重结点法（<strong>无向图</strong>）</p><ul><li><p><strong>十字链表法</strong></p><p>在存储稀疏矩阵时，有讲到过十字链表，其样式如下图所示。</p><p><img src="http://imagehost.vitaminz-image.top/DS-53.png" style="zoom:33%;"></p><p>以下不过是对上面的变形，边结点，是相同的，但表头指针做了合并。这是因为在图中的矩阵是个方阵，因此行列结点可以放在一个结构体里，再加上顶点可能存在一些数据（如顶点名），所有也有数据域。</p><p><img src="http://imagehost.vitaminz-image.top/DS-51.png" style="zoom: 33%;"></p><p>空间复杂度<span class="math inline">\(O(|V|+|E|)\)</span></p></li><li><p><strong>邻接多重表法</strong></p><p>该表示方法很自由，因为一条边的关联不具有方向性，又不具有出入度之分从x，所以算是十字链表的阉割版。</p><p><img src="http://imagehost.vitaminz-image.top/DS-52.png" style="zoom: 33%;"></p><p>空间复杂度<span class="math inline">\(O(|V|+|E|)\)</span></p></li></ul></li><li><p>比较，下图摘自王道ppt</p><p><img src="http://imagehost.vitaminz-image.top/DS-46.png" style="zoom: 40%;"></p><p>不唯一性体现在链表中的次序是任意的，本质是一个顶点和每个邻接点没有顺序关系。</p></li></ul><h3 id="遍历-1">遍历</h3><h4 id="dfs">DFS</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 伪码 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Vertix V)</span> </span>{<br>    visited[V] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (V的每个邻接点W) {<br>        <span class="hljs-keyword">if</span> (!visited[W])<br>            <span class="hljs-built_in">DFS</span>(W);<br>    }<br>}<br><br><span class="hljs-comment">/* 图并非一定连通，因此考虑所有子图 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listComponents</span> <span class="hljs-params">(Graph G)</span> </span>{<br>    <span class="hljs-keyword">for</span> (each V in G) {<br>        <span class="hljs-keyword">if</span> (!visited[V]) {<br>            <span class="hljs-built_in">DFS</span>(V);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>邻接表：时间复杂度，<span class="math inline">\(O(|V|+|E|)\)</span>，联系树的遍历路径，就是每个顶点和边都会经过3次；空间复杂度，栈，<span class="math inline">\(O(|V|)\)</span>，最坏是<span class="math inline">\(|V|\)</span>，最好是<span class="math inline">\(1\)</span></p><p>邻接矩阵：时间复杂度，<span class="math inline">\(O(|V|^2)\)</span>，对于每个点都要扫描一整行获得邻接点；空间复杂度，<span class="math inline">\(O(|V|)\)</span></p><h4 id="bfs">BFS</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 伪码 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(Vertix V)</span> </span>{<br>    visited[V] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">enqueue</span>(V, Q);<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isempty</span>(Q)) {<br>        V = <span class="hljs-built_in">dequeue</span>(Q);<br>        <span class="hljs-keyword">for</span> (V的每个邻接结点W) {<br>            <span class="hljs-keyword">if</span> (visited[W]) {<br>                visited[W] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">Enqueue</span>(W, Q);<br>            }<br>}<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>邻接表：时间复杂度，<span class="math inline">\(O(|V|+|E|)\)</span>，联系树的层序遍历，就是每个顶点和边都会经过1次；空间复杂度，辅助队列，<span class="math inline">\(O(|V|)\)</span></p><p>邻接矩阵：时间复杂度，<span class="math inline">\(O(|V|^2)\)</span>，对于每个点都要扫描一整行获得邻接点；空间复杂度，<span class="math inline">\(O(|V|)\)</span></p><h3 id="应用-2">应用</h3><h4 id="最短路径">最短路径</h4><h5 id="单源最短路径">单源最短路径</h5><ul><li><p>无权图</p><p>以<span class="math inline">\(V_3\)</span>为起点的起始状态如下图所示</p><p><img src="http://imagehost.vitaminz-image.top/DS-35.png" style="zoom: 50%;"></p><p>最终态如下图所示</p><p><img src="http://imagehost.vitaminz-image.top/DS-36.png" style="zoom: 50%;"></p><p>算法表示如下</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 伪码 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getShortestPath</span><span class="hljs-params">(Vertex V)</span> </span>{<br>    <span class="hljs-comment">/* dist为最短路径 path为到该点的最短路径的上一结点</span><br><span class="hljs-comment">    通过path可以逆回去找到整条路经 它们都初始化为-1 整体框架类似于BFS */</span><br>    <span class="hljs-built_in">Enqueue</span>(V, Q);<br>    dist[V] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isEmpty</span>(Q)) {<br>        V = <span class="hljs-built_in">Dequeue</span>(Q);<br>        <span class="hljs-keyword">for</span> (V的每个邻接点W) {<br>            <span class="hljs-keyword">if</span> (dist[W] == <span class="hljs-number">-1</span>) {<br>                dist[W] = dist[V] + <span class="hljs-number">1</span>;<br>                path[W] = V;<br>                <span class="hljs-built_in">Enqueue</span>(W, Q);<br>            }<br>}<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>它的正确性可以联系树的层序遍历。上述图案可以换个样式，如下图所示。下面的图案可以视为高度是4的“树”，而上述算法则是对下面这样的“树“进行层序遍历。之所以会是最短路径是因为，每层的任何一个结点都不可能跨过一层指向下一层结点。每个结点所在的高度就是最短路径。</p><p><img src="http://imagehost.vitaminz-image.top/DS-38.png" style="zoom: 33%;"></p><p>以上是一种粗略的理解。时间复杂度为<span class="math inline">\(O(|V|+|E|)\)</span>。因为该算法就类似于一次DFS。</p></li><li><p>有权图：<strong>Dijkstra 算法</strong></p><p><strong>不可以有负权边</strong></p><p>下面是当年学Dijkstra算法时做的笔记（二次复习可以直接略过）</p><hr><p>该算法基于<strong>贪心算法</strong>、动态规划、广度优先搜索的思想，基本思想可用以下语言描述：</p><ul><li><p><strong>结论：若已知源点<span class="math inline">\(P_0\)</span>各个点的最短距离，将这些点根据到源点<span class="math inline">\(P_0\)</span>的最短距离升序排序，则可得到有序序列<span class="math inline">\([P_1, P_2, P_3,..., P_n]\)</span>，记<span class="math inline">\(P_0\rightarrow P_k\)</span>表示<span class="math inline">\(P_0\)</span>到<span class="math inline">\(P_k\)</span>的最短距离，<span class="math inline">\(P_s\Rightarrow P_k\)</span>表示<span class="math inline">\(P_s\)</span>到<span class="math inline">\(P_k\)</span>的邻接距离，那么<span class="math inline">\(P_0\rightarrow P_k=\min\limits_{s=0,1,...,k-1}(P_0\rightarrow P_s\Rightarrow P_k)\)</span>。</strong></p><ul><li><p>证明如下：</p><p>可采用反证法，设存在<span class="math inline">\(P_t\)</span>，使得<span class="math inline">\(P_0\rightarrow P_k = P_0\rightarrow P_t\Rightarrow P_k &lt; \min\limits_{s=0,1,..,k-1}(P_0\rightarrow P_s\Rightarrow P_k)\)</span>，且<span class="math inline">\(t&gt; k\)</span>。显然<span class="math inline">\(P_0\rightarrow P_t &lt; P_0\rightarrow P_t\Rightarrow P_k\)</span>，那么<span class="math inline">\(P_0\rightarrow P_t &lt; P_0\rightarrow P_k\)</span>，则<span class="math inline">\(t &lt; k\)</span>，这与假设矛盾，证明完毕。</p></li></ul></li><li><p>有了以上结论，接下来我们需要解决的如何根据上述结论的递推关系，获得序列<span class="math inline">\([P_1, P_2, P_3,..., P_n]\)</span>。</p><p>根据以上结论，显然，<span class="math inline">\(P_0\rightarrow P_1 = P_0\Rightarrow P_1\)</span>。</p><p>根据以上结论，我们对算法进行逐行剖析。</p><p>设非源点的其他所有点构成的集合为<span class="math inline">\(V=\{Q_1,Q_2,Q_2,...,Q_n\}, P_i\in V\)</span>。那么算法中的<span class="math inline">\(Flag\)</span>数组即用来表示各个点是否在集合<span class="math inline">\(V\)</span>中。算法中的<span class="math inline">\(MinDist\)</span>，表示<span class="math inline">\(MinDist[k]=\min\limits_{j=0,1,2...,i}P_0\rightarrow P_j\Rightarrow P_k\)</span>，其中$ k=1,2,..,n$。算法可以用语言描述如下：</p><p>step1：初始化，<span class="math inline">\(MinDist[k]=\min\limits_{j=0}P_0\rightarrow P_j\Rightarrow Q_k=\min P_0\Rightarrow Q_k\)</span>。<span class="math inline">\(i=0\)</span>。</p><p>step2：当<span class="math inline">\(i=n\)</span>时退出程序。由于<span class="math inline">\(P_{i+1}\in V\)</span>，则<span class="math inline">\(P_{i+1}=Q_m,P_{0}\rightarrow Q_m=\min\limits_{Q_k\in V}MinDist[k]\)</span>。</p><p>setp3：<span class="math inline">\(V=V-P_{i+1}\)</span>，<span class="math inline">\(MinDist[k]=\min(\min\limits_{j=0,1,2...,i}P_0\rightarrow P_j\Rightarrow Q_k,P_0\rightarrow P_{i+1}\Rightarrow Q_k)\)</span><span class="math inline">\(=\min\limits_{j=0,1,2...,i+1}P_0\rightarrow P_j\Rightarrow Q_k=\min(MinDist[k], P_0\rightarrow Q_m\Rightarrow Q_k)\)</span>。<span class="math inline">\(i=i+1\)</span>，转step2。</p></li></ul><hr><p>虽然，上面的分析看着严谨华丽，<strong>但不便于记忆以及快速直观地理解</strong>。记住3个关键词：收录、最小、更新</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 伪码 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span> <span class="hljs-params">(Vertex V)</span> </span>{<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {<br>        V = 未收录顶点中dist的最小者;<br>        <span class="hljs-keyword">if</span> (这样的V不存在)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span> (V的每个邻接点W) {<br>            <span class="hljs-keyword">if</span> (collected[W] == <span class="hljs-literal">false</span>) {<br>                <span class="hljs-keyword">if</span> (dist[V] + E[V, W] &lt; dist[W]) {<br>                    dist[W] = dist[W] + E[V, W];<br>                    path[W] = V;<br>                }<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度分析：上述过程只是伪码描述，屏蔽了一些具体实现细节。根据dist的存储结构不同可以有以下2种实现</p><ul><li>直接扫描所有未收录顶点（较常用）<ul><li>伪码中第4行语句“V = 未收录顶点中dist的最小者”变成一个|V|次的循环</li><li>更新距离时需要扫描所有边，<span class="math inline">\(|E|\)</span>次</li><li>时间复杂度是<span class="math inline">\(O(|V|^2+|E|)\)</span></li><li>对稠密图效果更好</li></ul></li><li>dist存在最小堆中<ul><li>伪码中第4行语句“V = 未收录顶点中dist的最小者”变成一个log|V|的时间复杂度</li><li>每次更新距离的时候，需要对堆进行调整，也是log|V|的时间复杂度</li><li>时间复杂度是<span class="math inline">\(O(|V|\log|V|+|E|\log|V|)=O(|E|\log|V|)\)</span>，（一般边数大于点数）</li><li>对稀疏图更好</li></ul></li></ul></li></ul><h5 id="多源最短路径">多源最短路径</h5><ul><li><p>一种方法是调用|V|次Dijkstra算法。以常用实现方法来说，时间复杂度为<span class="math inline">\(O(|V|^3+|E|\times|V|)\)</span>，对稀疏图更好。</p></li><li><p>Floyd算法</p><p>可以有负权边，但不能有带负权边的回路（这是王道上说的，<strong>但我认为准确地说应该是回路权重之和是负的</strong>）。像下图所示，就没有最短路径。因为一直转圈路径会持续变小。下图摘自王道ppt。</p><p><img src="http://imagehost.vitaminz-image.top/DS-55.png" style="zoom:25%;"></p><p>同样运用了动态规划的思想。</p><p>如果要获得<span class="math inline">\(i\rightarrow j\)</span>的最小距离<span class="math inline">\(MinDist[i\rightarrow j]\)</span>，那么假如路径上有一点<span class="math inline">\(k\)</span>，则<span class="math inline">\(MinDist[i\rightarrow j]=\min\limits_{k=1,2,...,|V|}{MinDist[i\rightarrow k]+MinDist[k\rightarrow j]}\)</span>。这是显然的，其满足最优子结构。</p><p>我们可以这么去考虑，对于点<span class="math inline">\(MinDist[i\rightarrow j]\)</span>，一开始可以假设只有<span class="math inline">\(i,j\)</span>这2个结点，或者说<span class="math inline">\(i,j\)</span> 结点不能通过任何结点中转，那么它们的最短路径就是邻接距离，即<span class="math inline">\(MinDist^0[i\rightarrow j]=Dist[i\rightarrow j]\)</span>。再逐步地往里加结点。</p><p>加入结点1后，即任意两个结点可以通过结点1。</p><p><span class="math inline">\(MinDist^1[i\rightarrow j]=\min(\min\limits_{k=1}({MinDist^0[i\rightarrow k]+MinDist^0[k\rightarrow j]}), MinDist^0[i\rightarrow j])\)</span></p><p>加入结点2后，即任意两个结点可以通过结点1、结点2。</p><p><span class="math inline">\(MinDist^2[i\rightarrow j]=\min(\min\limits_{k=1,2}({MinDist^1[i\rightarrow k]+MinDist^1[k\rightarrow j]}), MinDist^1[i\rightarrow j])\)</span></p><p>依次类推，得到递推式。</p><p><span class="math inline">\(MinDist^{m}[i\rightarrow j]=\min(\min\limits_{k=1,2,...m}({MinDist^{m-1}[i\rightarrow k]+MinDist^{m-1}[k\rightarrow j]}), MinDist^{m-1}[i\rightarrow j])\)</span></p><p>该递推式想说明的事实是，已经得到<span class="math inline">\(MinDist[i\rightarrow j]\)</span>，当加入一个结点后，那么新的最短距离<span class="math inline">\(MinDist'[i\rightarrow j]\)</span>的路径要么有新加入的结点，要么没有。<strong>如果有，那么该距离一定等于【<span class="math inline">\(i\)</span>通过原有的结点到达新结点的最短距离+新结点到达<span class="math inline">\(j\)</span>的最短距离】；如果没有，那就是原来的最短距离。</strong></p><p>下图摘自王道ppt。</p><p><img src="http://imagehost.vitaminz-image.top/DS-54.png" style="zoom:33%;"></p><p>算法伪码如下。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 伪码 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++) {<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; N; j++) {<br>            dist[i][j] = graph[i][j];<br>            path[i][j] = <span class="hljs-number">-1</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; N; k++) {<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++) {<br>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; N; j++) {<br>                <span class="hljs-keyword">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j]) {<br>                    dist[i][j] = dist[i][k] + dist[k][j];<br>                    path[i][j] = k;<br>                }<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度为<span class="math inline">\(O(|V|^3)\)</span>。</p></li></ul><h4 id="最小生成树">最小生成树</h4><p>对于一个带权连通<strong>无向图</strong></p><p>最小生成树(<strong>M</strong>aximum <strong>S</strong>panning <strong>T</strong>ree)：无回路，<span class="math inline">\(V\)</span>个顶点<span class="math inline">\(|V|-1\)</span>条边，是原图的子集，边权之和最小。</p><p>最小生成树不唯一。</p><h5 id="prim算法">Prim算法</h5><p>选点，从一棵小树慢慢的长大。</p><p>这个算法的正确性是显然的，假如得到了一张图的最小生成树，那么若往图中新加一个结点，以及若干条与之相关联的边。那么求整张图的最小生成树，必然是在原来的最小生成树上选择一条最短的边到达新结点。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 伪码 */</span><br><span class="hljs-comment">/* dist数组用于存储整棵树所有结点到它们最近的邻接顶点的距离</span><br><span class="hljs-comment"> parent数组则用于存储树，它的存储方式采用类似于并查集的双亲表示法 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prim</span><span class="hljs-params">(Graph G)</span> </span>{<br>    parent[s] = <span class="hljs-number">-1</span>; <span class="hljs-comment">/* MST = {S} */</span><br>    <span class="hljs-keyword">for</span> (s的每个邻接点W) {<br>        dist[W] = E[s, W];<br>        <span class="hljs-comment">/* 暂且定义所有顶点的父结点都是初始点s */</span><br>        parent[W] = s; <br>    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {<br>        V = <span class="hljs-built_in">findMinDist</span>(G) <span class="hljs-comment">// 未收录顶点中dist的最小者;</span><br>        <span class="hljs-keyword">if</span> (这样的V不存在) <br>            <span class="hljs-keyword">break</span>;<br>        将V收录到MST中: dist[V] = <span class="hljs-number">0</span>;<span class="hljs-comment">// 0为收录标记</span><br>        <span class="hljs-keyword">for</span> (V的每个邻接点W) {<br>            <span class="hljs-keyword">if</span> (dist[W] != <span class="hljs-number">0</span>) {<br>                <span class="hljs-keyword">if</span> (E[V, W] &lt; dist[W]) {<br>                    dist[W] = E[V, W];<br>                    parent[W] = V;<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">if</span> (MST中收的顶点不到|V|个)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-string">"生成树不存在"</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>当第4行语句findMinDist使用顺序扫描的方式，则时间复杂度为<span class="math inline">\(O(|V|^2)\)</span>。</p><p>适合于稠密图</p><h5 id="kruskal算法">Kruskal算法</h5><p>森林合并称一棵树，星星之火可以燎原</p><p>这个算法的正确性同样显然。若有2个图的最小生成树，然后再将2张图的选择若干结点相连（添加边的2个点不在同一张图上），那么新图的最小生成树，必然是2个最小生成树的基础上，选择权值最小的使他们连通的边。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 伪码 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Kruskal</span> <span class="hljs-params">(Graph G)</span> </span>{<br>    MST = {};<br>    <span class="hljs-keyword">while</span> (MST中不到|V|<span class="hljs-number">-1</span>条边 &amp;&amp; E中还有边) {<br>        从E中取一条权重最小的边E[V, W]; <span class="hljs-comment">/* 最小堆 */</span><br>        将E[V, W]从E中删除;<br>        <span class="hljs-keyword">if</span> (E[V, W]不再MST中构成回路) {<span class="hljs-comment">/* 并查集, 由于是无向图 */</span><br>            将E[V, W]加入MST;   <span class="hljs-comment">/* 顶点在同一个集合里就是回路 */</span><br>        }<br>        <span class="hljs-keyword">else</span>{<br>            将E[V, W]从E中删除;<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (MST中收的顶点不到 |V|<span class="hljs-number">-1</span> 条边)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-string">"生成树不存在"</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度为<span class="math inline">\(O(|E|\log |E|)\)</span>，当<span class="math inline">\(|E|\)</span>较小时其值近似于<span class="math inline">\(|V|\)</span>，时间复杂度近似为<span class="math inline">\(O(|V|\log |V|)\)</span>。</p><p>适合于稀疏图。</p><h4 id="dag">DAG</h4><p>DAG，即有向无环图</p><h5 id="dag描述表达式">DAG描述表达式</h5><p>如下图所示，就是将表达式树合并重复部分，变成一个最简的有向无环图。下图摘自王道ppt</p><p><img src="http://imagehost.vitaminz-image.top/DS-49.png" style="zoom: 50%;"></p><p><img src="http://imagehost.vitaminz-image.top/DS-50.png" style="zoom: 50%;"></p><p>以下是王道ppt给出的做题步骤。个人认为操作数不重复以及分层的想法可以借鉴。</p><p><img src="http://imagehost.vitaminz-image.top/DS-48.png" style="zoom: 60%;"></p><h5 id="aov网拓扑排序">AOV网：拓扑排序</h5><p>顶点表示活动的网</p><p>先修课程问题</p><p>每次删除入度为0，拓扑排序不唯一。</p><p>以下算法亦可以用来判断该图是否为DAG</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 伪码 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">topSort</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (cnt = <span class="hljs-number">0</span>; cnt &lt; |V|; cnt++) {<br>        V = 未输出的入度为<span class="hljs-number">0</span>的顶点;<br>        <span class="hljs-keyword">if</span> (这样的V不存在) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-string">"图中有回路"</span>;<br>            <span class="hljs-keyword">break</span>;<br>        }<br>        输出V，或者记录V的输出序号;<br>        <span class="hljs-keyword">for</span> (V的每个邻接点W)<br>            InDegree[W]--;<br>    }<br>}<br><span class="hljs-comment">/* 细化实现 邻接表 时间复杂度为 O(|V|+|E|) */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">topSort</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (每个顶点V) {<br>        <span class="hljs-keyword">if</span> (InDegree[V] == <span class="hljs-number">0</span>) <br>            <span class="hljs-built_in">Enqueue</span>(V, Q);<span class="hljs-comment">// 不一定使用队列，可以是其他容器</span><br>    }<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isempty</span>(Q)) {<br>        V = <span class="hljs-built_in">Dequeue</span>(Q);<br>        输出V，或者记录V的输出序号;<br>        v_num++;<br>        <span class="hljs-keyword">for</span> (V的每个邻接点W) {<br>            <span class="hljs-keyword">if</span> (--InDegree[W] == <span class="hljs-number">0</span>) {<br>                <span class="hljs-built_in">Enqueue</span>(W, Q);<br>            }<br>        }<br>    }<br>    <span class="hljs-comment">/* 如果出现环的话说明在没删完顶点的时候，剩余的顶点入度都不是0 */</span><br>    <span class="hljs-keyword">if</span> (v_num != |V|) {<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">"图中有回路"</span>;<br>        <span class="hljs-keyword">break</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>逆拓扑排序：每次删除出度为0，逆邻接表。</p><p>使用DFS完成逆拓扑排序</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 伪码 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Vertix V)</span> </span>{<br>    visited[V] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (V的每个邻接点W) {<br>        <span class="hljs-keyword">if</span> (!visited[W])<br>            <span class="hljs-built_in">DFS</span>(W);<br>    }<br>    输出V，或者记录V的输出序号;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="aoe网络关键路径">AOE网络：关键路径</h5><p>边表示活动，点表示事件</p><p>具有最大路径长度的路径（路径上的权值相加）称为<strong>关键路径</strong>，关键路径上的活动叫<strong>关键活动</strong>。</p><p>根据拓扑排序序列计算最早时刻EET，EET=max(入度的最早时刻+持续时间)，开始事件最早时刻为0。</p><p>根据逆拓扑排序序列计算最晚时刻LET，LET=min(出度的最晚时刻-持续时间)，结束事件最晚时刻=最早时刻。</p><p>最早时刻和最晚时刻的区别发生在，并行事件中，一些事件的执行是由灵活空间的，那么自然就有最早和最晚的区别。而这个灵活空间就是机动时间。</p><p>下图摘自《软件工程导论》，粗箭头有点不太明显，仔细看。</p><p><img src="http://imagehost.vitaminz-image.top/DS-57.png" style="zoom: 67%;"></p><p>以下是王道给出的写法。王道的写法非常不直观。比上图多的是所谓的活动的最早时间、最晚时间。活动的最早时间是活动的左顶点的最早时刻，而活动的最晚时间则是右顶点的最迟时刻减去持续时间，所谓的时间余量是指机动时间，而余量时间就是活动的最早时刻-最晚时刻，也就等于右顶点的最晚时刻-持续时间-左顶点的最早时刻。</p><p><img src="http://imagehost.vitaminz-image.top/DS-58.png" style="zoom:50%;"></p><p>4个结论：</p><ul><li>关键活动耗时增加，则整个工程工期增长</li><li>缩短关键活动时间，可以缩短整个工程的工期</li><li>当缩短一定程度时，关键活动可能变成非关键活动。</li><li>可能存在多条关键路径，因此需要改变所有关键路径或其交集</li></ul><h2 id="排序-1">排序</h2><h3 id="简单排序">简单排序</h3><h4 id="冒泡排序">冒泡排序</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span> <span class="hljs-params">(ElemType* Arr, <span class="hljs-type">int</span> N)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) {<br>            <span class="hljs-keyword">if</span> (Arr[j] &gt; Arr[j+<span class="hljs-number">1</span>]) {<br>                flag = <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">swap</span>(Arr[j], Arr[j+<span class="hljs-number">1</span>]);<br>            }<br>        }<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度：最好情况，<span class="math inline">\(O(N)\)</span>，最坏情况，<span class="math inline">\(O(N^2)\)</span></p><p>适用于链表和数组</p><h4 id="插入排序">插入排序</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertionSort</span> <span class="hljs-params">(ElemType* Arr, <span class="hljs-type">int</span> N)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) {<br>        <span class="hljs-keyword">if</span> (Arr[i<span class="hljs-number">-1</span>] &gt; Arr[i]) {<br>            <span class="hljs-type">int</span> j;<br>            ElemType tmp = Arr[i];<br>            <span class="hljs-keyword">for</span> (j = i; (j &gt;= <span class="hljs-number">1</span>) &amp;&amp; (tmp &lt; Arr[j<span class="hljs-number">-1</span>]); j--) {<br>                Arr[j] = Arr[j<span class="hljs-number">-1</span>];<br>            }<br>            Arr[j] = tmp;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度：最好情况，<span class="math inline">\(O(N)\)</span>，最坏情况，<span class="math inline">\(O(N^2)\)</span></p><p>适用于链表和数组</p><h4 id="折半插入排序">折半插入排序</h4><p>由于插入的数据段是有序，固可以用折半扫描的方式，插入到合适位置。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertionBinSort</span><span class="hljs-params">(ElemType* Arr, <span class="hljs-type">int</span> N)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) {<br>        <span class="hljs-keyword">if</span> (Arr[i<span class="hljs-number">-1</span>] &gt; Arr[i]) {<br>            ElemType tmp = Arr[i];<br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> mid;<br>            <span class="hljs-keyword">while</span> (l &lt;= r) {<br>                mid = (l + r) / <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span> (tmp &gt;= Arr[mid])<br>                    l = mid + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    r = mid - <span class="hljs-number">1</span>;<br>            }<br>            <span class="hljs-type">int</span> j;<br>            <span class="hljs-keyword">for</span> (j = i; j &gt; l; j--){<br>                Arr[j] = Arr[j<span class="hljs-number">-1</span>];<br>            }<br>            Arr[j] = tmp;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>折半插入排序只是减少了比较次数，约为，但元素的移动次数并没有变，因此总的时间复杂度仍未<span class="math inline">\(O(n^2)\)</span></p><h4 id="时间复杂度下界">时间复杂度下界</h4><p>逆序对，对于下标<span class="math inline">\(i\lt j\)</span>，有<span class="math inline">\(Array[i]&gt;Array[j]\)</span>，则称其为1个逆序对。</p><p>插入排序：<span class="math inline">\(O(N+I)\)</span>，<span class="math inline">\(I\)</span> 表示逆序对数</p><p>冒泡排序和插入排序都是每次交换仅消除1个逆序对。</p><p>一个序列逆序对数量最少是<span class="math inline">\(0\)</span>，最多是<span class="math inline">\(\frac{(N-1)N}{2}\)</span>，平均是<span class="math inline">\(\frac{(N-1)N}{4}\)</span>，</p><p>因此仅以交换<strong>相邻</strong>两个元素来排序的算法，平均时间复杂度为<span class="math inline">\(O(n^2)\)</span>。</p><h3 id="希尔排序">希尔排序</h3><p>升级版的插入排序</p><p>定义的增量序列最好互质</p><p>Hibbard增量序列，<span class="math inline">\(D_k=2^k-1\)</span></p><p>Sedgewick增量序列，<span class="math inline">\(4^i-3\times 2^i+1\)</span></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellSort</span> <span class="hljs-params">(ElemType* Arr, <span class="hljs-type">int</span> N)</span> </span>{<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> DeltaSize = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> Delta[DeltaSize] = {<span class="hljs-number">109</span>, <span class="hljs-number">41</span>, <span class="hljs-number">19</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>};<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">0</span>; d &lt; DeltaSize; d++) {<br>        <span class="hljs-comment">/* 就是把插入排序的所有1都改成Delta[d] */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = Delta[d]; i &lt; N; i += Delta[d]) {<br>            <span class="hljs-keyword">if</span> (Arr[i-Delta[d]] &gt; Arr[i]) {<br>                <span class="hljs-type">int</span> j;<br>                ElemType tmp = Arr[i];<br>                <span class="hljs-keyword">for</span> (j = i; (j &gt;= Delta[d]) &amp;&amp; (tmp &lt; Arr[j-Delta[d]]); j -= Delta[d]) {<br>                    Arr[j] = Arr[j-Delta[d]];<br>                }<br>                Arr[j] = tmp;<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="选择排序">选择排序</h3><p><span class="math inline">\(T=\Theta(n^2)\)</span>，稳定的慢。</p><p>但其也有优点，简单选择排序的移动次数只有<span class="math inline">\(O(n)\)</span>，尽管其比较次数是<span class="math inline">\(O(n^2)\)</span></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinElem</span><span class="hljs-params">(ElemType* Arr, <span class="hljs-type">int</span> beg, <span class="hljs-type">int</span> end)</span> </span>{<br>    ElemType MinElem = Arr[beg];<br>    <span class="hljs-type">int</span> MinElemPos = beg;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = beg + <span class="hljs-number">1</span>; i &lt; end; i++) {<br>        <span class="hljs-keyword">if</span> (Arr[i] &lt; MinElem) {<br>            MinElem = Arr[i];<br>            MinElemPos = i;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> MinElemPos;<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectionSort</span> <span class="hljs-params">(ElemType* Arr, <span class="hljs-type">int</span> N)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {<br>        <span class="hljs-type">int</span> MinElemPos = <span class="hljs-built_in">findMinElem</span>(Arr, i, N);<br>        <span class="hljs-built_in">swap</span>(Arr[i], Arr[MinElemPos]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="堆排序">堆排序</h4><p>选择排序的改进：最大堆，每次“删除”最大元素（不是实际地删除，是将它放在队尾，并将队列长度减1）。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">percdown</span> <span class="hljs-params">(ElemType* Arr, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> N)</span> </span>{<br>    <span class="hljs-type">int</span> parent, child;<br>    ElemType Tmp = Arr[pos];<br>    <span class="hljs-keyword">for</span> (parent = pos; (parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) &lt; N; parent = child){<br>        child = parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">/* 选择孩子的较大者 */</span><br>        <span class="hljs-keyword">if</span> (child &lt; N<span class="hljs-number">-1</span> &amp;&amp; Arr[child] &lt; Arr[child+<span class="hljs-number">1</span>])<br>            child++;<br>        <span class="hljs-comment">/* 不是Arr[parent] &lt; Arr[child]! */</span><br>        <span class="hljs-keyword">if</span> (Tmp &lt; Arr[child])<br>            Arr[parent] = Arr[child];<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">break</span>;<br>    }<br>    Arr[parent] = Tmp;<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildHeap</span> <span class="hljs-params">(ElemType* Arr, <span class="hljs-type">int</span> N)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (N - <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>        <span class="hljs-built_in">percdown</span>(Arr, i, N);<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span> <span class="hljs-params">(ElemType* Arr, <span class="hljs-type">int</span> N)</span> </span>{<br>    <span class="hljs-built_in">buildHeap</span>(Arr, N);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = N - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {<br>        <span class="hljs-built_in">swap</span>(Arr[<span class="hljs-number">0</span>], Arr[i]);<br>        <span class="hljs-built_in">percdown</span>(Arr, <span class="hljs-number">0</span>, i);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="快速排序">快速排序</h3><p>取主元，其他元素分两边</p><p>怎么取主元？怎么分两边？</p><ul><li><p>选主元</p><ul><li>第一个元素，实际效果差，但考研主要以该种方法为主</li><li>随机数，花时间</li><li>头、中、尾的中位数，实际情况种常用，编程采用该种</li></ul></li><li><p>分两边</p><ul><li><p>分两边的方法有很多变种，浙大mooc和王道上介绍的不同，以下是王道版本。取第一个数为主元，然后<strong>右指针</strong>往左移，直到碰到<strong>比主元小</strong>的数（<strong>等于也要移动</strong>），赋值到左指针指向的数；左指针右移，直到碰到<strong>比主元大</strong>的数，赋值到右指针指向的数。重复以上操作，直至左右指针相遇。该算法<strong>有很多细节</strong>需要注意。</p><p><img src="http://imagehost.vitaminz-image.top/DS-64.png" style="zoom: 50%;"></p></li><li><p><strong>有相等的元素怎么办？</strong></p><p>上述说法的黑体字表示等于的情况也必须移动，这是<strong>重要的</strong>。考虑极端情况，如果一个序列全部相等，等于的时候不移动，那么会造成右边的元素赋值到左边，左边的元素赋值到右边，然后每次重复执行该操作，就是一步也不动，左右指针永远无法相遇，陷入死循环。以下是王道的写法。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (l &lt; r) {<br>    <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; Arr[r] &gt;= Pivot)<br>        r--;<br>    Arr[l] = Arr[r];<br>    <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; Arr[l] &lt;= Pivot)<br>        l++;<br>    Arr[r] = Arr[l];<br>}<br></code></pre></td></tr></tbody></table></figure><p>但这样的做法也有个坏处那就是会造成不均衡，比如碰到一连串的相等值，一个指针会一直往一个方向移动，使得左右子序列长度严重不等，降低效率。浙大版本的交换模式，可以减轻这样的情况。</p><p>不过也可以采用我写的一个版本，即每次比较时，先移动指针，再看对不对，这样保证了 l 和 r 始终是在移动的，并且遇到一连串相等元素有利于均衡移动。不过需要注意的是，这样写 l, r 的初始值需是左闭右开区间。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (l &lt; r) {<br>    <span class="hljs-comment">/* 先移动再判断，可以消除遇到相等元素不动而陷入死循环的情况</span><br><span class="hljs-comment">    并且也能使左右指针移动地更加均衡 */</span><br>    <span class="hljs-keyword">while</span> (l &lt; --r &amp;&amp; Arr[r] &gt; Pivot);<br>    Arr[l] = Arr[r];<br>    <span class="hljs-keyword">while</span> (++l &lt; r &amp;&amp; Arr[l] &lt; Pivot);<br>    Arr[r] = Arr[l];<br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p><strong>可不可以先移动左指针？</strong></p><p>这取决于主元一开始放的位置，若采用上述写法，不管是王道写法还是我的写法，都会导致最后的序列出现2个主元，<strong>因此上述写法是不可以的</strong>。</p></li><li><p><strong>最后返回的位置是 l 还是 r ?</strong></p><p>如果采用王道写法，先判断再移动的方式，那么不管是 l 还是 r 都是可以的。但<strong>采用先移动再判断的方法，应当返回 r !</strong></p></li><li><p><strong>以上都是快排的各种细节问题，稍有不慎，快排将变错排、慢排、死循环排！血泪教训。</strong></p></li></ul></li><li><p>小规模数据时，用简单排序</p></li></ul><p>完整实现</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setMedianPivot</span><span class="hljs-params">(ElemType* Arr, <span class="hljs-type">int</span> beg, <span class="hljs-type">int</span> end)</span> </span>{<br>    <span class="hljs-comment">/* 左闭右开 */</span><br>    end--;<br>    <span class="hljs-type">int</span> mid = (beg + end) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> ((Arr[mid] &lt;= Arr[end] &amp;&amp; Arr[mid] &gt;= Arr[beg]) || (Arr[mid] &lt;= Arr[beg] &amp;&amp; Arr[mid] &gt;= Arr[end]))<br>        <span class="hljs-built_in">swap</span>(Arr[mid], Arr[beg]);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((Arr[end] &lt;= Arr[mid] &amp;&amp; Arr[end] &gt;= Arr[beg]) || (Arr[end] &lt;= Arr[beg] &amp;&amp; Arr[end] &gt;= Arr[mid]))<br>        <span class="hljs-built_in">swap</span>(Arr[end], Arr[beg]);<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(ElemType* Arr, <span class="hljs-type">int</span> beg, <span class="hljs-type">int</span> end)</span> </span>{<br>    <span class="hljs-built_in">setMedianPivot</span>(Arr, beg, end);<br>    ElemType Pivot = Arr[beg];<br>    <span class="hljs-comment">/* 左闭右开区间 */</span><br>    <span class="hljs-type">int</span> l = beg, r = end;<br>    <span class="hljs-keyword">while</span> (l &lt; r) {<br>        <span class="hljs-comment">/* 先移动再判断，可以消除遇到相等元素不动而陷入死循环的情况</span><br><span class="hljs-comment">    并且也能使左右指针移动地更加均衡 */</span><br>        <span class="hljs-keyword">while</span> (l &lt; --r &amp;&amp; Arr[r] &gt; Pivot);<br>        Arr[l] = Arr[r];<br>        <span class="hljs-keyword">while</span> (++l &lt; r &amp;&amp; Arr[l] &lt; Pivot);<br>        Arr[r] = Arr[l];<br>    }<br>    <span class="hljs-comment">/* 是r，不是l */</span><br>    Arr[r] = Pivot;<br>    <span class="hljs-keyword">return</span> r;<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSortAux</span><span class="hljs-params">(ElemType* Arr, <span class="hljs-type">int</span> beg, <span class="hljs-type">int</span> end)</span> </span>{<br>    <span class="hljs-keyword">if</span> (beg + <span class="hljs-number">1</span> &gt;= end)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> PivotPos = <span class="hljs-built_in">partition</span>(Arr, beg, end);<br>    <span class="hljs-built_in">quickSortAux</span>(Arr, beg, PivotPos);<br>    <span class="hljs-built_in">quickSortAux</span>(Arr, PivotPos+<span class="hljs-number">1</span>, end);<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(ElemType* Arr, <span class="hljs-type">int</span> N)</span> </span>{<br>    <span class="hljs-built_in">quickSortAux</span>(Arr, <span class="hljs-number">0</span>, N);<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="归并排序">归并排序</h3><p>2个有序序列的归并</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 复制数组Arr2到Arr1中 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copyArray</span> <span class="hljs-params">(ElemType* Arr1, ElemType* Arr2, <span class="hljs-type">int</span> N)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        Arr1[i] = Arr2[i];<br>}<br><span class="hljs-comment">/* 合并2个有序序列，左闭右开区间 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(ElemType* Arr, ElemType* TmpArr, <span class="hljs-type">int</span> beg, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> end)</span> </span>{<br>    <span class="hljs-type">int</span> i = beg, j = mid, k = beg;<br>    <span class="hljs-keyword">while</span> (i &lt; mid &amp;&amp; j &lt; end) {<br>        <span class="hljs-keyword">if</span> (Arr[i] &lt;= Arr[j])<br>            TmpArr[k++] = Arr[i++];<br>        <span class="hljs-keyword">else</span><br>            TmpArr[k++] = Arr[j++];<br>    }<br>    <span class="hljs-keyword">while</span> (i &lt; mid)<br>        TmpArr[k++] = Arr[i++];<br>    <span class="hljs-keyword">while</span> (j &lt; end)<br>        TmpArr[k++] = Arr[j++];<br>    <span class="hljs-comment">/* 别忘了复制回去 */</span><br>    <span class="hljs-built_in">copyArray</span>(Arr + beg, TmpArr + beg, end - beg);<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li><p>递归实现</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 归并接口 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSortAux</span><span class="hljs-params">(ElemType* Arr, ElemType* TmpArr, <span class="hljs-type">int</span> beg, <span class="hljs-type">int</span> end)</span> </span>{<br>    <span class="hljs-comment">/* 左闭右开区间 */</span><br>    <span class="hljs-keyword">if</span> (beg + <span class="hljs-number">1</span> == end)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = (beg + end) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">mergeSortAux</span>(Arr, TmpArr, beg, mid);<br>    <span class="hljs-built_in">mergeSortAux</span>(Arr, TmpArr, mid, end);<br>    <span class="hljs-built_in">merge</span>(Arr, TmpArr, beg, mid, end);<br>}<br><br><span class="hljs-comment">/* 递归版本归并排序 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(ElemType* Arr, <span class="hljs-type">int</span> N)</span> </span>{<br>    <span class="hljs-comment">/* 在外部定义TmpArr，有利于避免频繁释放开辟空间 */</span><br>    ElemType *TmpArr = <span class="hljs-keyword">new</span> ElemType[N];<br>    <span class="hljs-built_in">mergeSortAux</span>(Arr, TmpArr, <span class="hljs-number">0</span>, N);<br>    <span class="hljs-keyword">delete</span>[] TmpArr;<br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p>非递归实现</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 循环版本归并排序 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSortLoop</span><span class="hljs-params">(ElemType* Arr, <span class="hljs-type">int</span> N)</span> </span>{<br>    ElemType* TmpArr = <span class="hljs-keyword">new</span> ElemType[N];<br>    <span class="hljs-type">int</span> d, i;<br>    <span class="hljs-keyword">for</span> (d = <span class="hljs-number">1</span>; d &lt;= N; d *= <span class="hljs-number">2</span>) {<br>        <span class="hljs-comment">/* 也有其他写法，每个间隔做了2次赋值，其实比较浪费</span><br><span class="hljs-comment">        Arr 和 TmpArr 可以来回赋值，为了更高的可读性，还是采用该写法 */</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N - <span class="hljs-number">2</span> * d; i += <span class="hljs-number">2</span> * d) {<br>            <span class="hljs-built_in">merge</span>(Arr, TmpArr, i, i + d, i + <span class="hljs-number">2</span> * d);<br>        }<br>        <span class="hljs-keyword">if</span> (i + d &lt; N)<br>            <span class="hljs-built_in">merge</span>(Arr, TmpArr, i, i + d, N);<br>    }<br>    <span class="hljs-keyword">delete</span>[] TmpArr;<br>}<br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="基数排序">基数排序</h3><p>桶排序：将所有可能值，设置成1个1个桶，然后再往里填入即可。</p><p>基数排序是将数据拆成少数的几个基数构成，然后将这些基数作为桶。</p><p>如下图所示（摘自浙大mooc），采用次位优先（<strong>L</strong>east <strong>S</strong>ignificant <strong>D</strong>igit）的方法。</p><p>基本思想是，先比较优先级最低的位次（比如我们比较整数大小时，先从最高位看起，最后才是末位，那么整数中优先级从低到高则是末尾到高位）。第1次操作，根据整数的个位放入桶中；第2次操作则是，<strong>从小到大</strong>，一个一个从桶中按顺序取出数据，按照十位放到新的桶中，<strong>注意取下一个桶的数前要先把上一个桶按顺序全部取完</strong>。</p><p>正确性需要稍微解释：第1次操作后，同1个桶中的数据个位相同，因此第2次操作时，同一个桶中的数据取出按照十位放入各个桶中后，再取下一个桶时，下一个桶的某个数据十位和上一个桶的某个数据十位若相同，则下一个桶的数据将排在上一个桶的后面，这保证了正确性。因为下一个桶的个位要比上一个桶大，十位相同的话自然是下一个桶在后，上一个桶在前。</p><p>更一般的解释：第 <span class="math inline">\(i\)</span> 次操作时，若保证<strong>每个桶在第 <span class="math inline">\(i-1\)</span> 位及以前保持有序</strong>，且<strong>不同的桶在第 <span class="math inline">\(i-1\)</span> 位及以前也保持有序</strong>（即桶1的数在第 <span class="math inline">\(i-1\)</span> 位及以前小于桶2的数）；第 <span class="math inline">\(i+1\)</span> 次操作时，按序取出1个桶中所有数据，放入下一轮桶中时，同1个桶第 <span class="math inline">\(i\)</span> 位相同，而第 <span class="math inline">\(i-1\)</span> 位及以前有序放入，则保证了第 <span class="math inline">\(i\)</span> 位及以前有序；而不同桶间自然是第 <span class="math inline">\(i\)</span> 位及以前有序（不管第<span class="math inline">\(i-1\)</span>位，第<span class="math inline">\(i\)</span>位大则达）。</p><p><img src="http://imagehost.vitaminz-image.top/DS-60.png" style="zoom:50%;"></p><p>多关键字</p><p>主位优先（<strong>M</strong>ost <strong>S</strong>ignificant <strong>D</strong>igit）</p><h3 id="内部排序的比较">内部排序的比较</h3><p>以上介绍的所有排序算法，<strong>除了基数排序、桶排序</strong>，都是<strong>基于比较的排序</strong>。</p><p>基于比较的排序有结论：</p><ul><li><p>在最坏的情况下，任何基于比较的排序至少需要<span class="math inline">\(\log_2(n!)=\Omega(n\log_2n)\)</span>次比较。</p><ul><li><p>基于排序的实质，其实是在序列<span class="math inline">\(n!\)</span>种排序可能中，寻找正确的可能。根据排列组合，假如一个序列有<span class="math inline">\(n\)</span>个元素，<span class="math inline">\(m\)</span>个元素的相对位置已经确定，则可能的排列有<span class="math inline">\(\frac{n!}{m!}\)</span> 中。而每次比较，可以确定其中2个元素的相对位置，因此每次比较后，可能性从原来的<span class="math inline">\(n!\)</span>，缩减为原来的一半。最坏的情况就是，一直缩减，直至只有1种可能为止。即<span class="math inline">\(\lceil \log_2n! \rceil\)</span>次。这种结构是一种决策树，如下图所示，摘自算法导论。</p><p><img src="http://imagehost.vitaminz-image.top/DS-61.png" style="zoom: 67%;"></p></li></ul></li></ul><p><strong>稳定性</strong>：排序前后元素相等的相对位置不发生改变。</p><p>归并的稳定性有点不太显然，考虑假如是2个块合并，那么当第一个块的指针和第二个块的指针走到相同元素时，使用判断语句“若第一个块的值小于等于第二个块的值，则输出”，便保证了2个块的相等值，总是第1个块先输出。</p><p>快排辅助空间是堆栈的个数，显然最少的个数就是树高<span class="math inline">\(O(\log_2n)\)</span>，最坏的情况是，每次都分配到极端，复杂度是<span class="math inline">\(O(n)\)</span>。</p><p><img src="http://imagehost.vitaminz-image.top/DS-62.png" style="zoom:50%;"></p><p>以下是实验结果。可以发现，快排是最快的。<strong>快排在平均性能上是所有内部排序中最优的</strong>。</p><p>在实际编程中，出现了1个Bug。为了提高计时准确率，每个算法都执行了1000次。但第2次及以后的执行，没有对数组进行初始化，使得后面的排序数组已经是有序的了，结果中，冒泡排序、插入排序、希尔排序比其他算法快得多。这是因为，<strong>在有序序列中，冒泡排序、插入排序是线性时间复杂度！</strong></p><p><img src="http://imagehost.vitaminz-image.top/DS-63.png" style="zoom:50%;"></p><h3 id="表排序">表排序</h3><p>间接排序：不移动数据，移动指针</p><p>物理排序，N个数字的</p><h3 id="外部排序多路归并">外部排序：多路归并</h3><h4 id="一般过程">一般过程</h4><ol type="1"><li><p>构造初始归并段</p><p><img src="http://imagehost.vitaminz-image.top/DS-71.png"></p><p><img src="http://imagehost.vitaminz-image.top/DS-70.png" style="zoom:50%;"></p></li><li><p>多路归并</p><p><strong>一个归并段对应一个缓冲区</strong></p><p><img src="http://imagehost.vitaminz-image.top/DS-70.png" style="zoom:50%;"></p></li></ol><p>归并次数：如下图所示，一课k叉归并树的归并次数为<span class="math inline">\(h-1\)</span>，<span class="math inline">\(h\)</span>是树高。则<span class="math inline">\(k^{h-1}=叶子结点数=初始归并段=n\)</span>。因此<span class="math inline">\(归并次数=h-1=\lceil\log_k n\rceil\)</span>。</p><p><img src="http://imagehost.vitaminz-image.top/DS-73.png" style="zoom:50%;"></p><p>磁盘读写次数=读次数+写次数=<span class="math inline">\(2n\lceil\log_k n\rceil\)</span>，</p><p>k路平衡归并：1. 最多只能有k个段归并为1个；2. 每1趟归并中，若有m个归并段参与归并，则经过这一趟处理得到<span class="math inline">\(\lceil m/k \rceil\)</span>个新的归并段。</p><p><strong>外部排序时间开销</strong> = 读写外存时间+内部排序时间所需+内部归并所需时间。</p><p>以下内容通过败者树、置换-选择排序、最佳归并树分别优化内部归并时间、初始归并段长度、读写外存次数。</p><h4 id="败者树">败者树</h4><p>内部归并的优化。原先是顺序扫描各个队首元素取最小者。</p><p>败者树要和堆区分。败者树是每个分支结点虽然是失败者，但它必然比其中的一个孩子强。这和堆不一样，堆是要比2个孩子都强。如下图所示，败者树的每个叶结点，为当前各个归并段的队首。而分支结点记录的是各个归并段队首胜者。在完成一轮比拼后，如下图所示，胜者为3号归并段。</p><p><img src="http://imagehost.vitaminz-image.top/DS-65.png" style="zoom: 50%;"></p><p>然后从胜者的归并段中，取出下一个原色。不断地和父结点进行比拼。</p><p><img src="http://imagehost.vitaminz-image.top/DS-66.png" style="zoom:50%;"></p><p>这里的正确性需要稍微解释：</p><p>首先，如下图所示，选择某一败者结点，<strong>若败者结点来源于败者的某一子树，那么该败者结点与该子树构成一个败者树</strong>。这个结论是显然的，因为该败者正是通过与其来源的子树遴选上来的胜者。也可以用另一种眼光看他，<strong>整个比拼的过程可以看作如下图所示的2棵败者树的合并</strong>。</p><p><img src="http://imagehost.vitaminz-image.top/DS-69.png" style="zoom:50%;"></p><p>新结点的插入其实和初始构建败者树是相同的原理，它区别在于原来的败者树，它将线程的子树拆成败者树。如下图所示，已经比较直观了。</p><p><img src="http://imagehost.vitaminz-image.top/DS-68.png" style="zoom:50%;"></p><h4 id="置换-选择排序">置换-选择排序</h4><p>优化初始归并段长度，每个归并段长度不等。</p><p>懒得解释，看看图差不多就懂了。</p><p><img src="http://imagehost.vitaminz-image.top/DS-75.png" style="zoom: 33%;"></p><p><img src="http://imagehost.vitaminz-image.top/DS-74.png" style="zoom: 33%;"></p><h4 id="最佳归并树">最佳归并树</h4><p>优化磁盘读写次数</p><p>初始归并段的大小不同</p><p>磁盘读/写（I/O）次数 = WPL * 2</p><p>k叉哈夫曼树，<strong>段不足要添加长度为0的虚段</strong>。</p><p><img src="http://imagehost.vitaminz-image.top/DS-76.png" style="zoom:50%;"></p><p>如何知道要添加多少个虚段？</p><p>对于一个<span class="math inline">\(k\)</span>叉哈夫曼树有点数等式：<span class="math inline">\(n=n_k+n_0\)</span>。边数等式：<span class="math inline">\(kn_k=n-1\)</span>。则<span class="math inline">\(n_k=\frac{n_0-1}{k-1}\)</span>。由于<span class="math inline">\(n_k\)</span>是整数，如果整除，则不需补充，否则需补充的结点为<span class="math inline">\((k-1)-((n_0-1) \mod{(k-1)})\)</span>个虚段。</p><h2 id="串">串</h2><h3 id="模式匹配">模式匹配</h3><h4 id="kmp算法">KMP算法</h4>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文速读&lt;一&gt;：关系抽取与提示学习</title>
    <link href="/2022/07/16/kg/lun-wen-su-du-1-guan-xi-chou-qu/"/>
    <url>/2022/07/16/kg/lun-wen-su-du-1-guan-xi-chou-qu/</url>
    
    <content type="html"><![CDATA[<h1 id="论文速读关系抽取与提示学习">论文速读&lt;一&gt;：关系抽取与提示学习</h1><p>论文速读系列为对论文的核心思想进行快速抓取，仅记录论文的Key Idea。本期为论文速读系列的第一期，选取了5篇近期知识图谱领域的关系抽取相关论文。</p><h2 id="key-idea">Key Idea</h2><h3 id="enriching-pre-trained-language-model-with-entity-information-for-relation-classification.1"><em>Enriching pre-trained language model with entity information for relation classification.</em><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Shanchan Wu and Yifan He. 2019. Enriching pre-trained language model with entity information for relation classification. In Proceedings of the 28th ACM international conference on information and knowledge management, pages 2361–2364.](https://dl.acm.org/doi/abs/10.1145/3357384.3358119)">[1]</span></a></sup></h3><p><img src="https://imagehost.vitaminz-image.top/SEofZJU-1.png"></p><p>R-Bert模型的框架如上图所示，其主要思路就是对每个句子的关系的头部放一个分类头，并在2个实体出使用特殊标记，放进预训练好后的Bert中，在输出中，实体所对应的embedding做一个平均值，和分类头的embedding分别经过3个MLP，最后做一个拼接，输出到softmax中去，进行分类。</p><h3 id="relation-classification-with-entity-type-restriction.">Relation classification with entity type restriction.</h3><p><img src="https://imagehost.vitaminz-image.top/SEofZJU-2.png"></p><p>该论文事实上是提出了一个算法无关的流程。</p><p>传统的关系抽取是将句子、实体以及实体类型一起丢进一个分类器中，然后输出关系的类别。但假如根据实体的类型可以一定程度上的筛掉一些不可能的关系。因此区别于传统的做法，它首先将实体丢进一个分类器，然后获得其类别之后，根据实体的类型去训练专用的分类器，最后句子一起输入到这个专用分类器中，输出对应的类别。</p><h3 id="ptr-prompt-tuning-with-rules-for-text-classification.">Ptr: Prompt tuning with rules for text classification.</h3><p><img src="https://imagehost.vitaminz-image.top/SEofZJU-3.png"></p><p>该论文提出了一种提示学习的方法对文本进行分类。提示学习就是在Fine Tuning的时候加一个模板化的提示，这样可以使得原问题更贴近于自然语言处理的问题，从而更贴合预训练的自然语言模型。</p><p>该论文的模式来源于推理规则，他在Fine Tuning时，在句子的结尾增添提示。给出句子的实体，但对实体的类型和实体间的关系做一个mask。这样可以使得模型能将实体与对应的类型结合起来，推理出他们之间的关系。</p><h3 id="summarization-as-indirect-supervision-for-relation-extraction">Summarization as Indirect Supervision for Relation Extraction</h3><p><img src="https://imagehost.vitaminz-image.top/SEofZJU-4.png"></p><p>该论文将摘要模型用于关系抽取。</p><p>若想要将摘要模型应用在句子的关系抽取上，需要将关系抽取问题转化为摘要问题。直觉上来讲，上游模型的特点和下游任务的关系月紧密，它的效果也会越好。</p><p>和通常的提示学习想法类似，它也是对原句子进行模板化改造，只不过将句子转换为一个段落而已。如上图所示，所谓的段落就是，加上“主语是。。。”，“谓语是。。。”这样的信息。</p><p>由于摘要模型输入是一个段落，输出是一个句子，而不是一个标签。因此输出的标签也应当做一个改造。改造的方式也很简单，比如"city of birth"就改在为"subj was born in the city obj"。需要注意的是，主语放在句子开头，宾语放在句子结尾。这是方便后面的预测。</p><p>其预测过程是构造一棵字典树，由于所有的句子主语放在开头，所以他们有同一个根结点。从根据结点出发，每次遇到一个分叉就使用decoder进行预测，给出每个分叉的概率。最后每个类别的概率，就是跟结点到叶结点的路上所有概率的乘积。选择最大的就是输出。</p><h3 id="prefix-tuning-optimizing-continuous-prompts-for-generation.">Prefix-tuning: Optimizing continuous prompts for generation.</h3><p><img src="https://imagehost.vitaminz-image.top/SEofZJU-5.png"></p><p>提示学习所用的提示模板往往是一个个离散的词。该文章提出了一种将离散词嵌入到连续空间中去，比如使用2个向量，使其起到提示的效果。</p><h2 id="参考资料">参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://dl.acm.org/doi/abs/10.1145/3357384.3358119">Shanchan Wu and Yifan He. 2019. Enriching pre-trained language model with entity information for relation classification. In Proceedings of the 28th ACM international conference on information and knowledge management, pages 2361–2364.</a> <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://arxiv.org/abs/2105.08393">Shengfei Lyu and Huanhuan Chen. 2021. Relation classification with entity type restriction. In Findings of the Association for Computational Linguistics: ACLIJCNLP 2021, pages 390–395, Online. Association for Computational Linguistics.</a> <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://arxiv.org/abs/2105.11259">Xu Han, Weilin Zhao, Ning Ding, Zhiyuan Liu, and Maosong Sun. 2021. Ptr: Prompt tuning with rules for text classification. arXiv preprint arXiv:2105.11259.</a> <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://arxiv.org/abs/2205.09837">Lu K, Hsu I, Zhou W, et al. Summarization as Indirect Supervision for Relation Extraction[J]. arXiv preprint arXiv:2205.09837, 2022.</a> <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://arxiv.org/abs/2101.00190">Xiang Lisa Li and Percy Liang. 2021. Prefix-tuning: Optimizing continuous prompts for generation. In Proceedings of the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing (V olume 1: Long Papers), pages 4582–4597, Online. Association for Computational Linguistics.</a> <a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>知识图谱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
      <tag>知识图谱</tag>
      
      <tag>关系抽取</tag>
      
      <tag>提示学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT甲级典型题型总结</title>
    <link href="/2022/07/05/dsandalg/pat-jia-ji-dian-xing-ti-xing-zong-jie/"/>
    <url>/2022/07/05/dsandalg/pat-jia-ji-dian-xing-ti-xing-zong-jie/</url>
    
    <content type="html"><![CDATA[<h1 id="pat甲级典型题型总结">PAT甲级典型题型总结</h1>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动手写一个编译器</title>
    <link href="/2022/06/20/compiler/dong-shou-xie-yi-ge-bian-yi-qi/"/>
    <url>/2022/06/20/compiler/dong-shou-xie-yi-ge-bian-yi-qi/</url>
    
    <content type="html"><![CDATA[<h1 id="toyc语言">ToyC语言</h1><p>本项目用于学习编译原理。</p><p>将参照龙书版本的《编译原理》，</p><p>以及LLVM的编译器制作教程：https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.html</p><p>制作一个完整的编译器前端。</p><h2 id="编译器的结构">编译器的结构</h2><p><img src="https://imagehost.vitaminz-image.top/ToyC-1.png"></p><center>图1：摘自《Compilers Principles, Techniques &amp; Tools》第二版Figure 2.3</center><h3 id="uml">UML</h3><p><img src="https://imagehost.vitaminz-image.top/UML.png"></p><center>图2：UML</center><h3 id="词法分析器lexer">词法分析器(Lexer)</h3><h4 id="设计token">设计Token</h4><p>Token主要分为: 多字符保留字、标识符、数字以及其余单个字符。</p><ul><li>多字符保留字：<ul><li>控制流语句：if, else, do, while, break</li><li>布尔运算：true, false, &amp;&amp;, ||</li><li>比较运算：&gt;=, &lt;=, ==, !=</li><li>变量类型：int, float, bool, char</li></ul></li><li>标识符：<ul><li>正则表达式：[_a-zA-Z][_a-zA-Z0-9]*</li></ul></li><li>数字：<ul><li>整型正则表达式：[0-9]+</li><li>浮点型正则表达式：[0-9]+.[0-9]*</li></ul></li><li>其余单个字字符</li></ul><h4 id="识别算法">识别算法</h4><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></tbody></table></figure><h4 id="测试">测试</h4><p>输入：字符串 输出：按序输出token流，每个token占一行</p><p>词法分析器的步骤可用如下伪代码表示：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">Input:  <br>Output: <br>cache = <span class="hljs-string">' '</span><br>Scan() {<br>    <span class="hljs-keyword">do</span>{<br>        <span class="hljs-keyword">if</span> cache != 空格、换行、制表符<br>            <span class="hljs-keyword">break</span>;<br>    }<span class="hljs-keyword">while</span>(read(cache));<br><br>    t = readKey(cache)     <span class="hljs-comment">// 识别保留字</span><br>    t = readNumber(cache); <span class="hljs-comment">// 识别实数</span><br>    t = <br><br>    <span class="hljs-keyword">return</span> t;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="语法分析器parser">语法分析器(Parser)</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++">PROGRAM -&gt; BLOCK<br>BLOCK -&gt; <span class="hljs-string">'{'</span> DECLS STMTS <span class="hljs-string">'}'</span><br>DECLS -&gt; DECLS DECL<br>    -&gt; eps<br>DECL -&gt; TYPE id<span class="hljs-number">'</span>;'<br>TYPE-&gt; basic DIMS<br>DIMS-&gt; <span class="hljs-string">'['</span>DIMS<span class="hljs-number">'</span>]'<br>-&gt; eps<br>STMTS-&gt; STMTS STMT<br>    -&gt; eps<br><br>STMT-&gt; ASSIGN<span class="hljs-number">'</span>;'<br>-&gt; <span class="hljs-keyword">if</span> ( BOOL ) STMT<br>        -&gt; <span class="hljs-keyword">if</span> ( BOOL ) STMT <span class="hljs-keyword">else</span> STMT<br>        -&gt; <span class="hljs-keyword">while</span> ( BOOL ) STMT<br>        -&gt; <span class="hljs-keyword">do</span> STMT <span class="hljs-keyword">while</span> ( BOOL )<br>        -&gt; <span class="hljs-keyword">break</span><span class="hljs-number">'</span>;'<br>        -&gt; BLOCK<br>ASSIGN  -&gt; id OFFSET = BOOL<br>OFFSET  -&gt; [ BOOL ] OFFSET<br>        -&gt; eps<br>            <br>BOOL-&gt; BOOL <span class="hljs-string">"||"</span> JOIN<br>        -&gt; JOIN<br>JOIN-&gt; JOIN <span class="hljs-string">"&amp;&amp;"</span> EQAULITY<br>        -&gt; EQUALITY<br>EQUALITY-&gt; EQUALITY <span class="hljs-string">"=="</span> CMP<br>        -&gt; EQUALITY <span class="hljs-string">"!="</span> CMP<br>        -&gt; CMP<br>CMP-&gt; EXPR &lt; EXPR<br>        -&gt; EXPR &lt;= EXPR<br>        -&gt; EXPR &gt;= EXPR<br>        -&gt; EXPR &gt; EXPR<br>        -&gt; EXPR<br>EXPR-&gt; EXPR + TERM<br>        -&gt; EXPR - TERM<br>        -&gt; TERM<br>TERM-&gt; TERM * UNARY<br>        -&gt; TERM / UNARY<br>        -&gt; UNARY<br>UNARY-&gt; <span class="hljs-string">'!'</span> UNARY<br>        -&gt; <span class="hljs-string">'-'</span> UNARY<br>        -&gt; FACTOR<br>FACTOR-&gt; ( BOOL )<br>        -&gt; id OFFSET<br>        -&gt; number<br>        -&gt; real<br>        -&gt; <span class="hljs-literal">true</span><br>        -&gt; <span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><h3 id="符号表symbol-table">符号表(Symbol Table)</h3><p><img src="https://imagehost.vitaminz-image.top/ToyC-2.png" style="zoom:50%;"></p><center>图2：符号表示意图</center><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">PROGRAM -&gt; {top = null;} BLOCK<br>BLOCK -&gt; <span class="hljs-string">'{'</span> <br>{ saved = top;<span class="hljs-comment">// 保留现场，saved</span><br>  top = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Scope</span>(top); } <span class="hljs-comment">// 碰到块建立符号表，top指向当前块符号表</span><br>DECLS DECL <br>{ top = saved; }<span class="hljs-comment">// 恢复现场，</span><br><span class="hljs-string">'}'</span><br>DECLS -&gt; DECLS DECL<br>      -&gt; eps<br>DECL  -&gt; TYPE id<span class="hljs-number">'</span>;<span class="hljs-string">' { s = new Symbol(id);// </span><br><span class="hljs-string">  s.type = TYPE.lexeme;</span><br><span class="hljs-string">  top.put(id.lexeme, s); }</span><br><span class="hljs-string">TYPE  -&gt; basic {DIMS.type = basic; } </span><br><span class="hljs-string"> DIMS {TYPE.lexeme = DIMS.type; }</span><br><span class="hljs-string">DIMS  -&gt; '</span>[<span class="hljs-string">'num'</span>]<span class="hljs-string">' DIMS { Array.sz = num * Array.sz;</span><br><span class="hljs-string">      DIMS.type = Array; }</span><br><span class="hljs-string">      -&gt; eps { Array.sz = 1; </span><br><span class="hljs-string">               Array.type = Dims.type; }</span><br><span class="hljs-string">STMTS -&gt; STMTS STMT </span><br><span class="hljs-string">      -&gt; eps</span><br><span class="hljs-string">STMT  -&gt; BLOCK</span><br><span class="hljs-string">STMT  -&gt; .... &gt; ... id { s = top.get(id.lexeme); } ....</span><br></code></pre></td></tr></tbody></table></figure><p>单元测试：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">PROGRAM -&gt; BLOCK<br>BLOCK -&gt; <span class="hljs-string">'{'</span> DECLS STMTS <span class="hljs-string">'}'</span><br>DECLS -&gt; DECLS DECL<br>    -&gt; eps<br>DECL -&gt; TYPE id <span class="hljs-string">';'</span><br>TYPE-&gt; basic DIMS<br>DIMS-&gt; <span class="hljs-string">'['</span>num<span class="hljs-number">'</span>]<span class="hljs-string">'DIMS</span><br><span class="hljs-string">-&gt; eps</span><br><span class="hljs-string">STMTS-&gt; STMTS STMT</span><br><span class="hljs-string">    -&gt; eps</span><br><span class="hljs-string">STMT-&gt; BLOCK</span><br><span class="hljs-string">    -&gt; FACTOR '</span>;'<br>FACTOR-&gt; id<br></code></pre></td></tr></tbody></table></figure><h3 id="中间代码intermediate-code">中间代码(Intermediate Code)</h3><h4 id="表达式的计算">表达式的计算</h4><p><img src="https://imagehost.vitaminz-image.top/ToyC-3.png" style="zoom: 25%;"></p><p><img src="https://imagehost.vitaminz-image.top/ToyC-5.png" style="zoom: 25%;"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++">PROGRAM -&gt; STMTS<br>STMTS-&gt; STMTS STMT<br>    -&gt; eps<br>STMT-&gt; ASSIGN<span class="hljs-number">'</span>;'<br>ASSIGN  -&gt; id OFFSET = BOOL<br>OFFSET  -&gt; [ BOOL ] OFFSET<br>        -&gt; eps<br><br>BOOL-&gt; BOOL <span class="hljs-string">"||"</span> JOIN<br>        -&gt; JOIN<br>JOIN-&gt; JOIN <span class="hljs-string">"&amp;&amp;"</span> EQAULITY<br>        -&gt; EQUALITY<br>EQUALITY-&gt; EQUALITY <span class="hljs-string">"=="</span> CMP<br>        -&gt; EQUALITY <span class="hljs-string">"!="</span> CMP<br>        -&gt; CMP<br>CMP-&gt; EXPR &lt; EXPR<br>        -&gt; EXPR &lt;= EXPR<br>        -&gt; EXPR &gt;= EXPR<br>        -&gt; EXPR &gt; EXPR<br>EXPR-&gt; EXPR + TERM<br>        -&gt; EXPR - TERM<br>        -&gt; TERM<br>TERM-&gt; TERM * UNARY<br>        -&gt; TERM / UNARY<br>        -&gt; UNARY<br>UNARY-&gt; <span class="hljs-string">'!'</span> UNARY<br>        -&gt; <span class="hljs-string">'-'</span> UNARY<br>        -&gt; FACTOR<br>FACTOR-&gt; ( BOOL )<br>        -&gt; OFFSET<br>        -&gt; number<br>        -&gt; real<br>        -&gt; <span class="hljs-literal">true</span><br>        -&gt; <span class="hljs-literal">false</span><br>        -&gt; id OFFSET<br></code></pre></td></tr></tbody></table></figure><p>输入</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">a = b + 1;<br>c = a + 32 * 43 - b / ( g - 2);<br>d = e + f;<br>c = -e[3];<br>c[33+34+sd3*c] = de*c + c2;<br>f[c[2*d]+4] = df + de[23-s[f]];<br>s[m][n][o] = -d[3][x];<br>a = !a || s &amp;&amp; (c || d) || !f &amp;&amp; kk ;<br>b = (a + c) &gt; (b * 2 - 1) || a &lt; b &amp;&amp; c;<br></code></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs txt">a = b + 1<br>L3:t1 = 32 * 43<br>t2 = a + t1<br>t3 = g - 2<br>t4 = b / t3<br>c = t2 - t4<br>L4:d = e + f<br>L5:t5 = 3 * 10<br>t6 = e[t5]<br>c = -t6<br>L6:t7 = 33 + 34<br>t8 = sd3 * c<br>t9 = t7 + t8<br>t10 = t9 * 10<br>t11 = c[t10]<br>t12 = de * c<br>t13 = t12 + c2<br>c[t11] = t13<br>L7:t14 = 2 * d<br>t15 = t14 * 10<br>t16 = c[t15]<br>t17 = t16 + 4<br>t18 = t17 * 10<br>t19 = f[t18]<br>t20 = f * 10<br>t21 = s[t20]<br>t22 = 23 - t21<br>t23 = t22 * 10<br>t24 = de[t23]<br>t25 = df + t24<br>f[t19] = t25<br>L8:t26 = m * 10<br>t27 = n * 10<br>t28 = t26 + t27<br>t29 = o * 10<br>t30 = t28 + t29<br>t31 = s[t30]<br>t32 = 3 * 10<br>t33 = x * 10<br>t34 = t32 + t33<br>t35 = d[t34]<br>t36 = -t35<br>s[t31] = t36<br>L9:if False a goto L13<br>t37 = 23 * 10<br>t38 = f * 10<br>t39 = t37 + t38<br>t40 = sp[t39]<br>if False t40 goto L14<br>if c goto L13<br>if d goto L13<br>goto L14<br>L14:if f goto L11<br>if kk goto L13<br>goto L11<br>L13:t41 = true<br>goto L12<br>L11:t41 = false<br>L12:a = t41<br>L10:t42 = a + c<br>t43 = b * 2<br>t44 = t43 - 1<br>if t42 &gt; t44 goto L17<br>if False a &lt; b goto L15<br>if c goto L17<br>goto L15<br>L17:t45 = true<br>goto L16<br>L15:t45 = false<br>L16:b = t45<br>L2:<br><br></code></pre></td></tr></tbody></table></figure><h4 id="控制流语句的中间代码">控制流语句的中间代码</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++">PROGRAM -&gt; BLOCK<br>BLOCK -&gt; <span class="hljs-string">'{'</span> STMTS <span class="hljs-string">'}'</span><br>STMTS-&gt; STMTS STMT<br>    -&gt; eps<br><br>STMT-&gt; ASSIGN<span class="hljs-number">'</span>;'<br>-&gt; <span class="hljs-keyword">if</span> ( BOOL ) STMT<br>        -&gt; <span class="hljs-keyword">if</span> ( BOOL ) STMT <span class="hljs-keyword">else</span> STMT<br>        -&gt; <span class="hljs-keyword">while</span> ( BOOL ) STMT<br>        -&gt; <span class="hljs-keyword">do</span> STMT <span class="hljs-keyword">while</span> ( BOOL )<br>        -&gt; <span class="hljs-keyword">break</span><span class="hljs-number">'</span>;'<br>        -&gt; BLOCK<br>ASSIGN  -&gt; id OFFSET = BOOL<br>OFFSET  -&gt; [ BOOL ]<br>        -&gt; eps<br>            <br>BOOL-&gt; BOOL <span class="hljs-string">"||"</span> JOIN<br>        -&gt; JOIN<br>JOIN-&gt; JOIN <span class="hljs-string">"&amp;&amp;"</span> EQAULITY<br>        -&gt; EQUALITY<br>EQUALITY-&gt; EQUALITY <span class="hljs-string">"=="</span> CMP<br>        -&gt; EQUALITY <span class="hljs-string">"!="</span> CMP<br>        -&gt; CMP<br>CMP-&gt; EXPR &lt; EXPR<br>        -&gt; EXPR &lt;= EXPR<br>        -&gt; EXPR &gt;= EXPR<br>        -&gt; EXPR &gt; EXPR<br><br></code></pre></td></tr></tbody></table></figure><p>输入</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs txt">{<br>    if ((a + c) &gt; (b * 2 - 1) || a &lt; b &amp;&amp; c){<br>        a = b * 2 - c + (b + 2 * d);<br>    }<br>    while (a &gt; 3){<br>        a = a + 1;<br>        do a = a + 3; while( b &gt; 2);<br>        if (c - 3){<br>            b = c + 5;<br>            d = a + 3;<br>        }<br>        else {<br>            c = 3;<br>            break;<br>        }<br>    }<br>    while (c &lt; b){<br>        a = 3;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight vbnet"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">L1:</span>t1 = a + c<br>t2 = b * <span class="hljs-number">2</span><br>t3 = t2 - <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> t1 &gt; t3 <span class="hljs-keyword">goto</span> L5<br><span class="hljs-keyword">if</span> <span class="hljs-literal">False</span> a &lt; b <span class="hljs-keyword">goto</span> L3<br><span class="hljs-keyword">if</span> c <span class="hljs-keyword">goto</span> L5<br><span class="hljs-keyword">goto</span> L3<br><span class="hljs-symbol">L5:</span>L4:t4 = b * <span class="hljs-number">2</span><br>t5 = t4 - c<br>t6 = <span class="hljs-number">2</span> * d<br>t7 = b + t6<br>a = t5 + t7<br><span class="hljs-symbol">L3:</span><span class="hljs-keyword">if</span> <span class="hljs-literal">False</span> a &gt; <span class="hljs-number">3</span> <span class="hljs-keyword">goto</span> L6<br><span class="hljs-symbol">L7:</span>a = a + <span class="hljs-number">1</span><br><span class="hljs-symbol">L8:</span>a = a + <span class="hljs-number">3</span><br><span class="hljs-symbol">L10:</span><span class="hljs-keyword">if</span> b &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">goto</span> L8<br><span class="hljs-keyword">goto</span> L9<br><span class="hljs-symbol">L9:</span><span class="hljs-keyword">if</span> <span class="hljs-literal">False</span> c - <span class="hljs-number">3</span> <span class="hljs-keyword">goto</span> L12<br><span class="hljs-symbol">L11:</span>b = c + <span class="hljs-number">5</span><br><span class="hljs-symbol">L13:</span>d = a + <span class="hljs-number">3</span><br><span class="hljs-keyword">goto</span> L3<br><span class="hljs-symbol">L12:</span>c = <span class="hljs-number">3</span><br><span class="hljs-symbol">L14:</span><span class="hljs-keyword">goto</span> L6<br><span class="hljs-keyword">goto</span> L3<br><span class="hljs-symbol">L6:</span><span class="hljs-keyword">if</span> <span class="hljs-literal">False</span> c &lt; b <span class="hljs-keyword">goto</span> L2<br><span class="hljs-symbol">L15:</span>a = <span class="hljs-number">3</span><br><span class="hljs-keyword">goto</span> L6<br><span class="hljs-symbol">L2:</span><br><br></code></pre></td></tr></tbody></table></figure><h4 id="总结">总结</h4><h2 id="附录">附录</h2>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级数据结构：树状数组、线段树</title>
    <link href="/2022/03/15/dsandalg/gao-ji-shu-ju-jie-gou-shu-zhuang-shu-zu-xian-duan-shu/"/>
    <url>/2022/03/15/dsandalg/gao-ji-shu-ju-jie-gou-shu-zhuang-shu-zu-xian-duan-shu/</url>
    
    <content type="html"><![CDATA[<h1 id="高级数据结构树状数组线段树">高级数据结构：树状数组、线段树</h1>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
      <tag>区间树</tag>
      
      <tag>线段树</tag>
      
      <tag>字典树</tag>
      
      <tag>高级数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统实验-Pintos</title>
    <link href="/2022/02/10/os/cao-zuo-xi-tong-shi-yan-pintos/"/>
    <url>/2022/02/10/os/cao-zuo-xi-tong-shi-yan-pintos/</url>
    
    <content type="html"><![CDATA[<h1 id="pintos">Pintos</h1><h2 id="环境篇">环境篇</h2><h3 id="wsl-ubuntu18.04">WSL: Ubuntu18.04</h3><p>Windows Subsystem for Linux（简称WSL）是一个在Windows 10上能够运行原生Linux二进制可执行文件（ELF格式）的兼容层。它是由微软与Canonical公司合作开发，其目标是使纯正的Ubuntu、Debian等映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。[https://baike.baidu.com/item/wsl/20359185?fr=aladdin#reference-[1]-21058117-wrap]。</p><p>安装步骤：可直接使用windows自带软件商城，搜索Ubuntu18.04安装即可。如果不想装到c盘，可参考文章https://blog.csdn.net/tiandiren111/article/details/121026761。<strong>不建议使用图形化界面，尝试使用命令行界面，或许有意想不到的惊喜。</strong></p><h3 id="配置pintos">配置Pintos</h3><p>参考：https://blog.csdn.net/geeeeeker/article/details/108104466（原文中9、10、11是不必要的甚至错误的）可能还需要安装gdb、git、vim等工具，过程中缺啥补啥就行了（即用sudo apt-get install xxx来安装）。</p><ol type="1"><li>在终端运行<code>sudo apt-get install qemu</code></li><li>从<a href="https://pintos-os.org/cgi-bin/gitweb.cgi?p=pintos-anon;a=summary">git公共库</a>获得最新Pintos，下载.tar .gz到你自己的目录并解压。</li><li><code>/utils/pintos-gdb</code>用vim打开，编辑<code>GDBMACROS</code>变量，将你自己的Pintos完整路径赋给该变量。</li><li>用vim打开Makefile并将<code>LOADLIBES</code>变量名编辑为<code>LDLIBS</code></li><li>在<code>/src/utils</code>中输入<code>make</code>来编译utils</li><li>编辑<code>/src/threads/Make.vars</code>（第7行）：更改<code>bochs</code>为<code>qemu</code></li><li>在<code>/src/threads</code>并运行来编译线程目录<code>make</code></li><li>编辑<code>/utils/pintos</code>（第103行）：替换<code>bochs</code>为<code>qemu</code></li><li>打开<code>~/.bashrc</code>并添加<code>export PATH=/home/.../pintos/src/utils:$PATH</code>到最后一行。</li><li>重新打开终端输入<code>source ~/.bashrc</code>并运行</li><li>进入src/threads/，make一下</li><li>然后cd build，输入<code>pintos run alarm-multiple</code>，（运行完后ctrl+c手动终止掉）。如果运行界面如下，大概率是配置成功了。以下将介绍如何测试。</li></ol><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/config_run.png"></p><h3 id="测试">测试</h3><p>比如想要对thread这个project的测试点进行测试，进入.../src/threads/build目录，执行make check即可。每次测试前，<strong>需先make clean</strong>，再make check。但使用我写的脚本（参考工具篇的shell script）进行测试是不需要这样的（因为脚本帮你做了）。总之最后会输出如下的信息（这是已经完成部分test的图，以实际为准）。</p><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/first_test.png"></p><p>由于上述配置只使用了qemu，而由于qemu只支持real time的原因，thread项目make check<strong>需要的时间很久</strong>，大概要二十分钟左右，这是正常现象。当然，你可以安装bochs虚拟机，对pintos进行配置，可以大大提高thread这一project的check速度。不过在我的wsl上没有配置成功，在虚拟机上成功了，具体原因未知。但本人更喜欢在wsl上编写代码、测试，因此没有记录虚拟机的配置过程，如有需要，可参考https://www.cnblogs.com/crayygy/p/ubuntu-pintos.html。</p><p>当然如果想自己写测试脚本，可以参考工具篇shell scipt。</p><h2 id="工具篇">工具篇</h2><p>”工欲善其事，必先利其器“，花点时间学习一些工具的使用，可能会有意想不到的惊喜。</p><h3 id="git">Git</h3><p>Git（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 也是<a href="https://baike.baidu.com/item/Linus%20Torvalds/9336769">Linus Torvalds</a>为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。[https://baike.baidu.com/item/GIT/12647237?fr=aladdin]</p><p>具体用法不细说啦，需要一点学习成本。但请相信，这点学习成本是值得的，当然在本项目也是<strong>必需</strong>的。推荐学习廖雪峰的git教程：https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496。</p><h3 id="tmux">Tmux</h3><p>使用方法参考：http://www.ruanyifeng.com/blog/2019/10/tmux.html</p><p>tmux可以让会话和终端窗口分离。如下图</p><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/tmux_show.png"></p><p>同一个终端窗口可以分屏为2个会话，你可以一侧编辑代码，一边测试。同时，方便的快捷键，可以让你不再依赖鼠标，提高工作效率。</p><p>配合GDB使用更佳。</p><h3 id="gdb">GDB</h3><p>参考：https://www.youtube.com/watch?v=0zO-8EwecP0&amp;t=620s</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">在一个会话中输入如下命令，xxxx表示你要测试的任务名</span><br>pintos --gdb -- run xxxx<br><span class="hljs-meta"># </span><span class="language-bash">在另一个会话中输入，注意要进入build目录执行</span><br>pintos-gdb --tui<br></code></pre></td></tr></tbody></table></figure><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/gdb_tmux.png"></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">在右侧会话中输入</span><br>pintos-gdb --tui<br><span class="hljs-meta"># </span><span class="language-bash">然后输入</span><br>file kernel.o<br><span class="hljs-meta"># </span><span class="language-bash">然后根据提示输入y即可</span><br></code></pre></td></tr></tbody></table></figure><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/gdb_running.png"></p><p>然后就需要参照gdb的使用方法了，如加入断点</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm"># 在sema_down处添加断电<br>b sema_down<br># 继续执行至断点处<br>c<br># 下一步, 进入函数<br>s<br># 下一步，不进入函数<br>n<br># 杀死程序<br>kill<br># 等等<br># 可参照网上的一些gdb教程<br># 如https://baijiahao.baidu.com/s?id=1675872273223193511&amp;wfr=spider&amp;for=pc等等<br></code></pre></td></tr></tbody></table></figure><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/gdb_running2.png"></p><h3 id="understand">Understand</h3><p>Understand是一款静态代码分析工具，界面如下图所示：</p><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/understand_ui.png"></p><p>我比较喜欢的功能是它可以画出函数之间的调用图。</p><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/understand_call.png"></p><p>还有这样的蝴蝶图。</p><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/understand_butterfly.png"></p><p>推荐使用它对代码进行分析。</p><h3 id="shell-script">Shell script</h3><p>使用shell编写一些脚本，可以个性化地完成一些你所想的工作。如果想要使用如下脚本，只需将missions数组中写入所需要测试的任务名即可。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">unset missions<br>missions=(alarm-single alarm-multiple alarm-simultaneous alarm-priority alarm-zero alarm-negative) # task list<br>if [[ $1 = "m" ]]<br>then<br>cnt=0<br>for i in ${missions[*]}<br>do<br>echo $cnt:$i<br>let "cnt++"<br>done<br>else<br><span class="hljs-meta"># </span><span class="language-bash">compute number of missions</span><br>((num=${#missions[@]}-1)) <br>if [[ $1 &amp;&amp; $1 != "v" &amp;&amp; $1 -le $num &amp;&amp; $1 -ge 0 ]]<br>then m=${missions[$1]}; unset missions; missions=($m)<br>fi<br><span class="hljs-meta"># </span><span class="language-bash">execute instructions</span><br>(cd build<br>for i in ${missions[*]}<br>do<br>echo ------------------------------------------------------------<br>echo "$i"<br>echo ------------------------------------------------------------<br>rm -f tests/threads/${i}.output<br>unset op<br>if [[ $1 = 'v' || $2 = 'v' ]]<br>then op='VERBOSE=1'<br>fi<br>make tests/threads/${i}.result $op<br>done)<br>fi<br><br></code></pre></td></tr></tbody></table></figure><p>使用方法：</p><p>比如上述脚本，missions数组中存的是thread的task1的任务列表，我将脚本复制到task1文件中。</p><p>执行</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">. task1<br></code></pre></td></tr></tbody></table></figure><p>那么它只会执行thread中alarm部分的测试。</p><p>如果想要输出详细信息则执行</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">. task1 v<br></code></pre></td></tr></tbody></table></figure><p>如果想要执行某一个任务，可以先执行</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">. task1 m<br></code></pre></td></tr></tbody></table></figure><p>则会输出一个任务列表，每个任务都有一个编号</p><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/task_list.png"></p><p>比如想要单独测试任务3: alarm-priority，则只需执行</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">. task1 3<br><span class="hljs-meta"># </span><span class="language-bash">或者</span><br>. task1 3 v<br><span class="hljs-meta"># </span><span class="language-bash">表示输出第三个任务的详细信息</span><br></code></pre></td></tr></tbody></table></figure><h2 id="结构篇">结构篇</h2><h3 id="主要模块分析">主要模块分析</h3><p>参考：Pintos官方手册的Appendix部分</p><h3 id="补充知识">补充知识</h3><h4 id="c语言的面向对象">C语言的面向对象</h4><p>C语言中没有class，但是也可以使用一些技巧来达到面向对象编程的目的。如：pintos的list.h中有这样一串代码，它表示，输入list_elem的地址，再输入宿主结构，以及list_elem类型成员在宿主中的名字，就可以获得宿主的地址。这样就能实现使用通过list_elem来访问宿主结构体的目的啦。 如此一来，只需要实现一个list的代码，就能够使得所有类型的struct都能去使用它。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* offset表示某成员在TYPE中的偏移地址 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *) 0)-&gt;MEMBER)</span><br><span class="hljs-comment">/* Converts pointer to list element LIST_ELEM into a pointer to</span><br><span class="hljs-comment">   the structure that LIST_ELEM is embedded inside.  Supply the</span><br><span class="hljs-comment">   name of the outer structure STRUCT and the member name MEMBER</span><br><span class="hljs-comment">   of the list element.  See the big comment at the top of the</span><br><span class="hljs-comment">   file for an example. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_entry(LIST_ELEM, STRUCT, MEMBER)           \</span><br><span class="hljs-meta">        ((STRUCT *) ((uint8_t *) &amp;(LIST_ELEM)-&gt;next     \</span><br><span class="hljs-meta">                     - offsetof (STRUCT, MEMBER.next)))</span><br></code></pre></td></tr></tbody></table></figure><h4 id="内联汇编">内联汇编</h4><p>参考：</p><p>https://www.jianshu.com/p/1782e14a076</p><p>https://www.cnblogs.com/taek/archive/2012/02/05/2338838.html</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">asm</span> ( assembler template<br>        : output operands                <span class="hljs-comment">/* optional */</span><br>        : input operands                 <span class="hljs-comment">/* optional */</span><br>        : <span class="hljs-built_in">list</span> of clobbered registers    <span class="hljs-comment">/* optional */</span><br>);<br></code></pre></td></tr></tbody></table></figure><p>Eamples</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>, b;<br><span class="hljs-keyword">asm</span> ( <span class="hljs-string">"movl %1, %%eax;movl %%eax, %0;"</span><br>          :<span class="hljs-string">"=r"</span>(b)           <span class="hljs-comment">/* output */</span><br>          :<span class="hljs-string">"r"</span>(a)              <span class="hljs-comment">/* input */</span><br>          :<span class="hljs-string">"%eax"</span>         <span class="hljs-comment">/* clobbered register */</span><br>);<br></code></pre></td></tr></tbody></table></figure><p>Constraints</p><figure class="highlight mathematica"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">其他可能用到的<span class="hljs-variable">constraint</span>有：<br><span class="hljs-variable">r</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用一个通用寄存器<span class="hljs-operator">,</span>由<span class="hljs-variable">GCC</span>在<span class="hljs-operator">%</span><span class="hljs-variable">eax</span><span class="hljs-operator">/%</span><span class="hljs-variable">ax</span><span class="hljs-operator">/%</span><span class="hljs-variable">al</span>、<span class="hljs-operator">%</span><span class="hljs-variable">ebx</span><span class="hljs-operator">/%</span><span class="hljs-variable">bx</span><span class="hljs-operator">/%</span><span class="hljs-variable">bl</span>、<span class="hljs-operator">%</span><span class="hljs-variable">ecx</span><span class="hljs-operator">/%</span><span class="hljs-variable">cx</span><span class="hljs-operator">/%</span><span class="hljs-variable">cl</span>、<span class="hljs-operator">%</span><span class="hljs-variable">edx</span><span class="hljs-operator">/%</span><span class="hljs-variable">dx</span><span class="hljs-operator">/%</span><span class="hljs-variable">dl</span>中选取一个<span class="hljs-variable">GCC</span>认为是合适的<span class="hljs-operator">;</span><br><span class="hljs-variable">q</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用一个通用寄存器<span class="hljs-operator">,</span>与<span class="hljs-variable">r</span>的意义相同<span class="hljs-operator">;</span><br><span class="hljs-variable">g</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用寄存器或内存地址<span class="hljs-operator">;</span><br><span class="hljs-variable">m</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用内存地址<span class="hljs-operator">;</span><br><span class="hljs-variable">a</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用<span class="hljs-operator">%</span><span class="hljs-variable">eax</span><span class="hljs-operator">/%</span><span class="hljs-variable">ax</span><span class="hljs-operator">/%</span><span class="hljs-variable">al</span><span class="hljs-operator">;</span><br><span class="hljs-variable">b</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用<span class="hljs-operator">%</span><span class="hljs-variable">ebx</span><span class="hljs-operator">/%</span><span class="hljs-variable">bx</span><span class="hljs-operator">/%</span><span class="hljs-variable">bl</span><span class="hljs-operator">;</span><br><span class="hljs-variable">c</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用<span class="hljs-operator">%</span><span class="hljs-variable">ecx</span><span class="hljs-operator">/%</span><span class="hljs-variable">cx</span><span class="hljs-operator">/%</span><span class="hljs-variable">cl</span><span class="hljs-operator">;</span><br><span class="hljs-variable">d</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用<span class="hljs-operator">%</span><span class="hljs-variable">edx</span><span class="hljs-operator">/%</span><span class="hljs-variable">dx</span><span class="hljs-operator">/%</span><span class="hljs-variable">dl</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">D</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用<span class="hljs-operator">%</span><span class="hljs-variable">edi</span><span class="hljs-operator">/%</span><span class="hljs-variable">di</span><span class="hljs-operator">;</span><br><span class="hljs-variable">S</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用<span class="hljs-operator">%</span><span class="hljs-variable">esi</span><span class="hljs-operator">/%</span><span class="hljs-variable">si</span><span class="hljs-operator">;</span><br><span class="hljs-variable">f</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用浮点寄存器<span class="hljs-operator">;</span><br><span class="hljs-variable">t</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用第一个浮点寄存器<span class="hljs-operator">;</span><br><span class="hljs-variable">u</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用第二个浮点寄存器<span class="hljs-operator">;</span><br><span class="hljs-variable">A</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示把<span class="hljs-operator">%</span><span class="hljs-variable">eax</span>与<span class="hljs-operator">%</span><span class="hljs-variable">edx</span>组合成一个<span class="hljs-number">64</span>位的整数值<span class="hljs-operator">;</span><br><span class="hljs-variable">o</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用一个内存位置的偏移量<span class="hljs-operator">;</span><br><span class="hljs-variable">V</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示仅仅使用一个直接内存位置<span class="hljs-operator">;</span><br><span class="hljs-variable">i</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用一个整数类型的立即数<span class="hljs-operator">;</span><br><span class="hljs-variable">n</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用一个带有已知整数值的立即数<span class="hljs-operator">;</span><br><span class="hljs-variable">F</span><span class="hljs-operator">:</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span>表示使用一个浮点类型的立即数<span class="hljs-operator">;</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-title">.data段保存程序的数据，是可读可写的，相当于C程序的全局变量</span><br><span class="hljs-title">.globl指示告诉汇编器，这个符号要被链接器用到，所以要在目标文件的符号表中标记它是一个全局符号</span><br><span class="hljs-title">.text段保存代码，是只读和可执行的</span><br></code></pre></td></tr></tbody></table></figure><table><thead><tr class="header"><th style="text-align: left;">Intel Code</th><th style="text-align: left;">AT&amp;T Code</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">mov eax,1</td><td style="text-align: left;">movl $1,%eax</td></tr><tr class="even"><td style="text-align: left;">mov ebx,0ffh</td><td style="text-align: left;">movl $0xff,%ebx</td></tr><tr class="odd"><td style="text-align: left;">int 80h</td><td style="text-align: left;">int $0x80</td></tr><tr class="even"><td style="text-align: left;">mov ebx, eax</td><td style="text-align: left;">movl %eax, %ebx</td></tr><tr class="odd"><td style="text-align: left;">mov eax,[ecx]</td><td style="text-align: left;">movl (%ecx),%eax</td></tr><tr class="even"><td style="text-align: left;">mov eax,[ebx+3]</td><td style="text-align: left;">movl 3(%ebx),%eax</td></tr><tr class="odd"><td style="text-align: left;">mov eax,[ebx+20h]</td><td style="text-align: left;">movl 0x20(%ebx),%eax</td></tr><tr class="even"><td style="text-align: left;">add eax,[ebx+ecx*2h]</td><td style="text-align: left;">addl (%ebx,%ecx,0x2),%eax</td></tr><tr class="odd"><td style="text-align: left;">lea eax,[ebx+ecx]</td><td style="text-align: left;">leal (%ebx,%ecx),%eax</td></tr><tr class="even"><td style="text-align: left;">sub eax,[ebx+ecx*4h-20h]</td><td style="text-align: left;">subl -0x20(%ebx,%ecx,0x4),%eax</td></tr></tbody></table><h4 id="汇编调用c函数">汇编调用c函数</h4><ol type="1"><li>将参数压栈</li><li>调用</li></ol><p>结构体变量注意8字节对齐。</p><p>可参照pintos中的switch.h文件中的switch_threads，该函数被schedule()调用。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs asm">#include "threads/switch.h"<br><br>#### struct thread *switch_threads (struct thread *cur, struct thread *next);<br>####<br>#### Switches from CUR, which must be the running thread, to NEXT,<br>#### which must also be running switch_threads(), returning CUR in<br>#### NEXT's context.<br>####<br>#### This function works by assuming that the thread we're switching<br>#### into is also running switch_threads().  Thus, all it has to do is<br>#### preserve a few registers on the stack, then switch stacks and<br>#### restore the registers.  As part of switching stacks we record the<br>#### current stack pointer in CUR's thread structure.<br><br>.globl switch_threads<br>.func switch_threads<br>switch_threads:<br># Save caller's register state.<br>#<br># Note that the SVR4 ABI allows us to destroy %eax, %ecx, %edx,<br># but requires us to preserve %ebx, %ebp, %esi, %edi.  See<br># [SysV-ABI-386] pages 3-11 and 3-12 for details.<br>#<br># This stack frame must match the one set up by thread_create()<br># in size.<br>pushl %ebx<br>pushl %ebp<br>pushl %esi<br>pushl %edi<br><br># Get offsetof (struct thread, stack).<br>.globl thread_stack_ofs<br>mov thread_stack_ofs, %edx<br><br># Save current stack pointer to old thread's stack, if any.<br>movl SWITCH_CUR(%esp), %eax<br>movl %esp, (%eax,%edx,1)<br><br># Restore stack pointer from new thread's stack.<br>movl SWITCH_NEXT(%esp), %ecx<br>movl (%ecx,%edx,1), %esp<br><br># Restore caller's register state.<br>popl %edi<br>popl %esi<br>popl %ebp<br>popl %ebx<br>        ret<br>.endfunc<br><br>.globl switch_entry<br>.func switch_entry<br>switch_entry:<br># Discard switch_threads() arguments.<br>addl $8, %esp<br><br># Call thread_schedule_tail(prev).<br>pushl %eax<br>.globl thread_schedule_tail<br>call thread_schedule_tail<br>addl $4, %esp<br><br># Start thread proper.<br>ret<br>.endfunc<br></code></pre></td></tr></tbody></table></figure><h4 id="进程切换">进程切换</h4><p>切换前，保存进程上下文信息</p><p>切换后，恢复进程上下文信息</p><p>可参照pintos中的switch.h文件中的switch_threads，该函数被schedule()调用。</p><hr><h3 id="qa">Q&amp;A</h3><ol type="1"><li><p>running_thread(void)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Copy the CPU's stack pointer into `esp', and then round that</span><br><span class="hljs-comment">   down to the start of a page.  Because `struct thread' is</span><br><span class="hljs-comment">   always at the beginning of a page and the stack pointer is</span><br><span class="hljs-comment">   somewhere in the middle, this locates the curent thread. */</span><br></code></pre></td></tr></tbody></table></figure></li></ol><p>​ 问：为啥esp和线程在同一个页面？</p><p>​ 答：见手册P61</p><ol start="2" type="1"><li><p>sema_down(void)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Down or "P" operation on a semaphore.  Waits for SEMA's value</span><br><span class="hljs-comment">   to become positive and then atomically decrements it.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   This function may sleep, so it must not be called within an</span><br><span class="hljs-comment">   interrupt handler.  This function may be called with</span><br><span class="hljs-comment">   interrupts disabled, but if it sleeps then the next scheduled</span><br><span class="hljs-comment">   thread will probably turn interrupts back on. */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">sema_down</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sema)</span> <br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span>;</span><br><br>  ASSERT (sema != <span class="hljs-literal">NULL</span>);<br>  ASSERT (!intr_context ());<br><br>  old_level = intr_disable ();<br>  <span class="hljs-keyword">while</span> (sema-&gt;value == <span class="hljs-number">0</span>) <br>    {<br>      list_push_back (&amp;sema-&gt;waiters, &amp;thread_current ()-&gt;elem);<br>      thread_block ();<br>    }<br>  sema-&gt;value--;<br>  intr_set_level (old_level);<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>关于sema_down的实现，一开始还是有点迷糊的。先说收它的功能：先是关闭中断，当sema为0的时候，就把它推进等待队列，然后阻塞自己。随后，如果其他进程也sema_down，那同样会进来，由于还没有sema_up，sema还是0，同样阻塞自己。直到有人sema_up。至于注释说它说这个function可能会sleep，sleep是指后面调用了thread_block，会跳出这个程序，执行另一个进程。但是问题在于，它把中断关了，那其他进程岂不都是在关中断的情况下进行的？那不是无法被时间片调度？好像是有可能的。不过，我看了一下有谁会调用开中断程序。</p><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/timer_intr.png"></p><p>发现thread_create会间接调用intr_enable，仔细看一下kenel_thread的代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Function used as the basis for a kernel thread. */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">kernel_thread</span> <span class="hljs-params">(thread_func *function, <span class="hljs-type">void</span> *aux)</span> <br>{<br>  ASSERT (function != <span class="hljs-literal">NULL</span>);<br><br>  intr_enable ();       <span class="hljs-comment">/* The scheduler runs with interrupts off. */</span><br>  function (aux);       <span class="hljs-comment">/* Execute the thread function. */</span><br>  thread_exit ();       <span class="hljs-comment">/* If function() returns, kill the thread. */</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>发现，当执行线程函数之前，首先做的事就是开中断。那么就意味着，如果是执行新创建的一个线程，就会把中断打开。不过还是感觉怪怪的，感觉这里关中断关的有点久了？</p></li></ol><h2 id="实现篇">实现篇</h2><p>个人认为，project的难度较高，这使得独立实现比较困难。可以参考以下文章，辅助阅读。</p><p>https://www.cnblogs.com/laiy/p/pintos_project1_thread.html</p><p>https://zhuanlan.zhihu.com/p/104497182</p><p>https://blog.csdn.net/Calvinzan/article/details/117966196</p><p>https://wenku.baidu.com/view/8296f9629b6648d7c1c74649.html</p><p>https://zhuanlan.zhihu.com/p/340428650</p><h3 id="project1-threads">Project1 Threads</h3><h4 id="task1-alarm">Task1: alarm</h4><h5 id="分析">分析</h5><p>先来看看任务1的Mission List:</p><figure class="highlight elixir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-number">0</span><span class="hljs-symbol">:alarm-single</span><br><span class="hljs-number">1</span><span class="hljs-symbol">:alarm-multiple</span><br><span class="hljs-number">2</span><span class="hljs-symbol">:alarm-simultaneous</span><br><span class="hljs-number">3</span><span class="hljs-symbol">:alarm-priority</span><br><span class="hljs-number">4</span><span class="hljs-symbol">:alarm-zero</span><br><span class="hljs-number">5</span><span class="hljs-symbol">:alarm-negative</span><br></code></pre></td></tr></tbody></table></figure><p>我们需要实现哪些工作？</p><ol type="1"><li>将忙等待的睡眠机制，转为block</li><li>实现优先级唤醒</li></ol><p>这两个任务，我们最好不要分开考虑，要相结合。</p><p>根据操作系统的知识，让系统睡眠的常用方法其实是阻塞该睡眠进程。如下图所示，睡眠时，可将其塞入<strong>阻塞（block）队列</strong>当中，当<strong>事件（Event）</strong>发生时，再将其丢入<strong>ready队列</strong>。</p><p>那么这里需阐明几点概念</p><ul><li><strong>事件</strong>是什么？对于唤醒的事件，就是当时间到的时候，而pintos实现计时功能的，则是利用时间中断的机制，当经过一个最小的时间单位后，8254芯片就会产生时间中断，进入timer_interrupt函数，将时间加1，<strong>因此这里的事件应该指的是，睡眠时间用尽，那么事件发生的地点应在timer_interrupt函数中，则唤醒进程的任务在该函数进行。</strong></li><li><strong>ready队列</strong>是个FIFO队列吗？显然不是，因为我们要实现的第二个任务便是优先级唤醒，因此在执行顺序上，对于同一时间唤醒的几个进程，应按照优先级唤醒。<strong>那么ready应当是个优先级队列</strong>。不仅如此，Blocked queue最好也应设计为优先队列。</li><li>为了简单起见，我们无需开辟一个Blocked queue去存储阻塞队列，只需遍历all_list，通过标志位进行判断是否为阻塞即可。</li></ul><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/schedule.png"></p><p>到此为止，task1的思路基本明了了。以下阐述具体实现</p><hr><h5 id="实现">实现</h5><ul><li>为完成第一个目标，首先我们应修改timer_sleep函数，去除忙等待机制</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*########################## timer.c ###########################*/</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">timer_sleep</span> <span class="hljs-params">(<span class="hljs-type">int64_t</span> ticks)</span><br>{<br>  <span class="hljs-type">int64_t</span> start = timer_ticks ();<br><br>  ASSERT (intr_get_level () == INTR_ON);<br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br>  <span class="hljs-comment">/* 关闭中断，基操 */</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();<br>  <br>  <span class="hljs-comment">/* 获取当前线程，并存入休眠时间，阻塞进程 */</span><br>   <span class="hljs-keyword">if</span>(ticks &gt; <span class="hljs-number">0</span>)<br>   {<br>     thread_current() -&gt; sleepticks = ticks;<br>     thread_block();<br>   }<br>    <br>  intr_set_level(old_level);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>}<br><br><br></code></pre></td></tr></tbody></table></figure><ul><li>在实现以上函数的时候，我们使用了thread中的sleepticks，而这一些在源程序中，其实是没有的，我们需添加这些东西</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*########################## thread.h ###########################*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span></span><br><span class="hljs-class">  {</span><br>    <span class="hljs-comment">/* Owned by thread.c. */</span><br>    <span class="hljs-type">tid_t</span> tid;                          <span class="hljs-comment">/* Thread identifier. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">thread_status</span> <span class="hljs-title">status</span>;</span>          <span class="hljs-comment">/* Thread state. */</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">16</span>];                      <span class="hljs-comment">/* Name (for debugging purposes). */</span><br>    <span class="hljs-type">uint8_t</span> *<span class="hljs-built_in">stack</span>;                     <span class="hljs-comment">/* Saved stack pointer. */</span><br>    <span class="hljs-type">int</span> priority;                       <span class="hljs-comment">/* Priority. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> <span class="hljs-title">allelem</span>;</span>           <span class="hljs-comment">/* List element for all threads list. */</span><br><br>    <span class="hljs-comment">/* Shared between thread.c and synch.c. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> <span class="hljs-title">elem</span>;</span>              <span class="hljs-comment">/* List element. */</span><br><br>    <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><br>    <span class="hljs-type">int</span> sleepticks;                     <span class="hljs-comment">/* How may time to sleep */</span><br><br>    <span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USERPROG</span><br>    <span class="hljs-comment">/* Owned by userprog/process.c. */</span><br>    <span class="hljs-type">uint32_t</span> *pagedir;                  <span class="hljs-comment">/* Page directory. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* Owned by thread.c. */</span><br>    <span class="hljs-type">unsigned</span> magic;                     <span class="hljs-comment">/* Detects stack overflow. */</span><br>  };<br><br></code></pre></td></tr></tbody></table></figure><ul><li>接下来我们要考虑怎么去唤醒它了</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span><br><br><span class="hljs-comment">/*对于sleep_queue中的每一个进程，都进行sleepticks--的操作，</span><br><span class="hljs-comment"> 并检查是否到了休眠时间，即sleepticks==0?  */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">check_and_unblock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* t, <span class="hljs-type">void</span>*aux UNUSED)</span><br>{<br>  <span class="hljs-keyword">if</span> (t-&gt;status == THREAD_BLOCKED &amp;&amp; t-&gt;sleepticks &gt; <span class="hljs-number">0</span>)<br>  {<br>    t-&gt;sleepticks --;<br>    <span class="hljs-keyword">if</span> (t-&gt;sleepticks &lt;= <span class="hljs-number">0</span>)<br>    {<br>      thread_unblock(t);<br>    }<br>  }<br><br>}<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br><br><span class="hljs-comment">/* Timer interrupt handler. */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">timer_interrupt</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame *args UNUSED)</span><br>{<br>  ticks++;<br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><br>  thread_foreach (check_and_unblock, <span class="hljs-literal">NULL</span>);<br><br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  thread_tick ();<br>}<br><br><br><span class="hljs-comment">/*########################## thread.c ###########################*/</span><br><br><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><br><span class="hljs-comment">/*比较线程优先级的函数*/</span><br><span class="hljs-type">bool</span><br><span class="hljs-title function_">thread_cmp_priority</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem *a, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem *b, <span class="hljs-type">void</span> *aux UNUSED)</span><br>{<br>  <span class="hljs-keyword">return</span> list_entry(a, <span class="hljs-keyword">struct</span> thread, elem)-&gt;priority &gt; list_entry(b, <span class="hljs-keyword">struct</span> thread, elem)-&gt;priority;<br>}<br><br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">thread_unblock</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> thread *t)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span>;</span><br><br>  ASSERT (is_thread (t));<br><br>  old_level = intr_disable ();<br>  ASSERT (t-&gt;status == THREAD_BLOCKED);<br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><br>  <span class="hljs-comment">/*按优先级插入ready队列，以实现优先级唤醒的目的*/</span><br>  list_insert_ordered (&amp;ready_list, &amp;cur-&gt;elem, (list_less_func *) &amp;thread_cmp_priority, <span class="hljs-literal">NULL</span>);<br><br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  t-&gt;status = THREAD_READY;<br>  intr_set_level (old_level);<br>}<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">thread_yield</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">cur</span> =</span> thread_current ();<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span>;</span><br><br>  ASSERT (!intr_context ());<br><br>  old_level = intr_disable ();<br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br>  <span class="hljs-keyword">if</span> (cur != idle_thread)<br>    list_insert_ordered (&amp;ready_list, &amp;cur-&gt;elem, (list_less_func *) &amp;thread_cmp_priority, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  cur-&gt;status = THREAD_READY;<br>  schedule ();<br>  intr_set_level (old_level);<br>}<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">thread_init</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  ASSERT (intr_get_level () == INTR_OFF);<br><br>  lock_init (&amp;tid_lock);<br>  list_init (&amp;ready_list);<br>  list_init (&amp;all_list);<br><br>  <span class="hljs-comment">/* Set up a thread structure for the running thread. */</span><br>  initial_thread = running_thread ();<br>  init_thread (initial_thread, <span class="hljs-string">"main"</span>, PRI_DEFAULT);<br>  initial_thread-&gt;status = THREAD_RUNNING;<br>  initial_thread-&gt;tid = allocate_tid ();<br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br>  initial_thread-&gt;sleepticks = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>}<br><br><br><span class="hljs-comment">/*########################## thread.h ###########################*/</span><br><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><span class="hljs-type">void</span> <span class="hljs-title function_">check_and_unblock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* t, <span class="hljs-type">void</span>*aux UNUSED)</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">thread_cmp_priority</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem *a, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem *b, <span class="hljs-type">void</span> *aux UNUSED)</span>;<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br></code></pre></td></tr></tbody></table></figure><hr><h4 id="task2-priority">Task2: priority</h4><p>先来看看清单</p><figure class="highlight elixir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-number">0</span><span class="hljs-symbol">:priority-change</span><br><span class="hljs-number">1</span><span class="hljs-symbol">:priority-donate-one</span><br><span class="hljs-number">2</span><span class="hljs-symbol">:priority-donate-multiple</span><br><span class="hljs-number">3</span><span class="hljs-symbol">:priority-donate-multiple2</span><br><span class="hljs-number">4</span><span class="hljs-symbol">:priority-donate-nest</span><br><span class="hljs-number">5</span><span class="hljs-symbol">:priority-donate-sema</span><br><span class="hljs-number">6</span><span class="hljs-symbol">:priority-donate-lower</span><br><span class="hljs-number">7</span><span class="hljs-symbol">:priority-donate-chain</span><br><span class="hljs-number">8</span><span class="hljs-symbol">:priority-fifo</span><br><span class="hljs-number">9</span><span class="hljs-symbol">:priority-preempt</span><br><span class="hljs-number">10</span><span class="hljs-symbol">:priority-sema</span><br><span class="hljs-number">11</span><span class="hljs-symbol">:priority-condvar</span><br></code></pre></td></tr></tbody></table></figure><p>先做0、8、9，都是和抢占相关</p><p>在做10、11，都和进程同步互斥相关</p><p>最后做1-7，都是关于priority-donate的</p><hr><h5 id="分析priority-change-fifo-preempt">分析：Priority change, fifo, preempt</h5><p>这3个任务点都和抢占相关，需要注意以下3点：</p><ol type="1"><li>进程创建之初，若优先级高于running thread时，应当抢占。</li><li>当优先级改变在改变优先级之后，若优先级高于running thread的优先级，就抢占。</li><li>进程优先级相同时，要保证先进先出。</li></ol><p>对于抢占，只需要调用thread_yield即可，因为在alarm当中我们已经将thread_yield实现为优先级插入了。先进先出则时list_insert_ordered的所保证的，当它在插入时，如果优先级相同时，先来的会在后来的之前。</p><hr><h5 id="实现priority-change-fifo-preempt">实现：Priority change, fifo, preempt</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">tid_t</span> <span class="hljs-title function_">thread_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> priority, thread_func* function, <span class="hljs-type">void</span>* aux)</span> {<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span>* <span class="hljs-title">t</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kernel_thread_frame</span>* <span class="hljs-title">kf</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">switch_entry_frame</span>* <span class="hljs-title">ef</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">switch_threads_frame</span>* <span class="hljs-title">sf</span>;</span><br>  <span class="hljs-type">tid_t</span> tid;<br><br>  ASSERT(function != <span class="hljs-literal">NULL</span>);<br><br>  <span class="hljs-comment">/* Allocate thread. */</span><br>  t = palloc_get_page(PAL_ZERO);<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> TID_ERROR;<br><br>  <span class="hljs-comment">/* Initialize thread. */</span><br>  init_thread(t, name, priority);<br>  tid = t-&gt;tid = allocate_tid();<br><br>  <span class="hljs-comment">/* Stack frame for kernel_thread(). */</span><br>  kf = alloc_frame(t, <span class="hljs-keyword">sizeof</span> *kf);<br>  kf-&gt;eip = <span class="hljs-literal">NULL</span>;<br>  kf-&gt;function = function;<br>  kf-&gt;aux = aux;<br><br>  <span class="hljs-comment">/* Stack frame for switch_entry(). */</span><br>  ef = alloc_frame(t, <span class="hljs-keyword">sizeof</span> *ef);<br>  ef-&gt;eip = (<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>))kernel_thread;<br><br>  <span class="hljs-comment">/* Stack frame for switch_threads(). */</span><br>  sf = alloc_frame(t, <span class="hljs-keyword">sizeof</span> *sf);<br>  sf-&gt;eip = switch_entry;<br>  sf-&gt;ebp = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/* Add to run queue. */</span><br>  thread_unblock(t);<br><br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br>  <span class="hljs-keyword">if</span> (thread_current()-&gt;priority &lt; priority)<br>  {<br>    thread_yield();<br>  }<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br>  <span class="hljs-keyword">return</span> tid;<br>}<br><br><br><span class="hljs-comment">/* Sets the current thread's priority to NEW_PRIORITY. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">thread_set_priority</span><span class="hljs-params">(<span class="hljs-type">int</span> new_priority)</span> { <br>  thread_current()-&gt;priority = new_priority; <br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br>  thread_yield();  <br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>解决测试0后，会发现，测试8、9也pass了，为了节省篇幅，就不放测试8、9的源码。</p><p>简单解释一下8、9测试的主要过程。</p><p>8-priority-fifo：该测试程序事实上就是创建了16个优先级相同的进程，看优先级相同的进程是否为先进先出。这个能够通过，主要还是因为insert_list_ordered函数，本身就有这样的功能。</p><p>9-priority-preempt：该程序在创建时，指定了比主进程高1级的优先级，因此创建后，就立马执行了。然后每次thread_yield，运行过程：调度[thread_yield(将当前线程插到最后)-&gt;schedule(将下一线程丢出，并切换到下一线程)]。可以看到，每次yield由于thread的优先级高于主进程，因此主进程在该进程执行完，是不会得到运行的。因此得到的结果是，主线程最后才执行。</p><hr><h5 id="分析priority-sema-convar">分析：Priority sema, convar</h5><p>而我们实际上的输出，是没有“Thread priority xx woke up.”这类语句。原因在于，sema_up没有做线程切换的操作，自然没有使得主线程被抢占，让主线程一直进行到底。此外，sema的waiters队列还得该是一个优先级队列，这个从函数名字test_priority_sema就可以看出来，这sema_up的唤醒顺序应当是按优先级来的。</p><p>test_priority_convar也是同样的道理，它只是要实现优先级唤醒而已。</p><h5 id="实现priority-sema-convar">实现：Priority sema, convar</h5><p>实现部分如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*########################## synch.c ###########################*/</span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">sema_down</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sema)</span> <br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span>;</span><br><br>  ASSERT (sema != <span class="hljs-literal">NULL</span>);<br>  ASSERT (!intr_context ());<br><br>  old_level = intr_disable ();<br>  <span class="hljs-keyword">while</span> (sema-&gt;value == <span class="hljs-number">0</span>) <br>    {<br>    <span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br>      list_insert_ordered (&amp;sema-&gt;waiters, &amp;thread_current ()-&gt;elem, thread_cmp_priority, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br>      thread_block ();<br>    }<br>  sema-&gt;value--;<br>  intr_set_level (old_level);<br>}<br><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">sema_up</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sema)</span> <br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span>;</span><br><br>  ASSERT (sema != <span class="hljs-literal">NULL</span>);<br><br>  old_level = intr_disable ();<br>  <span class="hljs-keyword">if</span> (!list_empty (&amp;sema-&gt;waiters))<br>  { <br>    thread_unblock (list_entry (list_pop_front (&amp;sema-&gt;waiters),<br>                                <span class="hljs-keyword">struct</span> thread, elem));<br>  }<br>  sema-&gt;value++;<br>  <span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br>  thread_yield();<br>  <span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br>  intr_set_level (old_level);<br>}<br><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">cond_signal</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> condition *cond, <span class="hljs-keyword">struct</span> lock *lock UNUSED)</span> <br>{<br>  ASSERT (cond != <span class="hljs-literal">NULL</span>);<br>  ASSERT (lock != <span class="hljs-literal">NULL</span>);<br>  ASSERT (!intr_context ());<br>  ASSERT (lock_held_by_current_thread (lock));<br><br>  <span class="hljs-keyword">if</span> (!list_empty (&amp;cond-&gt;waiters)){<br>    <span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br>    list_sort(&amp;cond-&gt;waiters, cond_cmp_priority, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br>    sema_up (&amp;list_entry (list_pop_front (&amp;cond-&gt;waiters),<br>                          <span class="hljs-keyword">struct</span> semaphore_elem, elem)-&gt;semaphore);<br>  }<br>}<br><br><br><span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br><span class="hljs-type">bool</span><br><span class="hljs-title function_">cond_cmp_priority</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem *a, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem *b, <span class="hljs-type">void</span> *aux UNUSED)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore_elem</span> *<span class="hljs-title">sa</span> =</span> list_entry (a, <span class="hljs-keyword">struct</span> semaphore_elem, elem);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore_elem</span> *<span class="hljs-title">sb</span> =</span> list_entry (b, <span class="hljs-keyword">struct</span> semaphore_elem, elem);<br>  <span class="hljs-keyword">return</span> list_entry(list_front(&amp;sa-&gt;semaphore.waiters), <span class="hljs-keyword">struct</span> thread, elem)-&gt;priority &gt; list_entry(list_front(&amp;sb-&gt;semaphore.waiters), <span class="hljs-keyword">struct</span> thread, elem)-&gt;priority;<br>}   <br><span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br><br></code></pre></td></tr></tbody></table></figure><hr><h5 id="分析priority-donate">分析：Priority donate</h5><p>优先级捐赠往往是为了防止<strong>优先级反置</strong>而设置的。</p><p>举个例子：有3个线程——老大、老二和老三。根据优先级调度的规则，先执行的是老大，但是老大的执行需要老三提供相应的资源（在程序中可能体现的是老三占有了某资源的锁），因此老大被阻塞。但由于优先级调度的规则，老二先执行。然后再是老三，老三释放锁后，老大才能执行。可以看到，老大作为最高优先级的线程，却最后才完成（<strong>优先级反置</strong>）。有个解决方法是，老大将自己的优先级捐赠给老三，这样老三就能先于老二执行，老三释放锁后，老大就能执行了。</p><p>明确思路与需求：</p><p>线程之间直接捐赠的程序设计，比较复杂，不好维护。通过阅读别人的代码，我发现，原来可以<strong>利用锁间接地捐赠优先级</strong>。考虑如下两种特殊情况：</p><ul><li><p><strong>多重捐赠</strong>：一个线程占有多个锁，而者些资源又为其他高优先级的资源锁需要。如下图所示，31线程有2个锁，而分别被32、33、34锁需要，其中一个锁又被2个线程需要。<strong>绿线</strong>表示已占用（<strong>held</strong>），<strong>红线</strong>表示正在申请（<strong>applying</strong>）。</p><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/task2_pic1.png"></p><ul><li><p>思路：每一个线程可以维护一个锁的链表，表示这个线程所占有的所有锁。而后，每个锁可能被多个进程锁需要，我们可以将让锁携带这些进程的最大优先级，然后传递给低优先级。然后再释放一个锁后，要重新更新优先级，以保持从锁中获取同样的操作。下图描述了整个过程。可以发现，在获得锁的时候做了两件事：<strong>1. 获得持有该锁进程的最大优先级；2. 向低优先级线程传递所有锁中的最大优先级。</strong>而在释放锁的时候，则做了这样两件事：<strong>1. 使锁的优先级为最小。2. 对锁持有者的优先级进行更新，方法和上述一样，从该线程占有的所有锁中取最大的优先级。</strong></p><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/task2_pic2.png"></p><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/task2_pic3.png"></p></li></ul></li><li><p><strong>递归捐赠</strong>：线程之间资源占用情况形成链状，如下图所示。那么33线程的优先级将沿着这条链一直捐到底</p><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/task2_pic4.png"></p><ul><li><p>思路：对于这种情况，就让优先级顺着锁往下传递。如下图所示。</p><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/task2_pic5.png"></p></li></ul></li></ul><h5 id="实现priority-donate">实现：Priority donate</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*########################## thread.h ###########################*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span></span><br><span class="hljs-class">  {</span><br>    <span class="hljs-comment">/* Owned by thread.c. */</span><br>    <span class="hljs-type">tid_t</span> tid;                          <span class="hljs-comment">/* Thread identifier. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">thread_status</span> <span class="hljs-title">status</span>;</span>          <span class="hljs-comment">/* Thread state. */</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">16</span>];                      <span class="hljs-comment">/* Name (for debugging purposes). */</span><br>    <span class="hljs-type">uint8_t</span> *<span class="hljs-built_in">stack</span>;                     <span class="hljs-comment">/* Saved stack pointer. */</span><br>    <span class="hljs-type">int</span> priority;                       <span class="hljs-comment">/* Priority. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> <span class="hljs-title">allelem</span>;</span>           <span class="hljs-comment">/* List element for all threads list. */</span><br><br>    <span class="hljs-comment">/* Shared between thread.c and synch.c. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> <span class="hljs-title">elem</span>;</span>              <span class="hljs-comment">/* List element. */</span><br><br>    <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><br>    <span class="hljs-type">int</span> sleepticks;<span class="hljs-comment">/* 剩余休眠的时间 */</span><br>    <span class="hljs-type">int</span> original_priority;              <span class="hljs-comment">/* 原始优先级 */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> <span class="hljs-title">locks</span>;</span>                  <span class="hljs-comment">/* 占有的锁队列*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span>* <span class="hljs-title">lock_applying</span>;</span><span class="hljs-comment">/* 申请中的锁*/</span><br><br>    <span class="hljs-comment">/*--------------------------------------------------------*/</span> <br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USERPROG</span><br>    <span class="hljs-comment">/* Owned by userprog/process.c. */</span><br>    <span class="hljs-type">uint32_t</span> *pagedir;                  <span class="hljs-comment">/* Page directory. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* Owned by thread.c. */</span><br>    <span class="hljs-type">unsigned</span> magic;                     <span class="hljs-comment">/* Detects stack overflow. */</span><br>  };<br><br>    <br><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><span class="hljs-type">void</span> <span class="hljs-title function_">thread_hold_the_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock* lock)</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">lock_cmp_priority</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem* a, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem* b, <span class="hljs-type">void</span>* aux UNUSED)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">remove_lock</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *lock)</span>;<br><span class="hljs-comment">/* 从捐赠者队列中获取最高优先级  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">update_priority</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* t)</span>;<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br><br></code></pre></td></tr></tbody></table></figure><hr><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*########################## synch.h ###########################*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> </span><br><span class="hljs-class">  {</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">holder</span>;</span>      <span class="hljs-comment">/* Thread holding lock (for debugging). */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> <span class="hljs-title">semaphore</span>;</span> <span class="hljs-comment">/* Binary semaphore controlling access. */</span><br>    <br>    <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> <span class="hljs-title">elem</span>;</span><br>    <span class="hljs-type">int</span> max_priority;<br>    <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  };<br><br></code></pre></td></tr></tbody></table></figure><hr><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*########################## thread.c ###########################*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">init_thread</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> thread *t, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> priority)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span>;</span><br><br>  ASSERT (t != <span class="hljs-literal">NULL</span>);<br>  ASSERT (PRI_MIN &lt;= priority &amp;&amp; priority &lt;= PRI_MAX);<br>  ASSERT (name != <span class="hljs-literal">NULL</span>);<br><br>  <span class="hljs-built_in">memset</span> (t, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> *t);<br>  t-&gt;status = THREAD_BLOCKED;<br>  strlcpy (t-&gt;name, name, <span class="hljs-keyword">sizeof</span> t-&gt;name);<br>  t-&gt;<span class="hljs-built_in">stack</span> = (<span class="hljs-type">uint8_t</span> *) t + PGSIZE;<br>  t-&gt;priority = priority;<br>  t-&gt;magic = THREAD_MAGIC;<br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span><br>  t-&gt;sleepticks = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">/* 初始化捐赠队列锁，原始priority，正在申请的锁 */</span><br>  list_init(&amp;t-&gt;locks);<br>  t-&gt;original_priority = priority;<br>  t-&gt;lock_applying = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  old_level = intr_disable ();<br>  list_insert_ordered (&amp;all_list, &amp;t-&gt;allelem, &amp;thread_cmp_priority, <span class="hljs-literal">NULL</span>);<br>  intr_set_level (old_level);<br>}<br><br><br><br><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span><br><span class="hljs-comment">/* 比较锁的最大优先级函数 */</span><br><span class="hljs-type">bool</span><br><span class="hljs-title function_">lock_cmp_priority</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem* a, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem* b, <span class="hljs-type">void</span>* aux UNUSED)</span><br>{<br>  <span class="hljs-keyword">return</span> list_entry(a, <span class="hljs-keyword">struct</span> lock, elem)-&gt;max_priority &gt; list_entry(b, <span class="hljs-keyword">struct</span> lock, elem)-&gt;max_priority;<br>}<br><br><span class="hljs-comment">/* 该函数的作用是让进程拥有该锁，即把锁推入进程的尺有所队列中</span><br><span class="hljs-comment"> * 如果锁的最大优先级比当前进程高，就将锁的优先级捐赠给当前进程</span><br><span class="hljs-comment"> * 并抢占调度。从而实现优先级捐赠。 */</span><br><span class="hljs-type">void</span> <br><span class="hljs-title function_">thread_hold_the_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock* lock)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();<br>  list_push_back(&amp;thread_current()-&gt;locks, &amp;lock-&gt;elem);<br>  <span class="hljs-keyword">if</span>(lock-&gt;max_priority &gt; thread_current()-&gt;priority)<br>  {<br>    thread_current()-&gt;priority = lock-&gt;max_priority;<br>    thread_yield();<br>  }<br>  intr_set_level(old_level);<br>}<br><br><span class="hljs-comment">/* 从将线程持有的锁（如果持有），根据锁的最大优先级从大到小排序。</span><br><span class="hljs-comment"> * 比较锁的最大优先级，选择自己本身优先级和锁的最大优先级中的</span><br><span class="hljs-comment"> * 较大者作为自己的优先级。如果没有锁，自然就回归自己的原始优先</span><br><span class="hljs-comment"> * 级。*/</span> <br><span class="hljs-type">void</span> <br><span class="hljs-title function_">update_priority</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* t)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();<br>  <span class="hljs-type">int</span> lock_priority = PRI_MIN;<br>  <span class="hljs-keyword">if</span>(!list_empty(&amp;t-&gt;locks))<br>  {<br>    list_sort(&amp;t-&gt;locks, lock_cmp_priority, <span class="hljs-literal">NULL</span>);<br>    lock_priority = list_entry(list_front(&amp;t-&gt;locks), <span class="hljs-keyword">struct</span> lock, elem)-&gt;max_priority;<br>  }<br>  t-&gt;priority = (lock_priority &gt; t-&gt;original_priority ? lock_priority:t-&gt;original_priority);<br>  intr_set_level(old_level);<br>}<br><br><span class="hljs-comment">/* 将锁从线程的持有锁队列中释放，调用该函数的时机应当是</span><br><span class="hljs-comment"> * 释放锁的时候。  */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">remove_lock</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *lock)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable ();<br>  list_remove (&amp;lock-&gt;elem);<br>  update_priority (thread_current ());<br>  intr_set_level (old_level);<br>}<br><br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br></code></pre></td></tr></tbody></table></figure><hr><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*########################## synch.c ###########################*/</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">lock_init</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *lock)</span><br>{<br>  ASSERT (lock != <span class="hljs-literal">NULL</span>);<br><br>  lock-&gt;holder = <span class="hljs-literal">NULL</span>;<br>  sema_init (&amp;lock-&gt;semaphore, <span class="hljs-number">1</span>);<br><br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  lock-&gt;max_priority = PRI_MIN - <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>}<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">lock_acquire</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *lock)</span><br>{<br>  ASSERT (lock != <span class="hljs-literal">NULL</span>);<br>  ASSERT (!intr_context ());<br>  ASSERT (!lock_held_by_current_thread (lock));<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 首先将该锁置于申请中的状态，然后先判断锁是否被占用，</span><br><span class="hljs-comment">   * 1. 如果没人占用它，则无需捐献，跳过这里，与原函数操作相同</span><br><span class="hljs-comment">   * 2. 如果有人占用它，那么首先判断，递归地捐赠优先级。即，</span><br><span class="hljs-comment">   * 如果该占用者的优先级比自己低，那么捐赠优先级；如果被捐赠者</span><br><span class="hljs-comment">   * 也在申请其他锁，那么就给该锁的占用者捐赠优先级，不断下去</span><br><span class="hljs-comment">   * 直至一个进程没有正在申请的锁为止。*/</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span>* <span class="hljs-title">cur_thread</span> =</span> thread_current();<br>  cur_thread-&gt;lock_applying = lock;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span>* <span class="hljs-title">pre_lock</span> =</span> lock;<br>  <span class="hljs-keyword">while</span>(pre_lock != <span class="hljs-literal">NULL</span> &amp;&amp; pre_lock-&gt;holder != <span class="hljs-literal">NULL</span> &amp;&amp; pre_lock-&gt;max_priority &lt; cur_thread-&gt;priority)<br>  {<br>    pre_lock-&gt;max_priority = cur_thread-&gt;priority;<br>    update_priority(pre_lock-&gt;holder);<br>    pre_lock = pre_lock-&gt;holder-&gt;lock_applying;<br><br>  }<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  sema_down (&amp;lock-&gt;semaphore);<br>  lock-&gt;holder = thread_current ();<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 若成功获得该锁，那么该进程就没有正在申请的锁，归0</span><br><span class="hljs-comment">   * 并且在申请成功后，该锁的最大优先级显然和该进程相同。</span><br><span class="hljs-comment">   * 并将该锁推入进程的locks队列中，表示该锁已被得到 */</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();<br>  cur_thread-&gt;lock_applying = <span class="hljs-literal">NULL</span>;<br>  lock-&gt;max_priority = cur_thread-&gt;priority;<br>  thread_hold_the_lock(lock);<br>  intr_set_level(old_level);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>}<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">lock_release</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *lock)</span> <br>{<br>  ASSERT (lock != <span class="hljs-literal">NULL</span>);<br>  ASSERT (lock_held_by_current_thread (lock));<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 结束后，将其从线程锁列表中释放，并将最大优先级归0 */</span><br>  remove_lock(lock);<br>  lock-&gt;max_priority = PRI_MIN<span class="hljs-number">-1</span>;<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br>  lock-&gt;holder = <span class="hljs-literal">NULL</span>;<br>  sema_up (&amp;lock-&gt;semaphore);<br>}<br><br><br></code></pre></td></tr></tbody></table></figure><hr><h4 id="task3-mlfqs">Task3: mlfqs</h4><h5 id="分析-1">分析</h5><p>多级反馈队列调度。具体内容参考手册P91</p><p>我稍微说明以下要点：</p><ol type="1"><li><p>三大公式：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">priority = PRI_MAX - (recent_cpu / <span class="hljs-number">4</span>) - (nice * <span class="hljs-number">2</span>),<br>recent_cpu = (<span class="hljs-number">2</span>*load_avg)/(<span class="hljs-number">2</span>*load_avg + <span class="hljs-number">1</span>) * recent_cpu + nice<br>load_avg = (<span class="hljs-number">59</span>/<span class="hljs-number">60</span>)*load_avg + (<span class="hljs-number">1</span>/<span class="hljs-number">60</span>)*ready_threads<br></code></pre></td></tr></tbody></table></figure></li><li><p>三个更新时间：</p><ol type="1"><li>recent_cpu: 每个tick后+1，且每秒也就是每TIMER_FREQ个ticks根据公式更新一次，线程成员变量</li><li>load_avg: 每秒也就是每TIMER_FREQ个ticks根据公式更新一次，初始值为0，全局变量</li><li>priority: 每4个tick更新一次。范围应限制在PRI_MIN到PRI_MAX内</li></ol></li></ol><p>优先级、load_avg等计算都是实数计算，但pintos不支持。如下图所示，是手册给予的顶点实数计算公式。可以看到，定点实数的取整、乘法、除法是需要重新定义的，而其他与整数运算相同。我们只需要加个头文件，对这些需要重新定义的计算进行宏定义即可。</p><h5 id="实现-1">实现</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*########################## fixed_point.c ###########################*/</span><br><span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br><span class="hljs-comment">/* 定点实数计算</span><br><span class="hljs-comment"> * 我们将后14为定义为小数</span><br><span class="hljs-comment"> * 因此当整数转化为小数时，直接左移14位即可，反之，同理</span><br><span class="hljs-comment"> * 然后定点实数的加减运算不需要重新定义，与整数保持一致</span><br><span class="hljs-comment"> * 乘法，则只要两数相乘最后再14位即可</span><br><span class="hljs-comment"> * 除法，对于定点实数除法，也需要被除数先左移14位再除</span><br><span class="hljs-comment"> * 对于实数转整数，则有直接截尾和四舍五入两种方式  */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> FIXED_POINT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIXED_POINT_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Q 14</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> F (1 &lt;&lt; Q)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT_TO_FP(n) ((n) &lt;&lt; Q)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FP_TO_INT(x) ((x) &gt;&gt; Q)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FP_TO_ROUND_INT(x) ((x) &gt;= 0  ? FP_TO_INT((x) + (F &gt;&gt; 1)) : \</span><br><span class="hljs-meta">                              FP_TO_INT((x) - (F &gt;&gt; 1)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FP_MUL(x, y) ((int) ((((int64_t) (x)) * (y)) &gt;&gt; Q))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FP_DIV(x, y) ((int) ((((int64_t) (x)) &lt;&lt; Q) / (y)))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><br><br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br><br><span class="hljs-comment">/* 记得在thread.c, timer.c下添加该头文件 */</span><br><span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"threads/fixed_point.h"</span></span><br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br></code></pre></td></tr></tbody></table></figure><p>根据上述的归纳我们可以将更新部分的骨架(skeleton)给写了</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">timer_interrupt</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame *args UNUSED)</span><br>{<br>  ticks++;<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  thread_foreach (check_and_unblock, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-comment">/* 针对mlfqs任务  */</span><br>  <span class="hljs-keyword">if</span>(thread_mlfqs)<br>  {<br>    <span class="hljs-comment">/* 每个tick，正在执行进程的recent_cpu++。</span><br><span class="hljs-comment">     * 空闲进程无需计算recent_cpu */</span><br>    <span class="hljs-keyword">if</span>(!is_idle_thread(thread_current()))<br>      thread_current()-&gt;recent_cpu += INT_TO_FP(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">/* 每秒种计算一次load_avg以及recent_cpu</span><br><span class="hljs-comment">     * 每4个ticks(其实就是时间片长度)更新一次priority */</span><br>    <span class="hljs-keyword">if</span>(ticks % TIMER_FREQ == <span class="hljs-number">0</span>)<br>    {<br>      calculate_mlfqs_load_avg();<br>      update_mlfqs_recent_cpu();<br>      update_mlfqs_priority();<br>    }<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ticks % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>)<br>    {<br>      update_mlfqs_priority_aux(thread_current(), <span class="hljs-literal">NULL</span>);<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">      用于调试</span><br><span class="hljs-comment">      msg("load_avg %d",thread_get_load_avg());</span><br><span class="hljs-comment">      msg("priority: %d", thread_current()-&gt;priority);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      msg("tid: %d", thread_current()-&gt;tid);</span><br><span class="hljs-comment">      msg("recent_cp %d", thread_current()-&gt;recent_cpu);</span><br><span class="hljs-comment">      */</span><br>    }  <br>  }<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  thread_tick ();<br>}<br></code></pre></td></tr></tbody></table></figure><p>然后具体对更新recent_cpu、load_avg、priority进行实现。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br><span class="hljs-comment">/* 判断是否为空闲程序  */</span><br><span class="hljs-type">bool</span><br><span class="hljs-title function_">is_idle_thread</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* t)</span><br>{<br>  <span class="hljs-keyword">return</span> t == idle_thread;<br>}<br><br><span class="hljs-comment">/* 计算loag_avg函数 */</span><br><span class="hljs-type">void</span> <br><span class="hljs-title function_">calculate_mlfqs_load_avg</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();<br>  <span class="hljs-type">int</span> ready_threads = list_size(&amp;ready_list) +(thread_current() != idle_thread);<br>  load_avg = FP_MUL(INT_TO_FP(<span class="hljs-number">59</span>) / <span class="hljs-number">60</span>, load_avg) + INT_TO_FP(<span class="hljs-number">1</span>) / <span class="hljs-number">60</span> * ready_threads;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  用于调试：</span><br><span class="hljs-comment">  msg("ready_threads %d", ready_threads);</span><br><span class="hljs-comment">  msg("load_avg %d", load_avg);</span><br><span class="hljs-comment">  msg("load_avg %d", thread_get_load_avg());</span><br><span class="hljs-comment">  msg("idle %d", idle_thread-&gt;priority);</span><br><span class="hljs-comment">  */</span><br>  intr_set_level(old_level);<br>}<br><br><span class="hljs-comment">/* 更新recent_cpu接口 */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">update_mlfqs_recent_cpu_aux</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* t, <span class="hljs-type">void</span>* aux UNUSED)</span><br>{<br>  <span class="hljs-keyword">if</span>(is_idle_thread(t))<br>    <span class="hljs-keyword">return</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();<br>  <br>  t-&gt;recent_cpu = FP_MUL(FP_DIV(load_avg * <span class="hljs-number">2</span>, load_avg * <span class="hljs-number">2</span> + INT_TO_FP(<span class="hljs-number">1</span>)), t-&gt;recent_cpu) + INT_TO_FP(t-&gt;nice);<br><br>  intr_set_level(old_level);<br>}<br><br><span class="hljs-comment">/* 调用更新recent_cpu接口对每个线程recent_cpu更新 */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">update_mlfqs_recent_cpu</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  thread_foreach (update_mlfqs_recent_cpu_aux, <span class="hljs-literal">NULL</span>);<br>}<br><br><span class="hljs-comment">/* 优先级更新接口 */</span><br><span class="hljs-type">void</span> <br><span class="hljs-title function_">update_mlfqs_priority_aux</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* t, <span class="hljs-type">void</span>* aux UNUSED)</span><br>{<br><br>  <span class="hljs-keyword">if</span>(is_idle_thread(t))<br>    <span class="hljs-keyword">return</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();<br><br>  t-&gt;priority = (FP_TO_INT(INT_TO_FP(PRI_MAX) - t-&gt;recent_cpu / <span class="hljs-number">4</span> - INT_TO_FP(t-&gt;nice * <span class="hljs-number">2</span>)));<br>  t-&gt;priority = t-&gt;priority &lt; PRI_MIN ? PRI_MIN : t-&gt;priority;<br>  t-&gt;priority = t-&gt;priority &gt; PRI_MAX ? PRI_MAX : t-&gt;priority;<br><br>  intr_set_level(old_level);<br>}<br><br><span class="hljs-comment">/* 调用更新优先级接口对每个线程优先级更新 */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">update_mlfqs_priority</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  thread_foreach (update_mlfqs_priority_aux, <span class="hljs-literal">NULL</span>);<br>}<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br></code></pre></td></tr></tbody></table></figure><p>当然，原来的代码中是没有load_avg、nice、recent_cpu。load_avg是全局变量，而nice、recent_cpu则处于线程。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NICE_MIN -20 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NICE_MAX 20</span><br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br><span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> load_avg;<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br><span class="hljs-comment">/* struct thread 中添加 */</span><br>    <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><br>    <span class="hljs-type">int</span> nice;<br>    <span class="hljs-type">int</span> recent_cpu;<br><br>    <span class="hljs-comment">/*--------------------------------------------------------*/</span> <br><br></code></pre></td></tr></tbody></table></figure><p>此外题目还要求我们实现，thread_set_nice、thread_get_nice、thread_get_load_avg、thread_get_recent_cpu。他们已经为我们准备好了骨架。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span><br><span class="hljs-comment">/* Sets the current thread's nice value to NICE. */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">thread_set_nice</span> <span class="hljs-params">(<span class="hljs-type">int</span> nice)</span> <br>{<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span>;</span><br>  old_level = intr_disable ();<br><br>  nice = (nice &gt; NICE_MAX ? : NICE_MAX, nice);<br>  nice = (nice &lt; NICE_MIN ? : NICE_MIN, nice);<br>          <br>  thread_current ()-&gt;nice = nice;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  调试用</span><br><span class="hljs-comment">  msg("tid: %d nice: %d", thread_current()-&gt;tid , nice);</span><br><span class="hljs-comment">  */</span><br>  update_mlfqs_priority_aux (thread_current (), <span class="hljs-literal">NULL</span>);<br>  thread_yield();<br>  <br>  intr_set_level (old_level);<br>}<br><br><span class="hljs-comment">/* Returns the current thread's nice value. */</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">thread_get_nice</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>{<br>  <span class="hljs-keyword">return</span> thread_current ()-&gt;nice;<br>}<br><br><span class="hljs-comment">/* Returns 100 times the system load average. */</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">thread_get_load_avg</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>{<br>  <br>  <span class="hljs-keyword">return</span> FP_TO_ROUND_INT(load_avg * <span class="hljs-number">100</span>);<br>}<br><br><span class="hljs-comment">/* Returns 100 times the current thread's recent_cpu value. */</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">thread_get_recent_cpu</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>{<br>  <span class="hljs-keyword">return</span> FP_TO_ROUND_INT(thread_current ()-&gt;recent_cpu * <span class="hljs-number">100</span>);<br><br>}<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br></code></pre></td></tr></tbody></table></figure><p>然后为了这道题目，<strong>需要对第二题做必要的修改。</strong>这将在Q&amp;A中提到。</p><h4 id="qa-1">Q&amp;A</h4><ul><li><p><strong>Q1：原本的实现思路是开辟一个新的sleep_queue去完成代码，但实现过程中出现诸多麻烦。</strong></p><ul><li>Answer：发现函数中有thread_foreach，这是为all_list量身定制的，那么为何不用all_list+标志位实现阻塞队列呢？</li></ul></li><li><p><strong>Q2：在实现任务4、任务5时出现死机的现象</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">timer_sleep</span> <span class="hljs-params">(<span class="hljs-type">int64_t</span> ticks)</span><br>{<br>  <span class="hljs-type">int64_t</span> start = timer_ticks ();<br><br>  ASSERT (intr_get_level () == INTR_ON);<br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br>  <span class="hljs-comment">/* 关闭中断，基操 */</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();<br>  <br>  <span class="hljs-comment">/* 获取当前线程，并存入休眠时间，阻塞进程 */</span><br>   thread_current() -&gt; sleepticks = ticks;<br>   thread_block();<br>    <br>  intr_set_level(old_level);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>}<br><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">check_and_unblock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* t, <span class="hljs-type">void</span>*aux UNUSED)</span><br>{<br>    t-&gt;sleepticks --;<br>    <span class="hljs-keyword">if</span> (t-&gt;sleepticks == <span class="hljs-number">0</span>) <span class="hljs-comment">// ==0? wrong</span><br>    {<br>      thread_unblock(t);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li><p>Answer: 原因是因为，当thread_current的休眠时间为0甚至为负数时，它仍然会阻塞，而check_and_unblock的代码中，由于t-&gt;sleepticks --，因此t-&gt;sleepticks == 0永远都无法实现，进程永远被阻塞。改进代码如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">timer_sleep</span> <span class="hljs-params">(<span class="hljs-type">int64_t</span> ticks)</span><br>{  <br>    <span class="hljs-type">int64_t</span> start = timer_ticks ();<br>    ASSERT (intr_get_level () == INTR_ON);  <br>    <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span>   <br>    <span class="hljs-comment">/* 关闭中断，基操 */</span>  <br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();    <br>    <span class="hljs-comment">/* 获取当前线程，并存入休眠时间，阻塞进程, 注意如果ticks&lt;=0则无需阻塞*/</span>       <br>    <span class="hljs-keyword">if</span>(ticks &gt; <span class="hljs-number">0</span>)   <br>    {     <br>        thread_current() -&gt; sleepticks = ticks;     <br>        thread_block();   <br>    }      <br>    intr_set_level(old_level);  <br>    <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>}<br><span class="hljs-type">void</span><br><span class="hljs-title function_">check_and_unblock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* t, <span class="hljs-type">void</span>*aux UNUSED)</span><br>{  <br>  <span class="hljs-comment">/* 如果它本身没被阻塞，其实也就没必要去unblock了，小于0什么的根本不会被  阻塞，更无需讨论 */</span>  <br>  <span class="hljs-keyword">if</span> (t-&gt;status == THREAD_BLOCKED &amp;&amp; t-&gt;sleepticks &gt; <span class="hljs-number">0</span>)  <br>  {    <br>    t-&gt;sleepticks --;    <br>    <span class="hljs-keyword">if</span> (t-&gt;sleepticks &lt;= <span class="hljs-number">0</span>)    <br>    {      <br>      thread_unblock(t);    <br>     }  <br>  }<br>}<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>Q3：在实现priority condvar时，原本是和sema等一样，在插入时实现优先级排序。但会报错。</strong></p><ul><li>Answer：</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br><span class="hljs-type">bool</span><br><span class="hljs-title function_">cond_cmp_priority</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem *a, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> list_elem *b, <span class="hljs-type">void</span> *aux UNUSED)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore_elem</span> *<span class="hljs-title">sa</span> =</span> list_entry (a, <span class="hljs-keyword">struct</span> semaphore_elem, elem);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore_elem</span> *<span class="hljs-title">sb</span> =</span> list_entry (b, <span class="hljs-keyword">struct</span> semaphore_elem, elem);<br>  <span class="hljs-keyword">return</span> list_entry(list_front(&amp;sa-&gt;semaphore.waiters), <span class="hljs-keyword">struct</span> thread, elem)-&gt;priority &gt; list_entry(list_front(&amp;sb-&gt;semaphore.waiters), <span class="hljs-keyword">struct</span> thread, elem)-&gt;priority;<br>}   <br><span class="hljs-comment">/*-------------------------mycode-------------------------*/</span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">cond_wait</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> condition *cond, <span class="hljs-keyword">struct</span> lock *lock)</span> <br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore_elem</span> <span class="hljs-title">waiter</span>;</span><br><br>  ASSERT (cond != <span class="hljs-literal">NULL</span>);<br>  ASSERT (lock != <span class="hljs-literal">NULL</span>);<br>  ASSERT (!intr_context ());<br>  ASSERT (lock_held_by_current_thread (lock));<br>  <br>  sema_init (&amp;waiter.semaphore, <span class="hljs-number">0</span>);<br>  list_push_back (&amp;cond-&gt;waiters, &amp;waiter.elem);<br>  lock_release (lock);<br>  sema_down (&amp;waiter.semaphore);<br>  lock_acquire (lock);<br>}<br><br><br><br></code></pre></td></tr></tbody></table></figure><p>从代码中可以看到，倘若将push_back改为insert_order，比较函数是比较semaphore的waiter中第一个线程的priority，而此时还未经sema_down，waiter中是空的，没有线程。因此会引发错误。那是否可以将插入放在sema_down之后呢？显然也不行，sema_down会将当前线程阻塞，插入操作无法立即执行。一个解决方法是，<strong>我们在sema_up的时候的对线程进行排序也是可以的</strong>。</p></li><li><p><strong>Q4：写完project1后，测试userprog会出现这样的错误。而这在完成project1之前是不会出现这样的现象的。</strong></p><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/task2_Q2.png"></p><ul><li>Answer: stack overflow上也有人碰到了类似的问题，参考：https://stackoverflow.com/questions/52472084/pintos-userprog-all-tests-fail-is-kernel-vaddr。</li></ul><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/schedule_before_thread_start.png"> 如上图所示，这是在init.c中，userprog任务调用的tss_init函数，根据调用关系，我们看到，它调用了lock_release函数函数，而在我们上述代码的实现里，lock_release调用了thread_yield，而此时还未调用thread_start对线程进行必要的初始化，不可以启用调度。因此解决方法是设一个标志位，在thread_start之前不要启用lock_release的thread_yield。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在thread.c中添加</span><br><span class="hljs-comment">/* 这一标志位是为了防止userprog在thread初始化前调度 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">bool</span> thread_started;<br><span class="hljs-comment">/* 判断线程是否开始  */</span><br><span class="hljs-type">bool</span> <br><span class="hljs-title function_">is_thread_started</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{<br>  <span class="hljs-keyword">return</span> thread_started;<br>}<br><span class="hljs-comment">// 在thread.h中声明</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">is_thread_started</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-comment">// 在synch.c的sema_up中添加 </span><br><span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br><span class="hljs-keyword">if</span> (is_thread_started())<br>{<br>  thread_yield();<br>}<br><br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br></code></pre></td></tr></tbody></table></figure><p>你以为这样就完了吗？并没有，我解决掉这个问题后，又会报这样的错误：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">../../threads/thread.c:495 in thread_yield(): assertion `!intr_context ()' failed.<br></code></pre></td></tr></tbody></table></figure><p>这又是什么鬼呢？使用gdb经过调试后发现，在初始化的时候sema_up会被内部中断调用，虽然我不知道具体原因，但只能说，sema_up里面压根就不能放thread_yield。而实际上，这一题的thread_yield完全可以放在lock_release里头。以下是最终的修改。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 把以下内容添加至lock_release结尾，并删除sema_up中的相应内容。</span><br><span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br><span class="hljs-keyword">if</span> (is_thread_started())<br>{<br>  thread_yield();<br>}<br><br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br></code></pre></td></tr></tbody></table></figure></li><li><p><strong>Q5：以下这三个测试点是相当玄幻的。</strong></p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">tests<span class="hljs-regexp">/threads/m</span>lfqs-load-<span class="hljs-number">60</span><br>tests<span class="hljs-regexp">/threads/m</span>lfqs-load-avg<br>tests<span class="hljs-regexp">/threads/m</span>lfqs-recent-<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><ul><li><p>Answer:</p><p>第一种情况，本地压根就没通过。mlfqs-load-avg大部分都不太满足，第一是看你的公式对不对，如果公式无误甚至非常完美，那么就要考虑对第二题所有的在获得锁时添加的代码，设置为thread_mlfqs不可见，如下。同理，<strong>在释放锁时也要做相应设置。</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br><span class="hljs-comment">/* 首先将该锁置于申请中的状态，然后先判断锁是否被占用，</span><br><span class="hljs-comment"> * 1. 如果没人占用它，则无需捐献，跳过这里，与原函数操作相同</span><br><span class="hljs-comment"> * 2. 如果有人占用它，那么首先判断，递归地捐赠优先级。即，</span><br><span class="hljs-comment"> * 如果该占用者的优先级比自己低，那么捐赠优先级；如果被捐赠者</span><br><span class="hljs-comment"> * 也在申请其他锁，那么就给该锁的占用者捐赠优先级，不断下去</span><br><span class="hljs-comment"> * 直至一个进程没有正在申请的锁为止。*/</span><br><span class="hljs-keyword">if</span>(!thread_mlfqs)<br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span>* <span class="hljs-title">cur_thread</span> =</span> thread_current();<br>  cur_thread-&gt;lock_applying = lock;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span>* <span class="hljs-title">pre_lock</span> =</span> lock<br>  <span class="hljs-title function_">while</span><span class="hljs-params">(pre_lock != <span class="hljs-literal">NULL</span> &amp;&amp; pre_lock-&gt;holder != <span class="hljs-literal">NULL</span> &amp;&amp; pre_lock-&gt;max_priority &lt; cur_thread-&gt;priority)</span><br>  {<br>    pre_lock-&gt;max_priority = cur_thread-&gt;priority;<br>    update_priority(pre_lock-&gt;holder);<br>    pre_lock = pre_lock-&gt;holder-&gt;lock_applying;<br>  }<br>}<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br>    <br><span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br><span class="hljs-comment">/* 若成功获得该锁，那么该进程就没有正在申请的锁，归0</span><br><span class="hljs-comment"> * 并且在申请成功后，该锁的最大优先级显然和该进程相同。</span><br><span class="hljs-comment"> * 并将该锁推入进程的locks队列中，表示该锁已被得到 */</span><br><span class="hljs-keyword">if</span>(!thread_mlfqs)<br>{<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span>* <span class="hljs-title">cur_thread</span> =</span> thread_current();<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_level</span> <span class="hljs-title">old_level</span> =</span> intr_disable();<br>cur_thread-&gt;lock_applying = <span class="hljs-literal">NULL</span>;<br>lock-&gt;max_priority = cur_thread-&gt;priority;<br>thread_hold_the_lock(lock);<br>intr_set_level(old_level);<br>}<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br>    <br></code></pre></td></tr></tbody></table></figure><p>其实，这在测试文件mlfqs-load-avg有提到。如下，在comment中，他说很可能是因为你的中断做了太多操作，浪费了大量时间，导致主线程没有足够多的线程去输出信息。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Starts 60 threads numbered 0 through 59.  Thread #i sleeps for</span><br><span class="hljs-comment">   (10+i) seconds, then spins in a loop for 60 seconds, then</span><br><span class="hljs-comment">   sleeps until a total of 120 seconds have passed.  Every 2</span><br><span class="hljs-comment">   seconds, starting 10 seconds in, the main thread prints the</span><br><span class="hljs-comment">   load average.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   The expected output is listed below.  Some margin of error is</span><br><span class="hljs-comment">   allowed.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   If your implementation fails this test but passes most other</span><br><span class="hljs-comment">   tests, then consider whether you are doing too much work in</span><br><span class="hljs-comment">   the timer interrupt.  If the timer interrupt handler takes too</span><br><span class="hljs-comment">   long, then the test's main thread will not have enough time to</span><br><span class="hljs-comment">   do its own work (printing a message) and go back to sleep</span><br><span class="hljs-comment">   before the next tick arrives.  Then the main thread will be</span><br><span class="hljs-comment">   ready, instead of sleeping, when the tick arrives,</span><br><span class="hljs-comment">   artificially driving up the load average.</span><br><span class="hljs-comment"> ...</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></tbody></table></figure><p>以下是msg的调用图，可以看到在输出信息时会关中断，而后会调用lock_aquire。而task2中的lock_aquire太过复杂，而关闭中断时间太长是很危险的。</p><p>第二种情况：你在本地跑的非常不错，ALL PASS，但提交到lab上却fail了，提示TIME OUT错误。</p><p>也就是说，超时了。不得不说这样的测试是挺离谱的，因为测试文件的目的就是要执行180秒，这能保证一点也不超时吗？本地测试的时间限制为480s，所以全部通过了，只能说非常的离谱。并且你还可能发现一些神奇的现象，比如说，同一次提交，不同的测试结果，这和平台的关系很大的。</p><p>没办法为了减少在timer_intrrupt的运行时间，需要对代码进行改进。原来更新recent_cpu和priority分成2个函数写，需要遍历链表两次，这次把他们放在一起，遍历一次即可，只不过代码的可读性下降了。将原来的这calculate_mlfqs_load_avg()、update_mlfqs_recent_cpu()、update_mlfqs_priority()这三个函数替换为以下函数即可。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 为了加快运行速度，将函数整合了一下 */</span><br><span class="hljs-type">void</span> <br><span class="hljs-title function_">mlfqs_update_rc_la_pr</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  <span class="hljs-type">int</span> ready_threads = list_size(&amp;ready_list) +(thread_current() != idle_thread);<br>  load_avg = FP_MUL(INT_TO_FP(<span class="hljs-number">59</span>) / <span class="hljs-number">60</span>, load_avg) + INT_TO_FP(<span class="hljs-number">1</span>) / <span class="hljs-number">60</span> * ready_threads;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> *<span class="hljs-title">e</span>;</span>     <br>  <span class="hljs-keyword">for</span> (e = list_begin (&amp;all_list); e != list_end (&amp;all_list); e = list_next (e))      <br>  { <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">t</span> =</span> list_entry (e, <span class="hljs-keyword">struct</span> thread, allelem);<br>    <span class="hljs-keyword">if</span>(t == idle_thread)<br>      <span class="hljs-keyword">continue</span>;<br><br>    t-&gt;recent_cpu = FP_MUL(FP_DIV(load_avg * <span class="hljs-number">2</span>, load_avg * <span class="hljs-number">2</span> + INT_TO_FP(<span class="hljs-number">1</span>)), t-&gt;recent_cpu) + INT_TO_FP(t-&gt;nice);<br>    t-&gt;priority = (FP_TO_INT(INT_TO_FP(PRI_MAX) - t-&gt;recent_cpu / <span class="hljs-number">4</span> - INT_TO_FP(t-&gt;nice * <span class="hljs-number">2</span>)));     <br>    t-&gt;priority = t-&gt;priority &lt; PRI_MIN ? PRI_MIN : t-&gt;priority;<br>    t-&gt;priority = t-&gt;priority &gt; PRI_MAX ? PRI_MAX : t-&gt;priority;<br> <br>   }<br>}<br></code></pre></td></tr></tbody></table></figure></li></ul></li></ul><hr><h4 id="总结">总结</h4><p>总的来说，思维上难度比较大的是task2的优先级捐赠，通过锁间接捐赠的想法很好，但也不好想到。不过，搞清楚内在的逻辑之后，代码就比较简单了。虽然task3在逻辑上并没有task2复杂，但我花的时间却最长。一个是花在解决给main线程预留足够时间输出上，另一个就是gitlab上的超时问题。总之task3的难点就是尽量压缩timer_interrupt中执行的程序时间，以避免出错。</p><h3 id="project2-userprog">Project2 Userprog</h3><h4 id="概述">概述</h4><p>如果在make check的时候遇到了非本项目出现的错误，可以参考project1的task2的Q&amp;A部分，很有可能是因为之前的实现造成的问题。想明确这一点，只需利用git回到最初的起点（别告诉我你还不会使用git），看看make check的内容和现在的是否一致即可。如果project1的实现确实造成了project2的一些困扰，可以利用gdb调试，看看问题出在哪里；但如果你遇到的问题和我不同，又不想解决，那你就用最原始的版本吧，因为这两个project是相对独立的。</p><p>参考：pintos官方文档</p><p>我们来看看userprog要求我们做哪些事呢？</p><p>这个项目当中我们会用到文件系统，但是我们不需要也不推荐去对文件系统进行任何修改，因为这不是我们这个project所要关注的事。我们只需要使用pintos写好的文件系统即可。但它提供的文件系统由于尚未完善，因此存在诸多限制：</p><ol type="1"><li>文件系统本身没有对同步互斥的支持，因此应确保一次只能有一个进程在使用文件系统；</li><li>文件系统的尺寸在创建之初就已经固定，而根目录其实就可以看作是一个文件，因此，文件的个数有限；</li><li>文件数据在磁盘上所占的空间是连续的，因此会有严重的碎片问题；</li><li>没有子目录；</li><li>文件名最长为14个字符；</li><li>在删除一个文件时，如果处于被打开的状态，是不会释放空间的，并且在进程关闭这个文件前，所有进程都能访问它。</li></ol><p>按照手册的说法我们还可以知道的是，kenel的虚拟地址是全局的，并且是3GB-4GB，如3GB+5MB对应的物理地址就是5MB。而user的虚拟地址则是局部的，<strong>每个user都有自己的虚拟地址，这在代码中的体现是，thread数据结构中，有一个pagedir成员，仅在userprog中启用</strong>，，它们的地址空间如下所示。代码段的地址从128MB左右开始，这没有什么具体意义，只是一个规定而已。</p><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/Memory_alloc.png"></p><p>此外文档<strong>还提供了任务的推荐完成顺序</strong>，如下：</p><ol type="1"><li>参数传递(Argument passing)；</li><li>用户存储访问(User memory access)；</li><li>系统调用(System call infrastructure)，包括关闭系统调用(the exit system call)</li><li>写系统调用(The write system call for writing to fd 1)；</li><li>剩下的任务</li></ol><p>但总的任务又分为3类：参数传递、系统调用、</p><p>我们将按照上述顺序进行实现</p><h4 id="task1-process-termination-messages">Task1: Process Termination Messages</h4><h5 id="分析-2">分析</h5><p>手册中有一个小任务，用printf ("%s: exit(%d)",...)<strong>仅当用户进程</strong>退出的时候，打印出进程的名字和进程的退出代码。退出代码在thread中是没有的，因此可以添加上该数据。同时，打印的时机也是需要考虑的，来看看thread_exit和process_exit做了些什么。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Deschedules the current thread and destroys it.  Never</span><br><span class="hljs-comment">   returns to the caller. */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">thread_exit</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>{<br>  ASSERT (!intr_context ());<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USERPROG</span><br>  process_exit ();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-comment">/* Remove thread from all threads list, set our status to dying,</span><br><span class="hljs-comment">     and schedule another process.  That process will destroy us</span><br><span class="hljs-comment">     when it calls thread_schedule_tail(). */</span><br>  intr_disable ();<br>  list_remove (&amp;thread_current()-&gt;allelem);<br>  thread_current ()-&gt;status = THREAD_DYING;<br>  schedule ();<br>  NOT_REACHED ();<br>}<br><br><span class="hljs-comment">/* Free the current process's resources. */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">process_exit</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">cur</span> =</span> thread_current ();<br>  <span class="hljs-type">uint32_t</span> *pd;<br><br>  <span class="hljs-comment">/* Destroy the current process's page directory and switch back</span><br><span class="hljs-comment">     to the kernel-only page directory. */</span><br>  pd = cur-&gt;pagedir;<br>  <span class="hljs-keyword">if</span> (pd != <span class="hljs-literal">NULL</span>) <br>    {<br>      <span class="hljs-comment">/* Correct ordering here is crucial.  We must set</span><br><span class="hljs-comment">         cur-&gt;pagedir to NULL before switching page directories,</span><br><span class="hljs-comment">         so that a timer interrupt can't switch back to the</span><br><span class="hljs-comment">         process page directory.  We must activate the base page</span><br><span class="hljs-comment">         directory before destroying the process's page</span><br><span class="hljs-comment">         directory, or our active page directory will be one</span><br><span class="hljs-comment">         that's been freed (and cleared). */</span><br>      cur-&gt;pagedir = <span class="hljs-literal">NULL</span>;<br>      pagedir_activate (<span class="hljs-literal">NULL</span>);<br>      pagedir_destroy (pd);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>如上所示，process_exit在project2中，会被thread_exit所调用。前面说到，thread结构当中有一个pagedir，只有在用户程序的时候才会给它分配独立的虚拟地址。因此如果是用户程序，正常情况下，pd不应当为空，因此打印退出代码的程序应该放在这里面。值得一提的是，后面的一些语句，表示页面的释放。它说这里的顺序非常重要，不可以修改。先是cur-&gt;pagedir置空，以避免时间中断跳回到用户程序页面。然后再将该页面激活（就是返回页面的物理地址），再把它毁掉。</p><p>总的来说任务还是比较清晰的，可以coding了。</p><h5 id="实现-2">实现</h5><p>在thread.h中的thread数据结构中加入</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br><span class="hljs-type">bool</span> exit_code;<span class="hljs-comment">/* 进程终止信息 */</span><br><span class="hljs-comment">/*--------------------------------------------------------*/</span> <br></code></pre></td></tr></tbody></table></figure><p>在process.c中的process_exit加入</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Free the current process's resources. */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">process_exit</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">cur</span> =</span> thread_current ();<br>  <span class="hljs-type">uint32_t</span> *pd;<br><br>  <span class="hljs-comment">/* Destroy the current process's page directory and switch back</span><br><span class="hljs-comment">     to the kernel-only page directory. */</span><br>  pd = cur-&gt;pagedir;<br>  <span class="hljs-keyword">if</span> (pd != <span class="hljs-literal">NULL</span>) <br>    {<br>      <span class="hljs-comment">/* Correct ordering here is crucial.  We must set</span><br><span class="hljs-comment">         cur-&gt;pagedir to NULL before switching page directories,</span><br><span class="hljs-comment">         so that a timer interrupt can't switch back to the</span><br><span class="hljs-comment">         process page directory.  We must activate the base page</span><br><span class="hljs-comment">         directory before destroying the process's page</span><br><span class="hljs-comment">         directory, or our active page directory will be one</span><br><span class="hljs-comment">         that's been freed (and cleared). */</span><br>      cur-&gt;pagedir = <span class="hljs-literal">NULL</span>;<br>      pagedir_activate (<span class="hljs-literal">NULL</span>);<br>      pagedir_destroy (pd);<br><br>      <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br>      <span class="hljs-comment">/* 打印用户进程终止信息 */</span><br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s: exit(%d)\n"</span>, cur-&gt;name, cur-&gt;exit_code);<br>      <span class="hljs-comment">/*--------------------------------------------------------*/</span> <br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><h4 id="task2-argument-passing">Task2: Argument Passing</h4><h5 id="分析-3">分析</h5><p>依照它的描述：在process_execute()中，所需要修改的只是简单的将字符串拆分而已</p><p>如"grep foo bar"，要将其拆成3个单词，且第一个为文件，第二个为参数。</p><p>嗯，听起来似乎没什么难的。我们先来看看process_execute做了些什么</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Starts a new thread running a user program loaded from</span><br><span class="hljs-comment">   FILENAME.  The new thread may be scheduled (and may even exit)</span><br><span class="hljs-comment">   before process_execute() returns.  Returns the new process's</span><br><span class="hljs-comment">   thread id, or TID_ERROR if the thread cannot be created. */</span><br><span class="hljs-type">tid_t</span><br><span class="hljs-title function_">process_execute</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file_name)</span> <br>{<br>  <span class="hljs-type">char</span> *fn_copy;<br>  <span class="hljs-type">tid_t</span> tid;<br><br>  <span class="hljs-comment">/* Make a copy of FILE_NAME.</span><br><span class="hljs-comment">     Otherwise there's a race between the caller and load(). */</span><br>  fn_copy = palloc_get_page (<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (fn_copy == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> TID_ERROR;<br>  strlcpy (fn_copy, file_name, PGSIZE);<br><br>  <span class="hljs-comment">/* Create a new thread to execute FILE_NAME. */</span><br>  tid = thread_create (file_name, PRI_DEFAULT, start_process, fn_copy);<br>  <span class="hljs-keyword">if</span> (tid == TID_ERROR)<br>    palloc_free_page (fn_copy); <br>  <span class="hljs-keyword">return</span> tid;<br>}<br><br><br></code></pre></td></tr></tbody></table></figure><p>可以看到，显示输入文件名字符串，当然这个字符串可能带着参数。</p><p>使用palloc_get_page取获得1页内存（pintos中线程的大小是固定的，就是1页，可见手册P61），而且是kernel pool的页面。 strlcpy则是想file_name复制到fn_copy的空间中去，再调用thread_create创建这个线程。为什么要复制file_name呢？<strong>按它的说法是不复制，调用者和loader会出现冲突</strong>（没太明白也许是地址冲突之类的？）。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">thread_create (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> priority, thread_func *function, <span class="hljs-type">void</span> *aux) <br></code></pre></td></tr></tbody></table></figure><p>防止你忘了创建线程函数的格式，上面写出来了。我们发现，process_execute所创建的线程名字为文件名，而调用的函数则是start_process，这又是什么呢？然后，aux则还是文件名。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* A thread function that loads a user process and starts it</span><br><span class="hljs-comment">   running. */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">start_process</span> <span class="hljs-params">(<span class="hljs-type">void</span> *file_name_)</span><br>{<br>  <span class="hljs-type">char</span> *file_name = file_name_;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intr_frame</span> <span class="hljs-title">if_</span>;</span><br>  <span class="hljs-type">bool</span> success;<br><br>  <span class="hljs-comment">/* Initialize interrupt frame and load executable. */</span><br>  <span class="hljs-built_in">memset</span> (&amp;if_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> if_);<br>  if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;<br>  if_.cs = SEL_UCSEG;<br>  if_.eflags = FLAG_IF | FLAG_MBS;<br>  success = load (file_name, &amp;if_.eip, &amp;if_.esp);<br><br>  <span class="hljs-comment">/* If load failed, quit. */</span><br>  palloc_free_page (file_name);<br>  <span class="hljs-keyword">if</span> (!success) <br>    thread_exit ();<br><br>  <span class="hljs-comment">/* Start the user process by simulating a return from an</span><br><span class="hljs-comment">     interrupt, implemented by intr_exit (in</span><br><span class="hljs-comment">     threads/intr-stubs.S).  Because intr_exit takes all of its</span><br><span class="hljs-comment">     arguments on the stack in the form of a `struct intr_frame',</span><br><span class="hljs-comment">     we just point the stack pointer (%esp) to our stack frame</span><br><span class="hljs-comment">     and jump to it. */</span><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">"movl %0, %%esp; jmp intr_exit"</span> : : <span class="hljs-string">"g"</span> (&amp;if_) : <span class="hljs-string">"memory"</span>)</span>;<br>  NOT_REACHED ();<br>}<br></code></pre></td></tr></tbody></table></figure><p>start_process 所做的事，就是将ELF可执行文件装载进thread。也许会问，怎么装载的呢？我想这并不是我们需要关心的问题，ELF文件有着固定的格式，根据某种规则，将文件加载进内存，当然还得要进行重定位等等。这也许会在CSAPP这本书中找到答案，这里我们不做深入讨论。</p><p>回到这个task，我们要做到参数传递，好像无非就是分割字符串成一个个单词罢了，这需要我们自己去写吗？不需要，贴心的pintos已经为我们准备好了这样的函数，毕竟这并不是操作系统的重点。</p><p>在string.c文件中有这么一个函数：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Breaks a string into tokens separated by DELIMITERS.  The</span><br><span class="hljs-comment">   first time this function is called, S should be the string to</span><br><span class="hljs-comment">   tokenize, and in subsequent calls it must be a null pointer.</span><br><span class="hljs-comment">   SAVE_PTR is the address of a `char *' variable used to keep</span><br><span class="hljs-comment">   track of the tokenizer's position.  The return value each time</span><br><span class="hljs-comment">   is the next token in the string, or a null pointer if no</span><br><span class="hljs-comment">   tokens remain.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   This function treats multiple adjacent delimiters as a single</span><br><span class="hljs-comment">   delimiter.  The returned tokens will never be length 0.</span><br><span class="hljs-comment">   DELIMITERS may change from one call to the next within a</span><br><span class="hljs-comment">   single string.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   strtok_r() modifies the string S, changing delimiters to null</span><br><span class="hljs-comment">   bytes.  Thus, S must be a modifiable string.  String literals,</span><br><span class="hljs-comment">   in particular, are *not* modifiable in C, even though for</span><br><span class="hljs-comment">   backward compatibility they are not `const'.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   Example usage:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   char s[] = "  String to  tokenize. ";</span><br><span class="hljs-comment">   char *token, *save_ptr;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   for (token = strtok_r (s, " ", &amp;save_ptr); token != NULL;</span><br><span class="hljs-comment">        token = strtok_r (NULL, " ", &amp;save_ptr))</span><br><span class="hljs-comment">     printf ("'%s'\n", token);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   outputs:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     'String'</span><br><span class="hljs-comment">     'to'</span><br><span class="hljs-comment">     'tokenize.'</span><br><span class="hljs-comment">*/</span><br>strtok_r (<span class="hljs-type">char</span> *s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *delimiters, <span class="hljs-type">char</span> **save_ptr) <br></code></pre></td></tr></tbody></table></figure><p>我们也许并不关心它的实现，但还是需要仔细看一下该函数需要注意的点。注释中说，输入的s必须是个可变的字符串，即不能是const型，原因在于，<strong>它的原理就是在原字符串中将delimiters转换为NULL('\0')，这对原字符串是会造成修改的</strong>。可以看到，它还贴心的用空格举的例子，这不正是我们所需要的吗？那么来理一下思路：</p><ol type="1"><li>首先我们需要在process_execute中将file_name把file拆出来，<strong>因为thread的名字显然是file，而不是这个字符串</strong>（thread的名字只有15个字符，文件名最长可以有14个字符，显然不太能把这个字符串给thread）。</li><li>其二，既然要把拆出来的文件名给thread，而aux得是fn_copy（上面说了，是为了防止冲突），输入的file_name又是const char *，格式，<strong>因此得复制2份，一份给thread的name，一份作为aux</strong>。</li><li>拆分字符串就是调用strtok_r 函数，且只要拆分一次即可。</li></ol><p>这样就完了吗？显然不是，我们参数还没传进去呢？手册中还有这么一句话：</p><figure class="highlight delphi"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">See Section <span class="hljs-number">3.5</span>.<span class="hljs-number">1</span> [<span class="hljs-keyword">Program</span> Startup Details], page <span class="hljs-number">36</span>, <span class="hljs-keyword">for</span> information <span class="hljs-keyword">on</span> exactly how<br>you need <span class="hljs-keyword">to</span> <span class="hljs-keyword">set</span> up the stack.<br></code></pre></td></tr></tbody></table></figure><p>我们还需要了解，参数压栈的规则，才能真正将参数传递进去。</p><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/PushStack.png"></p><p>手册【P36】中又这样一张图，同时手册【P36-37】详细介绍了80386在unix上调用函数的一些惯例。它告诉我们：</p><ol type="1"><li>栈是<strong>从高地址往低地址增长的</strong>，</li><li>假如我们有3个参数，我们要先压，参数3，再是2，最后是1，即<strong>压参的顺序是从右往左</strong>。</li><li>所有的参数，都是<strong>四字节对齐的</strong>。</li><li>如果被调用这有一个返回值，<strong>那么它将被存储于EAX中</strong>。</li><li>当然还有一些函数调用常识，比如80x86的RET指令是从栈中pop出返回地址，参数也是从栈中弹出。</li></ol><p>此外，压栈压栈，我们压的到底是哪个栈，我们在手册上看到了一个set_stack函数，这个函数，也被load调用，而该函数正是设置栈的空间的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create a minimal stack by mapping a zeroed page at the top of</span><br><span class="hljs-comment">   user virtual memory. */</span><br>setup_stack (<span class="hljs-type">void</span> **esp) <br>{<br>  <span class="hljs-type">uint8_t</span> *kpage;<br>  <span class="hljs-type">bool</span> success = <span class="hljs-literal">false</span>;<br><br>  kpage = palloc_get_page (PAL_USER | PAL_ZERO);<br>  <span class="hljs-keyword">if</span> (kpage != <span class="hljs-literal">NULL</span>) <br>    {<br>      success = install_page (((<span class="hljs-type">uint8_t</span> *) PHYS_BASE) - PGSIZE, kpage, <span class="hljs-literal">true</span>);<br>      <span class="hljs-keyword">if</span> (success)<br>        *esp = PHYS_BASE;<br>      <span class="hljs-keyword">else</span><br>        palloc_free_page (kpage);<br>    }<br>  <span class="hljs-keyword">return</span> success;<br>}<br></code></pre></td></tr></tbody></table></figure><p>不必去纠结它的实现细节，通过注释我们可以知道，这段代码就是给进程分配一个栈的空间，当然里面是没有参数的，为初始化0的页面。并且有一段代码是值得关注的。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (success) <br>*esp = PHYS_BASE;<br></code></pre></td></tr></tbody></table></figure><p>如果创建成功了，*esp = PHYS_BASE就指向了用户虚拟内存的栈顶。</p><p>进一步，我们还可以参考一下c语言main函数传参的过程</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span><br></code></pre></td></tr></tbody></table></figure><p>如上是带参main函数的格式，还记得main函数是如何压参的吗？在手册P37中，我们可以找到答案，如下图：</p><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/arg_pass.png"></p><p>我们来理一下过程：</p><ol type="1"><li>在调用我们的函数前，我们先将<strong>参数压入</strong></li><li>而为了方便，我们可以参照main函数的压参过程，使用<strong>二级指针将参数压入</strong></li><li>此外，自右向左，压入参数地址后，<strong>还需要压入argc</strong>，表示有多少个参数</li><li>在压参完毕后，还需<strong>压入返回地址</strong>。</li></ol><p>由此，压参的过程，已经明了了，可以开始coding了。</p><hr><h5 id="实现-3">实现</h5><p>在process.c中的process_execute中添加</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">tid_t</span><br><span class="hljs-title function_">process_execute</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file_name)</span> <br>{<br>  <span class="hljs-type">char</span> *fn_copy;<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-type">char</span> *fn_copy_for_thread_name;<br>  <span class="hljs-type">char</span> *thread_name, *save_ptr; <br>  fn_copy_for_thread_name = palloc_get_page (<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  <span class="hljs-type">tid_t</span> tid;<br><br>  <span class="hljs-comment">/* Make a copy of FILE_NAME.</span><br><span class="hljs-comment">     Otherwise there's a race between the caller and load(). */</span><br>  fn_copy = palloc_get_page (<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (fn_copy == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> TID_ERROR;<br>  strlcpy (fn_copy, file_name, PGSIZE);<br><br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 复制一个字符串，用于分割文件名作为线程名 */</span><br>  strlcpy (fn_copy_for_thread_name, file_name, PGSIZE);<br>  thread_name = strtok_r (fn_copy_for_thread_name, <span class="hljs-string">" "</span>, &amp;save_ptr);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br>  <span class="hljs-comment">/* Create a new thread to execute FILE_NAME. */</span><br>  tid = thread_create (file_name, PRI_DEFAULT, start_process, fn_copy);<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 别忘记把它释放掉 */</span><br>  palloc_free_page (fn_copy_for_thread_name); <br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  <span class="hljs-keyword">if</span> (tid == TID_ERROR)<br>    palloc_free_page (fn_copy); <br>  <span class="hljs-keyword">return</span> tid;<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>在process.c中的start_process中添加</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">start_process</span> <span class="hljs-params">(<span class="hljs-type">void</span> *file_name_)</span><br>{<br>  <span class="hljs-type">char</span> *file_name = file_name_;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intr_frame</span> <span class="hljs-title">if_</span>;</span><br>  <span class="hljs-type">bool</span> success;<br><br>  <span class="hljs-comment">/* Initialize interrupt frame and load executable. */</span><br>  <span class="hljs-built_in">memset</span> (&amp;if_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> if_);<br>  if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;<br>  if_.cs = SEL_UCSEG;<br>  if_.eflags = FLAG_IF | FLAG_MBS;<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 将真正的文件名装载进去，会造成字符串修改，而文件名</span><br><span class="hljs-comment">   * 也是参数的一部分，因此我们使用original来保存</span><br><span class="hljs-comment">   * 原字符串的副本  */</span><br>  <span class="hljs-type">char</span> *real_file_name, *original_name, *save_ptr; <br>  original_name = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(file_name)+<span class="hljs-number">1</span>);<br>  strlcpy (original_name, file_name, <span class="hljs-built_in">strlen</span>(file_name)+<span class="hljs-number">1</span>);<br>  real_file_name = strtok_r (file_name_, <span class="hljs-string">" "</span>, &amp;save_ptr);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  success = load (real_file_name, &amp;if_.eip, &amp;if_.esp);<br><br>  <span class="hljs-comment">/* If load failed, quit. */</span><br>  palloc_free_page (file_name);<br>  <span class="hljs-keyword">if</span> (!success) <br>    thread_exit ();<br><br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 显然只有在成功装载之后，我们才需要参数传递 </span><br><span class="hljs-comment">   * 以下过程，就是把参数压入栈中，此处的顺序是自左向右</span><br><span class="hljs-comment">   * 这并没有什么关系，因为我们使用二级指针对参数压栈</span><br><span class="hljs-comment">   * 只需要保证压入二级指针时，是自右向左即可。</span><br><span class="hljs-comment">   * argv存储的是各个参数的首地址，即实际的二级指针</span><br><span class="hljs-comment">   * 而386系统中，地址是32位，因此使用int型。</span><br><span class="hljs-comment">   * argc则存储的是参数的个数。</span><br><span class="hljs-comment">   * 由于参数个数未知，我们使用动态分配地址的方法。 */</span><br><br>  <span class="hljs-type">int</span> argc = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> argv_size = <span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span>* argv = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>(argv_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>  <span class="hljs-type">char</span>* token;<br><br>  <span class="hljs-keyword">for</span> (token = strtok_r (original_name, <span class="hljs-string">" "</span>, &amp;save_ptr); token != <span class="hljs-literal">NULL</span>;<br>             token = strtok_r (<span class="hljs-literal">NULL</span>, <span class="hljs-string">" "</span>, &amp;save_ptr))<br>  {<br>    <span class="hljs-comment">/* 字符串是低地址往高地址存，并且注意'\0'也是字符串</span><br><span class="hljs-comment">     * 的一部分 */</span><br>    if_.esp -= <span class="hljs-built_in">strlen</span>((token)+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memcmp</span>(if_.esp, token, <span class="hljs-built_in">strlen</span>(token)+<span class="hljs-number">1</span>);<br>    argv[argc++] = (<span class="hljs-type">int</span>) if_.esp;<br>    <span class="hljs-keyword">if</span> (argc &gt; argv_size)<br>    {<br>      <span class="hljs-comment">/* 如果空间不够，得重新分配 */</span><br>      argv_size += <span class="hljs-number">10</span>;<br>      <span class="hljs-built_in">realloc</span>(argv, argv_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>* )); <br>    }<br>  }<br><br>  push_arg_and_retaddr(&amp;if_.esp, argc, argv);<br><br>  <span class="hljs-built_in">free</span>(original_name);<br>  <span class="hljs-built_in">free</span>(argv);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br>  <span class="hljs-comment">/* Start the user process by simulating a return from an</span><br><span class="hljs-comment">     interrupt, implemented by intr_exit (in</span><br><span class="hljs-comment">     threads/intr-stubs.S).  Because intr_exit takes all of its</span><br><span class="hljs-comment">     arguments on the stack in the form of a `struct intr_frame',</span><br><span class="hljs-comment">     we just point the stack pointer (%esp) to our stack frame</span><br><span class="hljs-comment">     and jump to it. */</span><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">"movl %0, %%esp; jmp intr_exit"</span> : : <span class="hljs-string">"g"</span> (&amp;if_) : <span class="hljs-string">"memory"</span>)</span>;<br>  NOT_REACHED ();<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>在process.c中添加压参函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br><span class="hljs-comment">/* 自右向左压入参数的首地址，即二级指针</span><br><span class="hljs-comment"> * 此外还需压入参数的个数，以及返回地址0</span><br><span class="hljs-comment"> * 此处esp使用的是二级指针，原因在于，我们要修改的是</span><br><span class="hljs-comment"> * esp指针(即保存的地址)的值，而非esp所指向的值 */</span><br><span class="hljs-type">void</span> <br><span class="hljs-title function_">push_arg_and_retaddr</span><span class="hljs-params">(<span class="hljs-type">void</span>** esp, <span class="hljs-type">int</span> argc, <span class="hljs-type">int</span>* argv)</span><br>{<br><br>  <span class="hljs-comment">/* 4字节对齐 */</span><br>  <span class="hljs-type">int</span> rest = (<span class="hljs-type">int</span>)*esp % <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rest; i++)<br>  {<br>    *esp --;  <br>    *esp = (<span class="hljs-type">int</span>)*esp;<br><br>  }<br><br>  <span class="hljs-comment">/* 自右向左依次压入一级指针argv* */</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = argc - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>  {<br>     *esp -= <span class="hljs-number">4</span>;<br>     *(<span class="hljs-type">int</span> *) *esp = argv[i];<br>  }<br>  <span class="hljs-comment">/* 分别压入二级指针argv**，即argv[0]的地址</span><br><span class="hljs-comment">   * 参数个数，返回地址0 */</span><br>  *esp -= <span class="hljs-number">4</span>;<br>  *(<span class="hljs-type">int</span> *) *esp = (<span class="hljs-type">int</span>) *esp + <span class="hljs-number">4</span>;<br>  *esp -= <span class="hljs-number">4</span>;<br>  *(<span class="hljs-type">int</span> *) *esp = argc;<br>  *esp -= <span class="hljs-number">4</span>;<br>  *(<span class="hljs-type">int</span> *) *esp = <span class="hljs-number">0</span>;<br><br>}<br><br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br></code></pre></td></tr></tbody></table></figure><h4 id="task3-system-call">Task3: System Call</h4><h5 id="概述-1">概述</h5><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/syscall_intro.png"></p><p>如上图是syscall系统调用的流程，首先通过syscall_init装载内中断syscall_handler，<strong>中断号为30，且特权级为3</strong>（最低级别）。然后通过halt、exit等函数调用系统调用。这些函数用内联汇编代码编写。这些汇编代码的流程如下：</p><ol type="1"><li><strong>自右向左压入参数</strong>；</li><li>压入中断号，<strong>因此中断号总是处于栈顶位置</strong>。</li><li>调用<strong>30中断</strong>，进入中断处理程序，其实<strong>也就是syscall_handler</strong>。</li><li>执行完毕后，pop出所有参数，并返回。</li><li>如果有返回值，<strong>从EAX寄存器中取出</strong>，送入retval。</li></ol><p>手册【P29】说，所有的系统调用存在‘userprog/syscall.c’、‘userprog/syscall.h’，同时‘lib/syscall-nr.h’中还存着各个系统调用的终端号，如下所示。它用枚举型存储着，总共有20个，并且明确标出了project2所需要用到的13个系统调用。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __LIB_SYSCALL_NR_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __LIB_SYSCALL_NR_H</span><br><br><span class="hljs-comment">/* System call numbers. */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> </span><br><span class="hljs-class">  {</span><br>    <span class="hljs-comment">/* Projects 2 and later. */</span><br>    SYS_HALT,                   <span class="hljs-comment">/* Halt the operating system. */</span><br>    SYS_EXIT,                   <span class="hljs-comment">/* Terminate this process. */</span><br>    SYS_EXEC,                   <span class="hljs-comment">/* Start another process. */</span><br>    SYS_WAIT,                   <span class="hljs-comment">/* Wait for a child process to die. */</span><br>    SYS_CREATE,                 <span class="hljs-comment">/* Create a file. */</span><br>    SYS_REMOVE,                 <span class="hljs-comment">/* Delete a file. */</span><br>    SYS_OPEN,                   <span class="hljs-comment">/* Open a file. */</span><br>    SYS_FILESIZE,               <span class="hljs-comment">/* Obtain a file's size. */</span><br>    SYS_READ,                   <span class="hljs-comment">/* Read from a file. */</span><br>    SYS_WRITE,                  <span class="hljs-comment">/* Write to a file. */</span><br>    SYS_SEEK,                   <span class="hljs-comment">/* Change position in a file. */</span><br>    SYS_TELL,                   <span class="hljs-comment">/* Report current position in a file. */</span><br>    SYS_CLOSE,                  <span class="hljs-comment">/* Close a file. */</span><br><br>    <span class="hljs-comment">/* Project 3 and optionally project 4. */</span><br>    SYS_MMAP,                   <span class="hljs-comment">/* Map a file into memory. */</span><br>    SYS_MUNMAP,                 <span class="hljs-comment">/* Remove a memory mapping. */</span><br><br>    <span class="hljs-comment">/* Project 4 only. */</span><br>    SYS_CHDIR,                  <span class="hljs-comment">/* Change the current directory. */</span><br>    SYS_MKDIR,                  <span class="hljs-comment">/* Create a directory. */</span><br>    SYS_READDIR,                <span class="hljs-comment">/* Reads a directory entry. */</span><br>    SYS_ISDIR,                  <span class="hljs-comment">/* Tests if a fd represents a directory. */</span><br>    SYS_INUMBER                 <span class="hljs-comment">/* Returns the inode number for a fd. */</span><br>  };<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* lib/syscall-nr.h */</span></span><br></code></pre></td></tr></tbody></table></figure><p>其实在手册【P28】中还明确说到了，当然在本日志project2概述中也提到了，官方提出了一个推荐完成顺序。我们需要完成一些基本的syscall，并且系统调用应当还能够访问用户的内存空间。用户程序使用系统调用通过内部中断进行，在x86系统中，常常是通过<strong>调用门切换自己的特权级（DPL）</strong>，而特权级转变这里不详细展开说它的过程（后续有精力还会在补充）。</p><p>按照手册的说法，那我们先来让系统调用能够访问我们的用户内存</p><hr><h5 id="分析访问用户内存">分析：访问用户内存</h5><p>关于访问用户内存，手册【P27】是这么说的：</p><figure class="highlight gcode"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">作为系统调用的一部分，内核必须经常通过用户程序提供的指针访问内存。内核必须非常小心地这样做，因为用户可以传递一个空指针，一个指向未映射虚拟内存的指针，或者一个指向内核虚拟地址空间<span class="hljs-comment">(位于PHYS_BASE之上)</span>的指针。所有这些类型的无效指针都必须被拒绝，从而不会对内核或其他正在运行的进程造成伤害，方法是终止违规进程并释放其资源。<br>至少有两种合理的方法可以正确地做到这一点。<br>第一种方法是验证用户提供的指针的有效性，然后解除对它的引用。如果你选择了这个方法，你可以看看<span class="hljs-string">' userprog/pagedir.c '</span>和<span class="hljs-string">' threads/vaddr.h '</span>中的函数。这是处理用户内存访问的最简单的方法。<br>第二种方法是只检查用户指针是否指向PHYS_BASE下面，然后取消对它的引用。无效的用户指针将导致“页面错误”，您可以通过修改<span class="hljs-string">' userprog/exception.c '</span>中的page_fault<span class="hljs-comment">()</span>代码来处理。这种技术通常更快，因为它利用了处理器的MMU，所以它倾向于在真实的内核<span class="hljs-comment">(包括Linux)</span>中使用。<br>在这两种情况下，您都需要确保不会“泄漏”资源。例如，假设您的系统调用已经使用malloc<span class="hljs-comment">()</span>获得了一个锁或分配了内存，如果之后遇到无效的用户指针，仍然必须确保释放锁或释放内存页；如果您选择在解引用用户指针之前验证它们，这应该很简单，但无效指针导致页面错误，处理起来更加困难，因为无法从内存访问中返回错误代码。因此，对于那些想要尝试后一种技术的人，我们将提供一些有用的代码。<br>代码：略<br></code></pre></td></tr></tbody></table></figure><p>这里选择它所谓的最简单的方法。</p><p>什么验证用户提供的指针的有效性？可以分为2个方面：</p><ol type="1"><li>用户提供的中断类型号是否正确，即<strong>存不存在它需要的系统调用</strong>？</li><li>用户程序的内存是否正确，主要考察：<strong>用户程序的虚拟内存是否在PHYBASE以下？用户的虚拟地址是否指向一个不存在的物理地址？</strong></li><li>手册中所谓的确保不会“泄漏”资源（讲道理，这里没怎么看懂），然后给我们提供了2段代码，一个测试能否成功访问（解引用），另一段则是测试能否成功写入。我们在获得这个用户指针，可以用该代码来<strong>验证其是否有效</strong>。</li></ol><p>对于1，如何去知道用户所提供的中断号呢？<strong>中断存于用户栈顶</strong>，这在前面的分析已经说到了。系统调用时从栈顶推出，即可获得中断号。然后判断中断号是否在0~20之间即可。</p><p>对于2，可以用is_user_vaddr来判断是或否在phybase以下，同时还可以使用pagedir_get_page获得用户它的物理地址。该函数如下所示，我们在结构篇提到过，pintos采用的二级页表存储，所以它首先根据虚拟地址通过lookup_page在页目录中查找它所在的页面地址pte，然后使用pte_get_page找到对应页表项的地址，然后再加上页内偏移就是物理地址了。当然，如果中间任何一个环节找不到，那就会返回NULL，由此判断该虚拟地址是否指向一个存在的物理地址。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Looks up the physical address that corresponds to user virtual</span><br><span class="hljs-comment">   address UADDR in PD.  Returns the kernel virtual address</span><br><span class="hljs-comment">   corresponding to that physical address, or a null pointer if</span><br><span class="hljs-comment">   UADDR is unmapped. */</span><br><span class="hljs-type">void</span> *<br><span class="hljs-title function_">pagedir_get_page</span> <span class="hljs-params">(<span class="hljs-type">uint32_t</span> *pd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *uaddr)</span> <br>{<br>  <span class="hljs-type">uint32_t</span> *pte;<br><br>  ASSERT (is_user_vaddr (uaddr));<br>  <br>  pte = lookup_page (pd, uaddr, <span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">if</span> (pte != <span class="hljs-literal">NULL</span> &amp;&amp; (*pte &amp; PTE_P) != <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> pte_get_page (*pte) + pg_ofs (uaddr);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>对于3，我们可以使用手册提供的如下代码，进行解引用。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">get_user</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *uaddr)</span><br>{<br>  <span class="hljs-type">int</span> result;   <br>  <span class="hljs-keyword">asm</span> (<span class="hljs-string">"movl $1f, %0; movzbl %1, %0; 1:"</span><br>       : <span class="hljs-string">"=&amp;a"</span> (result) : <span class="hljs-string">"m"</span> (*uaddr));<br>  <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></tbody></table></figure><p>而解引用如引发异常，将调用page_fault，page_fault会强行杀掉进程，<strong>而无法返回错误信息</strong>。那么我们就需要对page_fault进行修改，在引发异常时返回-1，而不让它报错即可。</p><p>经过如上分析后，可以开始coding了。</p><hr><h5 id="实现访问用户内存">实现：访问用户内存</h5><p>对于非正常退出的情况，我们在syscall.c中添加如下代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span><br><span class="hljs-comment">/* 非正常退出  */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">exit_error</span><span class="hljs-params">()</span><br>{<br>  thread_current()-&gt;exit_code = <span class="hljs-number">-1</span>;<br>  thread_exit();<br>}<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br></code></pre></td></tr></tbody></table></figure><p>3个合法性检查函数：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span><br><span class="hljs-comment">/* 手册提供的判断页面可否访问的代码 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <br><span class="hljs-title function_">get_user</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *uaddr)</span><br>{<br>  <span class="hljs-type">int</span> result;<br>  <span class="hljs-keyword">asm</span> (<span class="hljs-string">"movl $1f, %0; movzbl %1, %0; 1:"</span> : <span class="hljs-string">"=&amp;a"</span> (result) : <span class="hljs-string">"m"</span> (*uaddr));<br>  <span class="hljs-keyword">return</span> result;<br>}<br><br><span class="hljs-comment">/* 主要判断3个方面：</span><br><span class="hljs-comment"> * 1. 用户指针是否可以访问。  </span><br><span class="hljs-comment"> * 2. 地址是狗在用户虚拟内存范围内</span><br><span class="hljs-comment"> * 3. 用户虚拟内存是否对应存在的物理空间</span><br><span class="hljs-comment"> * 最后返回用户虚拟内存的返回物理地址 */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">check_valid</span><span class="hljs-params">(<span class="hljs-type">void</span>* vaddr)</span><br>{  <br>  <span class="hljs-comment">/* 逐次检测用户指针的4个字节，判断是否都能够</span><br><span class="hljs-comment">   * 成功访问。 */</span><br>  <span class="hljs-type">uint8_t</span> *check_byteptr = (<span class="hljs-type">uint8_t</span> *) vaddr;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) <br>  {<br>    <span class="hljs-keyword">if</span> (get_user(check_byteptr + i) == <span class="hljs-number">-1</span>)<br>    {<br>      exit_error ();<br>    }<br>  }<br><br>  <span class="hljs-keyword">if</span> (is_user_vaddr(vaddr) == <span class="hljs-literal">NULL</span>)<br>  {<br>    exit_error ();<br>  }<br><br>  <span class="hljs-comment">/* 返回物理地址 */</span><br>  <span class="hljs-type">void</span> *ptr = pagedir_get_page (thread_current()-&gt;pagedir, vaddr);<br>  <span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>)<br>  {<br>    exit_error ();<br>  }<br><br>  <span class="hljs-keyword">return</span> ptr;<br>}<br><br><span class="hljs-comment">/* 判断压入的参数是否全都合法 */</span><br><span class="hljs-type">bool</span><br><span class="hljs-title function_">is_valid_args</span><span class="hljs-params">(<span class="hljs-type">void</span>* esp, <span class="hljs-type">uint8_t</span> argc)</span><br>{<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; argc; ++i)<br>  {<br>    <span class="hljs-keyword">if</span>( (is_user_vaddr(esp) == <span class="hljs-literal">NULL</span>) || (pagedir_get_page(thread_current()-&gt;pagedir, esp) == <span class="hljs-literal">NULL</span>) )<br>    {<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br></code></pre></td></tr></tbody></table></figure><p>重写中断处理函数syscall_handler。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 重写syscall中断处理函数</span><br><span class="hljs-comment"> * 首先检查参数用户空间的合法性</span><br><span class="hljs-comment"> * 然后再检查中断号是否处在正确范围内 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">syscall_handler</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame *f UNUSED)</span> <br>{<br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span><br>  <span class="hljs-type">int</span> * p = f-&gt;esp;<br>  <span class="hljs-comment">/* 检查参数空间是否处于用户空间内 */</span><br>  check_valid(p + <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">/* 从栈顶取出中断号 */</span><br>  <span class="hljs-type">int</span> syscall_code = * (<span class="hljs-type">int</span>* ) f-&gt;esp;<br>  <span class="hljs-keyword">if</span>(syscall_code &lt;= <span class="hljs-number">0</span> || syscall_code &gt;= SYSCALL_MAX)<br>  {<br>    exit_error();<br>  }<br>  syscalls[syscall_code](f);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>}<br><br></code></pre></td></tr></tbody></table></figure><p>在syscall.h中添加如下声明：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;syscall-nr.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"userprog/process.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"userprog/pagedir.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"threads/interrupt.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"threads/malloc.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"threads/palloc.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"threads/interrupt.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"threads/thread.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"threads/vaddr.h"</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_MAX 20</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_user</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *uaddr)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">check_valid</span><span class="hljs-params">(<span class="hljs-type">void</span>* vaddr)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">exit_error</span><span class="hljs-params">()</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">is_valid_args</span><span class="hljs-params">(<span class="hljs-type">void</span>* esp, <span class="hljs-type">uint8_t</span> argc)</span>;<br><br><span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br></code></pre></td></tr></tbody></table></figure><p>在exception.c中修改</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">page_fault</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame *f)</span> <br>{<br>  <span class="hljs-type">bool</span> not_present;  <span class="hljs-comment">/* True: not-present page, false: writing r/o page. */</span><br>  <span class="hljs-type">bool</span> write;        <span class="hljs-comment">/* True: access was write, false: access was read. */</span><br>  <span class="hljs-type">bool</span> user;         <span class="hljs-comment">/* True: access by user, false: access by kernel. */</span><br>  <span class="hljs-type">void</span> *fault_addr;  <span class="hljs-comment">/* Fault address. */</span><br><br>  <span class="hljs-comment">/* Obtain faulting address, the virtual address that was</span><br><span class="hljs-comment">     accessed to cause the fault.  It may point to code or to</span><br><span class="hljs-comment">     data.  It is not necessarily the address of the instruction</span><br><span class="hljs-comment">     that caused the fault (that's f-&gt;eip).</span><br><span class="hljs-comment">     See [IA32-v2a] "MOV--Move to/from Control Registers" and</span><br><span class="hljs-comment">     [IA32-v3a] 5.15 "Interrupt 14--Page Fault Exception</span><br><span class="hljs-comment">     (#PF)". */</span><br>  <span class="hljs-keyword">asm</span> (<span class="hljs-string">"movl %%cr2, %0"</span> : <span class="hljs-string">"=r"</span> (fault_addr));<br><br>  <span class="hljs-comment">/* Turn interrupts back on (they were only off so that we could</span><br><span class="hljs-comment">     be assured of reading CR2 before it changed). */</span><br>  intr_enable ();<br><br>  <span class="hljs-comment">/* Count page faults. */</span><br>  page_fault_cnt++;<br><br>  <span class="hljs-comment">/* Determine cause. */</span><br>  not_present = (f-&gt;error_code &amp; PF_P) == <span class="hljs-number">0</span>;<br>  write = (f-&gt;error_code &amp; PF_W) != <span class="hljs-number">0</span>;<br>  user = (f-&gt;error_code &amp; PF_U) != <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span><br>  <span class="hljs-keyword">if</span>(user == <span class="hljs-number">0</span>)<br>  {<br>    f-&gt;eip = f-&gt;eax;<br>    f-&gt;eax = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span>;<br>  }<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br>  <span class="hljs-comment">/* To implement virtual memory, delete the rest of the function</span><br><span class="hljs-comment">     body, and replace it with code that brings in the page to</span><br><span class="hljs-comment">     which fault_addr refers. */</span><br>  <span class="hljs-built_in">printf</span> (<span class="hljs-string">"Page fault at %p: %s error %s page in %s context.\n"</span>,<br>          fault_addr,<br>          not_present ? <span class="hljs-string">"not present"</span> : <span class="hljs-string">"rights violation"</span>,<br>          write ? <span class="hljs-string">"writing"</span> : <span class="hljs-string">"reading"</span>,<br>          user ? <span class="hljs-string">"user"</span> : <span class="hljs-string">"kernel"</span>);<br>  kill (f);<br>}<br><br><br></code></pre></td></tr></tbody></table></figure><hr><h5 id="分析进程相关系统调用">分析：进程相关系统调用</h5><p>我们先来完成进程相关的四个系统调用的实现：<strong>halt、exit、exec、wait</strong>。</p><p>首先是halt，手册对于halt的描述很简单，他说终止Pintos是靠shutdown_power_off（在 ‘devices/shutdown.h’中声明）进行的，那么这没什么好分析的，<strong>直接调用shutdown_power_off就完事了</strong>。</p><p>手册在exit、exec的描述中，都提到了父进程，这是什么呢？</p><p>父子进程在对wait的系统调用中进行了详细的说明。</p><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/process_wait.png"></p><p>上图描述比较清晰的描述了父子进程之间的关系：</p><ol type="1"><li>父进程首先创建子进程，让其加载用户程序。</li><li>若成功加载，则进行参数传递。</li><li>进行完1、2后，要告知父进程是否成功执行了1、2。</li><li>若子进程成功加载、传参，告知父进程，父进程将调用wait，等待子进程运行。</li><li>子进程开始运行，知道进程退出，并告知父进程退出信息。</li><li>如果父进程有多个子进程，则循环上述步骤。</li><li>以上操作设计到进程的同步关系，因此需要使用信号量保证它们的执行次序。</li></ol><h5 id="实现进程相关系统调用">实现：进程相关系统调用</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 对于exec来说，输入是文件名+参数的字符串,首先是user_ptr</span><br><span class="hljs-comment"> * 存的是参数的地址，而输入的参数是字符串，即char*类型。</span><br><span class="hljs-comment"> * 首先应取出参数，然后将参数转换为char*类型即可。</span><br><span class="hljs-comment"> * 这里有点绕，简单来说就是*user_ptr取参数，(char*)将参数</span><br><span class="hljs-comment"> * 强制转换。 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_exec</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  <span class="hljs-type">uint32_t</span>* user_ptr = f-&gt;esp;<br>  check_valid(++user_ptr);<br>  check_valid(*user_ptr);<br>  f-&gt;eax = process_execute((<span class="hljs-type">char</span>*)* user_ptr);<br>}<br><br><span class="hljs-comment">/* wait输入的是1个pid，直接取出来即可，并且wait是有</span><br><span class="hljs-comment"> * 输出的，其输出为process的返回值，即退出信息码 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_wait</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  <span class="hljs-type">uint32_t</span>* user_ptr = f-&gt;esp;<br>  check_valid(++user_ptr);<br>  f-&gt;eax = process_wait(*user_ptr);<br>}<br><br><span class="hljs-comment">/* exit输入的是1个整型变量即退出状态，将其赋值给</span><br><span class="hljs-comment"> * 当前进程的退出信息数据中，然后调用线程退出函数。  */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_exit</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  <span class="hljs-type">uint32_t</span>* user_ptr = f-&gt;esp;<br>  check_valid(++user_ptr);<br>  thread_current()-&gt;exit_code = *user_ptr;<br>  thread_exit();<br>}<br><br><span class="hljs-comment">/* 关机函数，无输入参数，无返回值，直接调用关机</span><br><span class="hljs-comment"> * 函数即可。 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_halt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  shutdown_power_off();<br>  NOT_REACHED();<br>}<br></code></pre></td></tr></tbody></table></figure><p>在process.c中添加</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Starts a new thread running a user program loaded from</span><br><span class="hljs-comment">   FILENAME.  The new thread may be scheduled (and may even exit)</span><br><span class="hljs-comment">   before process_execute() returns.  Returns the new process's</span><br><span class="hljs-comment">   thread id, or TID_ERROR if the thread cannot be created. */</span><br><span class="hljs-type">tid_t</span><br><span class="hljs-title function_">process_execute</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file_name)</span> <br>{<br>  <span class="hljs-type">char</span> *fn_copy;<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-type">char</span> *fn_copy_for_thread_name;<br>  <span class="hljs-type">char</span> *thread_name, *save_ptr; <br>  fn_copy_for_thread_name = palloc_get_page (<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  <span class="hljs-type">tid_t</span> tid;<br><br>  <span class="hljs-comment">/* Make a copy of FILE_NAME.</span><br><span class="hljs-comment">     Otherwise there's a race between the caller and load(). */</span><br>  fn_copy = palloc_get_page (<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (fn_copy == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> TID_ERROR;<br>  strlcpy (fn_copy, file_name, PGSIZE);<br><br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 复制一个字符串，用于分割文件名作为线程名 */</span><br>  strlcpy (fn_copy_for_thread_name, file_name, PGSIZE);<br>  thread_name = strtok_r (fn_copy_for_thread_name, <span class="hljs-string">" "</span>, &amp;save_ptr);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br>  <span class="hljs-comment">/* Create a new thread to execute FILE_NAME. */</span><br>  tid = thread_create (thread_name, PRI_DEFAULT, start_process, fn_copy);<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 别忘记把它释放掉 */</span><br>  palloc_free_page (fn_copy_for_thread_name); <br><br>  <span class="hljs-keyword">if</span> (tid == TID_ERROR){<br>    palloc_free_page (fn_copy); <br>    <span class="hljs-keyword">return</span> tid;<br>  }<br><br>  <span class="hljs-comment">/* 等待子进程装载，如果装载不成功则返回ERROR */</span><br>  sema_down(&amp;thread_current()-&gt;sema);<br>  <span class="hljs-keyword">if</span>(!thread_current()-&gt;is_load_success)<br>    <span class="hljs-keyword">return</span> TID_ERROR;<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  <span class="hljs-keyword">return</span> tid;<br>}<br><br><span class="hljs-comment">/* A thread function that loads a user process and starts it</span><br><span class="hljs-comment">   running. */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">start_process</span> <span class="hljs-params">(<span class="hljs-type">void</span> *file_name_)</span><br>{<br>  <span class="hljs-type">char</span> *file_name = file_name_;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intr_frame</span> <span class="hljs-title">if_</span>;</span><br>  <span class="hljs-type">bool</span> success;<br><br>  <span class="hljs-comment">/* Initialize interrupt frame and load executable. */</span><br>  <span class="hljs-built_in">memset</span> (&amp;if_, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> if_);<br>  if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;<br>  if_.cs = SEL_UCSEG;<br>  if_.eflags = FLAG_IF | FLAG_MBS;<br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 将真正的文件名装载进去，会造成字符串修改，而文件名</span><br><span class="hljs-comment">   * 也是参数的一部分，因此我们使用original来保存</span><br><span class="hljs-comment">   * 原字符串的副本  */</span><br>  <span class="hljs-type">char</span> *real_file_name, *original_name, *save_ptr; <br>  original_name = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(file_name)+<span class="hljs-number">1</span>);<br>  strlcpy (original_name, file_name, <span class="hljs-built_in">strlen</span>(file_name)+<span class="hljs-number">1</span>);<br>  real_file_name = strtok_r (file_name_, <span class="hljs-string">" "</span>, &amp;save_ptr);<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  success = load (real_file_name, &amp;if_.eip, &amp;if_.esp);<br><br>  <span class="hljs-comment">/* If load failed, quit. */</span><br>  palloc_free_page (file_name);<br><br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 显然只有在成功装载之后，我们才需要参数传递 </span><br><span class="hljs-comment">   * 以下过程，就是把参数压入栈中，此处的顺序是自左向右</span><br><span class="hljs-comment">   * 这并没有什么关系，因为我们使用二级指针对参数压栈</span><br><span class="hljs-comment">   * 只需要保证压入二级指针时，是自右向左即可。</span><br><span class="hljs-comment">   * argv存储的是各个参数的首地址，即实际的二级指针</span><br><span class="hljs-comment">   * 而386系统中，地址是32位，因此使用int型。</span><br><span class="hljs-comment">   * argc则存储的是参数的个数。</span><br><span class="hljs-comment">   * 由于参数个数未知，我们使用动态分配地址的方法。 */</span><br><br>  <span class="hljs-type">int</span> argc = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> argv_size = <span class="hljs-number">50</span>;<br>  <span class="hljs-type">int</span>* argv = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>(argv_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>  <span class="hljs-type">char</span>* token;<br><br>  <span class="hljs-keyword">if</span>(success)<br>  {<br>    <span class="hljs-keyword">for</span> (token = strtok_r (original_name, <span class="hljs-string">" "</span>, &amp;save_ptr); token != <span class="hljs-literal">NULL</span>;<br>             token = strtok_r (<span class="hljs-literal">NULL</span>, <span class="hljs-string">" "</span>, &amp;save_ptr))<br>    {<br>      <span class="hljs-comment">/* 字符串是低地址往高地址存，并且注意'\0'也是字符串</span><br><span class="hljs-comment">       * 的一部分 */</span><br>      if_.esp -= <span class="hljs-built_in">strlen</span>(token)+<span class="hljs-number">1</span>;<br>      <span class="hljs-built_in">memcpy</span>(if_.esp, token, <span class="hljs-built_in">strlen</span>(token)+<span class="hljs-number">1</span>);<br>      argv[argc++] = (<span class="hljs-type">int</span>) if_.esp;<br>      <span class="hljs-keyword">if</span> (argc &gt; argv_size)<br>      {<br>        <span class="hljs-comment">//  如果空间不够，得重新分配 </span><br>        argv_size += <span class="hljs-number">10</span>;<br>        <span class="hljs-built_in">realloc</span>(argv, argv_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>* )); <br>      }<br>    }<br><br>    push_arg_and_retaddr(&amp;if_.esp, argc, argv);<br><br>  }<br> <br><br>  <span class="hljs-comment">/* 告诉父线程自己装载情况，并让父线程继续执行 */</span><br>  thread_current()-&gt;parent-&gt;is_load_success = success;<br>  sema_up(&amp;thread_current()-&gt;parent-&gt;sema);<br><br>  <span class="hljs-built_in">free</span>(original_name);<br>  <span class="hljs-built_in">free</span>(argv);<br><br>  <span class="hljs-keyword">if</span>(!success)<br>    thread_exit();<br><br> <br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br>  <span class="hljs-comment">/* Start the user process by simulating a return from an</span><br><span class="hljs-comment">     interrupt, implemented by intr_exit (in</span><br><span class="hljs-comment">     threads/intr-stubs.S).  Because intr_exit takes all of its</span><br><span class="hljs-comment">     arguments on the stack in the form of a `struct intr_frame',</span><br><span class="hljs-comment">     we just point the stack pointer (%esp) to our stack frame</span><br><span class="hljs-comment">     and jump to it. */</span><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">"movl %0, %%esp; jmp intr_exit"</span> : : <span class="hljs-string">"g"</span> (&amp;if_) : <span class="hljs-string">"memory"</span>)</span>;<br>  NOT_REACHED ();<br>}<br><br><span class="hljs-comment">/* Waits for thread TID to die and returns its exit status.  If</span><br><span class="hljs-comment">   it was terminated by the kernel (i.e. killed due to an</span><br><span class="hljs-comment">   exception), returns -1.  If TID is invalid or if it was not a</span><br><span class="hljs-comment">   child of the calling process, or if process_wait() has already</span><br><span class="hljs-comment">   been successfully called for the given TID, returns -1</span><br><span class="hljs-comment">   immediately, without waiting.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   This function will be implemented in problem 2-2.  For now, it</span><br><span class="hljs-comment">   does nothing. */</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">process_wait</span> <span class="hljs-params">(<span class="hljs-type">tid_t</span> child_tid UNUSED)</span> <br>{<br> <br>  <span class="hljs-comment">/*-------------------- Added by ZL -----------------------*/</span><br>  <span class="hljs-comment">/* 遍历整个child队列，如果发现child已经没被等待过了，那么</span><br><span class="hljs-comment">   * 阻塞自己，等待child执行，并置位等待标志位。如果child已经</span><br><span class="hljs-comment">   * 被等待过了，说明这是不正常的，应当返回-1。此外，子进程队列</span><br><span class="hljs-comment">   * 中没有对应的子进程ID，这也是非正常现象。  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span>* <span class="hljs-title">child_list</span> =</span> &amp;thread_current()-&gt;child_list;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span>* <span class="hljs-title">child_elem</span> =</span> list_begin(child_list);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">child_thread</span>* <span class="hljs-title">cur_child</span> =</span> <span class="hljs-literal">NULL</span>; <br>  <br>  <span class="hljs-keyword">while</span>(child_elem != list_end(child_list))<br>  { <br>    cur_child = list_entry(child_elem, <span class="hljs-keyword">struct</span> child_thread, elem);<br>    <span class="hljs-keyword">if</span>(cur_child-&gt;tid == child_tid)<br>      <span class="hljs-keyword">break</span>;<br>    child_elem = list_next(child_elem);<br>  }<br>  <br>  <span class="hljs-keyword">if</span>(child_elem == list_end(child_list) || cur_child-&gt;tid != child_tid)<br>  {<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  }<br>  <span class="hljs-keyword">else</span><br>  {<br>    cur_child-&gt;is_waited = <span class="hljs-literal">true</span>;<br>    sema_down(&amp;cur_child-&gt;sema);<br>    list_remove(child_elem);<br>  }<br><br>  <span class="hljs-keyword">return</span> cur_child-&gt;exit_code;<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>}<br><br></code></pre></td></tr></tbody></table></figure><hr><h5 id="分析文件相关系统调用">分析：文件相关系统调用</h5><p><img src="D:/ZJUT/Operating%20System/pintos/code/tmp/cic-master/pNotes.assets/file_syscall.png"></p><p>CREATE：主要就是调用filesys_create即可。</p><p>OPEN： 在用户打开文件时，要维护一个打开文件表，者可以用链表实现。文件表记录着每个文件的file结构体以及其相对应的fd。所谓fd是文件描述符，整型变量。对于一个进程来说，其打开的所有文件的文件描述符都是不相同的，但不同的进程相同文件可以有不同文件描述符。read、write、close等系统调用都是依据fd来操作的。</p><p>READ：读入文件描述符fd，然后在该进程的打开文件表中，找到fd对应的file，进行读操作即可。需要注意的是，fd=0时，是标准输入，此时可以调用input_getc，这样就能从键盘中读入字符了。</p><p>WRITE：与read类似，同样先是找到fd对应的file，进行写操作。类似的，fd=1表示标准输出，此时可以使用printf输出到屏幕即可。</p><p>CLOSE：在用户打开文件时，处了使用pintos提供的关闭文件操作，同时，还要将文件从打开文件表中删除。</p><p>REMOVE：主要就是调用filesys_remove即可。</p><p>FILESIZE、TELL和SEEK的执行机制都一样，都是通过fd找到对应的file，然后运行pintos文件系统提供的函数即可。</p><p><strong>注：以上的所有操作都要加锁，以互斥访问</strong></p><hr><h5 id="实现文件相关系统调用">实现：文件相关系统调用</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 文件创建操作输入的参数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  <span class="hljs-type">uint32_t</span> *user_ptr = f-&gt;esp;<br>  <span class="hljs-comment">/* ??? */</span><br>  check_valid(user_ptr + <span class="hljs-number">5</span>);<br>  check_valid(*(user_ptr + <span class="hljs-number">4</span>));<br>  user_ptr++;<br><br>  acquire_file_lock();<br>  f-&gt;eax = filesys_create ((<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)*user_ptr, *(user_ptr+<span class="hljs-number">1</span>));<br>  release_file_lock();<br>}<br><br><span class="hljs-comment">/* 文件删除操作输入的参数为文件名 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br><br>  <span class="hljs-type">uint32_t</span> *user_ptr = f-&gt;esp;<br>  check_valid(++user_ptr);<br>  check_valid(*user_ptr);<br><br>  acquire_file_lock();<br>  f-&gt;eax = filesys_remove ((<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)*user_ptr);<br>  release_file_lock();<br><br>}<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  <span class="hljs-type">uint32_t</span> *user_ptr = f-&gt;esp;<br>  check_valid(user_ptr + <span class="hljs-number">1</span>);<br>  check_valid(*(user_ptr + <span class="hljs-number">1</span>));<br>  *user_ptr++;<br><br>  acquire_file_lock();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">file_opened</span> =</span> filesys_open((<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)*user_ptr);<br>  release_file_lock();<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> * <span class="hljs-title">t</span> =</span> thread_current();<br><br>  <span class="hljs-keyword">if</span> (file_opened)<br>  {<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_file</span> *<span class="hljs-title">thread_file_temp</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> thread_file));<br>    thread_file_temp-&gt;fd = t-&gt;fd++;<br>    thread_file_temp-&gt;file = file_opened;<br>    list_push_back (&amp;t-&gt;file_list, &amp;thread_file_temp-&gt;elem);<br>    f-&gt;eax = thread_file_temp-&gt;fd;<br>  } <br>  <span class="hljs-keyword">else</span><br>  {<br>    f-&gt;eax = <span class="hljs-number">-1</span>;<br>  }<br><br>}<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_close</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  <span class="hljs-type">uint32_t</span> *user_ptr = f-&gt;esp;<br>  check_valid(++user_ptr);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_file</span> * <span class="hljs-title">opened_file</span> =</span> find_file_by_fd (*user_ptr);<br>  <span class="hljs-keyword">if</span> (opened_file)<br>  {<br>    acquire_file_lock ();<br>    file_close (opened_file-&gt;file);<br>    release_file_lock ();<br>    list_remove (&amp;opened_file-&gt;elem);<br>    <span class="hljs-built_in">free</span>(opened_file);<br>  }<br><br>}<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{  <br>  <span class="hljs-type">int32_t</span> *user_ptr = f-&gt;esp;<br>  *user_ptr++;<br>  <span class="hljs-type">int</span> fd = *user_ptr;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">uint8_t</span> * buffer = (<span class="hljs-type">uint8_t</span>*)*(user_ptr+<span class="hljs-number">1</span>);<br>  <span class="hljs-type">uint32_t</span> size = *(user_ptr+<span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (!is_valid_args(buffer, <span class="hljs-number">1</span>) || !is_valid_args(buffer + size,<span class="hljs-number">1</span>))<br>  {<br>     exit_error();<br>  }<br><br>  <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">0</span>) <br>  {<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>    buffer[i] = input_getc();<br>    f-&gt;eax = size;<br>  }<br>  <span class="hljs-keyword">else</span><br>  {<br>    <span class="hljs-keyword">struct</span> thread_file * thread_file_temp = find_file_by_fd(*user_ptr);<br>    <span class="hljs-keyword">if</span> (thread_file_temp)<br>    {<br>      acquire_file_lock();<br>      f-&gt;eax = file_read (thread_file_temp-&gt;file, buffer, size);<br>      release_file_lock();<br>    } <br>    <span class="hljs-keyword">else</span><br>    {<br>      f-&gt;eax = <span class="hljs-number">-1</span>;<br>    }<br>  }<br><br>}<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  <span class="hljs-type">uint32_t</span> *user_ptr = f-&gt;esp;<br>  check_valid(user_ptr + <span class="hljs-number">7</span>);<br>  check_valid(*(user_ptr + <span class="hljs-number">6</span>));<br>  *user_ptr++;<br>  <span class="hljs-type">int</span> temp2 = *user_ptr;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> * buffer = (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)*(user_ptr+<span class="hljs-number">1</span>);<br>  <span class="hljs-type">uint32_t</span> size = *(user_ptr+<span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (temp2 == <span class="hljs-number">1</span>) <br>  {<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, buffer);<br>    f-&gt;eax = size;<br>  }<br>  <span class="hljs-keyword">else</span><br>  {<br>    <span class="hljs-keyword">struct</span> thread_file * thread_file_temp = find_file_by_fd(*user_ptr);<br>    <span class="hljs-keyword">if</span> (thread_file_temp)<br>    {<br>      acquire_file_lock();<br>      f-&gt;eax = file_write (thread_file_temp-&gt;file, buffer, size);<br>      release_file_lock();<br>    } <br>    <span class="hljs-keyword">else</span><br>    {<br>     f-&gt;eax = <span class="hljs-number">0</span>;<br>    }<br>  }<br><br>}<br><br><span class="hljs-comment">/* 通过输入的fd先取找到相应的file数据结构，在执行操作 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_filesize</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  <span class="hljs-type">uint32_t</span> *user_ptr = f-&gt;esp;<br>  check_valid(++user_ptr);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_file</span>* <span class="hljs-title">file_target</span> =</span> find_file_by_fd(*user_ptr);<br><br>  <span class="hljs-keyword">if</span>(file_target != <span class="hljs-literal">NULL</span>)<br>  {<br>    acquire_file_lock();<br>    f-&gt;eax = file_length(file_target-&gt;file);<br>    release_file_lock();<br>  } <br>  <span class="hljs-keyword">else</span><br>  {<br>    f-&gt;eax = <span class="hljs-number">-1</span>;<br>  }<br><br>}<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_seek</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br><br>  <span class="hljs-type">uint32_t</span> *user_ptr = f-&gt;esp;<br>  check_valid(user_ptr + <span class="hljs-number">5</span>);<br>  user_ptr++;<br>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_file</span>* <span class="hljs-title">file_target</span> =</span> find_file_by_fd(*user_ptr);<br>  <span class="hljs-keyword">if</span>(file_target)<br>  {<br>    acquire_file_lock();<br>    file_seek(file_target-&gt;file, *(user_ptr+<span class="hljs-number">1</span>));<br>    release_file_lock();<br>  }<br>  <span class="hljs-keyword">else</span><br>  {<br>    f-&gt;eax = <span class="hljs-number">-1</span>;<br>  }<br>}<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">sys_tell</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> intr_frame* f)</span><br>{<br>  <span class="hljs-type">uint32_t</span> *user_ptr = f-&gt;esp;<br>  check_valid(++user_ptr);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_file</span>* <span class="hljs-title">file_target</span> =</span> find_file_by_fd(*user_ptr);<br>  <span class="hljs-keyword">if</span>(file_target)<br>  {<br>    acquire_file_lock();<br>    f-&gt;eax = file_tell(file_target-&gt;file);<br>    release_file_lock();<br>  }<br>  <span class="hljs-keyword">else</span><br>  {<br>    f-&gt;eax = <span class="hljs-number">-1</span>;<br>  }<br><br>}<br><br><span class="hljs-comment">/* 通过fd寻找file */</span><br><span class="hljs-keyword">struct</span> thread_file*<br><span class="hljs-title function_">find_file_by_fd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>{<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span>* <span class="hljs-title">e</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_file</span>* <span class="hljs-title">thread_file_ptr</span> =</span> <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span>* <span class="hljs-title">files</span> =</span> &amp;thread_current()-&gt;file_list;<br>  <span class="hljs-keyword">for</span>(e = list_begin (files); e != list_end (files); e = list_next(e))<br>  {<br>    thread_file_ptr = list_entry(e, <span class="hljs-keyword">struct</span> thread_file, elem);<br>    <span class="hljs-keyword">if</span> (fd == thread_file_ptr-&gt;fd)<br>      <span class="hljs-keyword">return</span> thread_file_ptr;<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="task4-denying-writes-to-executables">Task4: Denying Writes to Executables</h4><h5 id="分析-4">分析</h5><p>在文档中，它对该任务是这么描述的</p><figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">You can use file_deny_write() <span class="hljs-keyword">to</span> prevent writes <span class="hljs-keyword">to</span> an open <span class="hljs-built_in">file</span>. Calling file_allow_<br><span class="hljs-built_in">write</span>() <span class="hljs-keyword">on</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span> will re-enable them (unless <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span> <span class="hljs-keyword">is</span> denied writes <span class="hljs-keyword">by</span> another opener. Closing a <span class="hljs-built_in">file</span> will also re-enable writes. Thus,<span class="hljs-keyword">to</span> deny writes <span class="hljs-keyword">to</span> a process’s executable, you must keep <span class="hljs-keyword">it</span> open <span class="hljs-keyword">as</span> long <span class="hljs-keyword">as</span> <span class="hljs-keyword">the</span> process <span class="hljs-keyword">is</span> still <span class="hljs-built_in">running</span>.<br></code></pre></td></tr></tbody></table></figure><p>该任务的实现也很简单，就是在装载的时候调用file_deny_write拒绝写入。利用t-&gt;file_owned = file存储拥有的这个文件（即只有这个文件可以写），这是为了方便进程退出后关闭文件。还需注意的是，load中原本在结尾是要关闭文件的。但是，为了完成进程能够一致保持着对改文件的所有权，应注释掉file_close。而使之推迟至进程退出后执行。</p><h5 id="实现-4">实现</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Loads an ELF executable from FILE_NAME into the current thread.</span><br><span class="hljs-comment">   Stores the executable's entry point into *EIP</span><br><span class="hljs-comment">   and its initial stack pointer into *ESP.</span><br><span class="hljs-comment">   Returns true if successful, false otherwise. */</span><br><span class="hljs-type">bool</span><br><span class="hljs-title function_">load</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file_name, <span class="hljs-type">void</span> (**eip) (<span class="hljs-type">void</span>), <span class="hljs-type">void</span> **esp)</span> <br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">t</span> =</span> thread_current ();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Elf32_Ehdr</span> <span class="hljs-title">ehdr</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span> =</span> <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-type">off_t</span> file_ofs;<br>  <span class="hljs-type">bool</span> success = <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">int</span> i;<br><br>  <span class="hljs-comment">/* Allocate and activate page directory. */</span><br>  t-&gt;pagedir = pagedir_create ();<br>  <span class="hljs-keyword">if</span> (t-&gt;pagedir == <span class="hljs-literal">NULL</span>) <br>    <span class="hljs-keyword">goto</span> done;<br>  process_activate ();<br><br>  <span class="hljs-comment">/* Open executable file. */</span><br>  <span class="hljs-comment">// acquire_file_lock();</span><br>  file = filesys_open (file_name);<br>  <span class="hljs-keyword">if</span> (file == <span class="hljs-literal">NULL</span>) <br>    {<br>      <span class="hljs-built_in">printf</span> (<span class="hljs-string">"load: %s: open failed\n"</span>, file_name);<br>      <span class="hljs-keyword">goto</span> done; <br>    }<br><br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span> <br>  file_deny_write(file);<br>  t-&gt;file_owned = file;<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span> <br><br>  <span class="hljs-comment">/* Read and verify executable header. */</span><br>  <span class="hljs-keyword">if</span> (file_read (file, &amp;ehdr, <span class="hljs-keyword">sizeof</span> ehdr) != <span class="hljs-keyword">sizeof</span> ehdr<br>      || <span class="hljs-built_in">memcmp</span> (ehdr.e_ident, <span class="hljs-string">"\177ELF\1\1\1"</span>, <span class="hljs-number">7</span>)<br>      || ehdr.e_type != <span class="hljs-number">2</span><br>      || ehdr.e_machine != <span class="hljs-number">3</span><br>      || ehdr.e_version != <span class="hljs-number">1</span><br>      || ehdr.e_phentsize != <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> Elf32_Phdr)<br>      || ehdr.e_phnum &gt; <span class="hljs-number">1024</span>) <br>    {<br>      <span class="hljs-built_in">printf</span> (<span class="hljs-string">"load: %s: error loading executable\n"</span>, file_name);<br>      <span class="hljs-keyword">goto</span> done; <br>    }<br><br>  <span class="hljs-comment">/* Read program headers. */</span><br>  file_ofs = ehdr.e_phoff;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ehdr.e_phnum; i++) <br>    {<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Elf32_Phdr</span> <span class="hljs-title">phdr</span>;</span><br><br>      <span class="hljs-keyword">if</span> (file_ofs &lt; <span class="hljs-number">0</span> || file_ofs &gt; file_length (file))<br>        <span class="hljs-keyword">goto</span> done;<br>      file_seek (file, file_ofs);<br><br>      <span class="hljs-keyword">if</span> (file_read (file, &amp;phdr, <span class="hljs-keyword">sizeof</span> phdr) != <span class="hljs-keyword">sizeof</span> phdr)<br>        <span class="hljs-keyword">goto</span> done;<br>      file_ofs += <span class="hljs-keyword">sizeof</span> phdr;<br>      <span class="hljs-keyword">switch</span> (phdr.p_type) <br>        {<br>        <span class="hljs-keyword">case</span> PT_NULL:<br>        <span class="hljs-keyword">case</span> PT_NOTE:<br>        <span class="hljs-keyword">case</span> PT_PHDR:<br>        <span class="hljs-keyword">case</span> PT_STACK:<br>        <span class="hljs-keyword">default</span>:<br>          <span class="hljs-comment">/* Ignore this segment. */</span><br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> PT_DYNAMIC:<br>        <span class="hljs-keyword">case</span> PT_INTERP:<br>        <span class="hljs-keyword">case</span> PT_SHLIB:<br>          <span class="hljs-keyword">goto</span> done;<br>        <span class="hljs-keyword">case</span> PT_LOAD:<br>          <span class="hljs-keyword">if</span> (validate_segment (&amp;phdr, file)) <br>            {<br>              <span class="hljs-type">bool</span> writable = (phdr.p_flags &amp; PF_W) != <span class="hljs-number">0</span>;<br>              <span class="hljs-type">uint32_t</span> file_page = phdr.p_offset &amp; ~PGMASK;<br>              <span class="hljs-type">uint32_t</span> mem_page = phdr.p_vaddr &amp; ~PGMASK;<br>              <span class="hljs-type">uint32_t</span> page_offset = phdr.p_vaddr &amp; PGMASK;<br>              <span class="hljs-type">uint32_t</span> read_bytes, zero_bytes;<br>              <span class="hljs-keyword">if</span> (phdr.p_filesz &gt; <span class="hljs-number">0</span>)<br>                {<br>                  <span class="hljs-comment">/* Normal segment.</span><br><span class="hljs-comment">                     Read initial part from disk and zero the rest. */</span><br>                  read_bytes = page_offset + phdr.p_filesz;<br>                  zero_bytes = (ROUND_UP (page_offset + phdr.p_memsz, PGSIZE)<br>                                - read_bytes);<br>                }<br>              <span class="hljs-keyword">else</span> <br>                {<br>                  <span class="hljs-comment">/* Entirely zero.</span><br><span class="hljs-comment">                     Don't read anything from disk. */</span><br>                  read_bytes = <span class="hljs-number">0</span>;<br>                  zero_bytes = ROUND_UP (page_offset + phdr.p_memsz, PGSIZE);<br>                }<br>              <span class="hljs-keyword">if</span> (!load_segment (file, file_page, (<span class="hljs-type">void</span> *) mem_page,<br>                                 read_bytes, zero_bytes, writable))<br>                <span class="hljs-keyword">goto</span> done;<br>            }<br>          <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">goto</span> done;<br>          <span class="hljs-keyword">break</span>;<br>        }<br>    }<br><br>  <span class="hljs-comment">/* Set up stack. */</span><br>  <span class="hljs-keyword">if</span> (!setup_stack (esp))<br>    <span class="hljs-keyword">goto</span> done;<br><br>  <span class="hljs-comment">/* Start address. */</span><br>  *eip = (<span class="hljs-type">void</span> (*) (<span class="hljs-type">void</span>)) ehdr.e_entry;<br><br>  success = <span class="hljs-literal">true</span>;<br><br> done:<br>  <span class="hljs-comment">/* We arrive here whether the load is successful or not. */</span><br>  <span class="hljs-comment">// file_close (file);</span><br>  <span class="hljs-keyword">return</span> success;<br>}<br></code></pre></td></tr></tbody></table></figure><p>在thread.c中添加</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">thread_exit</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>{<br>  ASSERT (!intr_context ());<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USERPROG</span><br>  process_exit ();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-comment">/* Remove thread from all threads list, set our status to dying,</span><br><span class="hljs-comment">     and schedule another process.  That process will destroy us</span><br><span class="hljs-comment">     when it calls thread_schedule_tail(). */</span><br>  intr_disable ();<br>  <span class="hljs-comment">/*--------------------- Added by ZL ----------------------*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USERPROG</span><br>  <span class="hljs-comment">/* 告诉父进程自己的退出码 */</span><br>  thread_current()-&gt;child-&gt;exit_code = thread_current()-&gt;exit_code;<br>  sema_up(&amp;thread_current()-&gt;child-&gt;sema);<br>  file_close (thread_current ()-&gt;file_owned);<br>  close_all_files();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  <br>  list_remove (&amp;thread_current()-&gt;allelem);<br>  thread_current ()-&gt;status = THREAD_DYING;<br>  schedule ();<br>  NOT_REACHED ();<br>}<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>操作系统</tag>
      
      <tag>Git</tag>
      
      <tag>GDB</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统知识整理</title>
    <link href="/2022/02/09/os/cao-zuo-xi-tong-zhi-shi-dian-zheng-li/"/>
    <url>/2022/02/09/os/cao-zuo-xi-tong-zhi-shi-dian-zheng-li/</url>
    
    <content type="html"><![CDATA[<h1 id="operating-system">Operating System</h1><h2 id="操作系统概述">操作系统概述</h2><h3 id="计算机资源的管理者">计算机资源的管理者</h3><p>主要管理处理机、存储器、文件、设备。</p><h3 id="为用户提供硬件系统的接口">为用户提供硬件系统的接口</h3><p>命令接口（shell，又分联机、脱机）和系统调用（又称广义指令，用于请求系统<strong>服务</strong>）</p><h3 id="最基本的特征">最基本的特征</h3><p>并发（<strong>不是并行</strong>）、共享</p><h3 id="系统调用">系统调用</h3><figure><img src="D:\ZJUT\OS\Notes\notes.assets\image-20211211190408030.png" alt="image-20211211190408030"><figcaption aria-hidden="true">image-20211211190408030</figcaption></figure><h4 id="系统调用和库函数">系统调用和库函数</h4><p>库函数是语言或应用程序的一部分，可以运行再用户空间中。而系统调用是操作系统的一部分，是内核为用户提供的程序接口，运行再内核空间中，而且许多库函数都会使用系统调用来实现功能。未使用系统调用的库函数，其执行效率通常要比系统调用的高。因为使用系统调用时，需要上下文切换及状态的转换（用户态转为和心态）。</p><h3 id="操作发展史">操作发展史</h3><p>手工操作系统（=没有操作系统）--&gt;批处理阶段</p><figure><img src="D:\ZJUT\OS\Notes\notes.assets\image-20211211192551500.png" alt="image-20211211192551500"><figcaption aria-hidden="true">image-20211211192551500</figcaption></figure><h4 id="手工操作系统">手工操作系统</h4><p>略</p><h4 id="批处理阶段">批处理阶段</h4><h5 id="单道批处理系统">单道批处理系统</h5><p>如磁带</p><p>自动性、顺序性、单道性</p><h5 id="多道批处理系统">多道批处理系统</h5><p>多道、宏观上并行、微观上串行</p><p>多道程序设计的基本特征：制约性、间断性、共享性</p><h4 id="分时操作系统">分时操作系统</h4><p>同时性：多路性，多个用户同时使用一个计算机</p><p>交互性：通过终端进行人机交互、人机对话</p><p>独立性：用户之间独立操作、互不干扰</p><p>及时性：时间片轮转，响应时间短</p><h4 id="实时操作系统">实时操作系统</h4><p>硬实时：某个动作必须再规定时间内完成，如飞行器系统</p><p>软实时：可偶尔超出规定时间，如飞机订票、银行管理等</p><h4 id="网络操作系统和分布式系统">网络操作系统和分布式系统</h4><p>略</p><h4 id="个人计算机操作系统">个人计算机操作系统</h4><p>如windows、linux等</p><h3 id="操作系统运行环境">操作系统运行环境</h3><h2 id="内存管理">内存管理</h2><h3 id="硬件">硬件</h3><p>内存管理的实现高度依赖硬件</p><p><strong>MMU（内存管理单元）</strong></p><h3 id="操作系统">操作系统</h3><ol type="1"><li>重定位</li><li>分段</li><li>分页</li><li>虚拟内存</li></ol><h3 id="地址">地址</h3><h4 id="物理地址空间">物理地址空间</h4><p>由物理地址线决定</p><p>显然，程序员并不好直接使用物理地址空间</p><h4 id="逻辑地址空间">逻辑地址空间</h4><p>运行的进程，所能看到的地址</p><h4 id="地址生成">地址生成</h4><p>一个c程序的执行之旅：</p><p>.c .h文件 -&gt; 编译 -&gt; 汇编 -&gt; 链接 -&gt; 程序加载（重定位）</p><h5 id="生成时机">生成时机</h5><p>逻辑地址</p><ol type="1"><li><p>编译时就会产生逻辑地址</p></li><li><p>但链接后会产生最终的逻辑地址</p></li></ol><p>可重入程序</p><p>​ 一个此程序被某进程调用，还未结束，又被另一个进程调用</p><p>​ 共享使用同一块存储空间的，或者通过动态链接的方式将所需的程序段映射到相关进程中去，减少对换信息量来改善系统响应时间</p><p>物理地址有3种情况：</p><ol type="1"><li>编译时就生成地址，程序写死了</li><li>加载时，通过重定位生成物理地址</li><li>执行时生成地址</li></ol><h5 id="生成过程">生成过程</h5><p>ALU MMU 地址映射</p><h3 id="内存分配">内存分配</h3><h4 id="连续内存分配">连续内存分配</h4><p>根据空闲分区表、寻找空闲区域、释放区域的不同可分为</p><h5 id="最先分配">最先分配</h5><p>分配n个字节,使用第一个可用的空间比n大的空闲块。</p><h5 id="最优匹配">最优匹配</h5><p>分配n字节分区时，查找并使用不小于n的最小空闲分区</p><h5 id="最差匹配">最差匹配</h5><p>分配n字节，使用尺寸不小于n的最大空闲分区</p><h4 id="碎片整理">碎片整理</h4><h5 id="紧凑compaction">紧凑（compaction）</h5><p>紧凑的条件：可动态重定位</p><h5 id="分区对换swapping-inout">分区对换（swapping in/out）</h5><h4 id="伙伴系统buddy-system">伙伴系统（buddy system）</h4><p>整个可分配的分区大小<span class="math inline">\(2^u\)</span>，需要的分区大小<span class="math inline">\(s\)</span>满足<span class="math inline">\(2^{u-1}&lt;s&lt;2^u\)</span>。 空闲块按大小和起始地址组织成二维数组，初始地址只有一个大小为<span class="math inline">\(2^u\)</span></p><h3 id="非连续分配">非连续分配</h3><p>需解决的问题 虚拟地址和物理地址的转换</p><ol type="1"><li>软件实现</li><li>硬件实现</li></ol><p>内存分块的大小问题</p><ol type="1"><li>段式存储</li><li>页式存储</li></ol><h3 id="段式存储">段式存储</h3><h4 id="分门别类">分门别类</h4><p>我们在整理东西的时候，很多时候会把属性、类别相似的东西放在一起<br>对于不同类别的东西分别放在不同的地方<br>那么段式存储用的就是这样的想法</p><p>进程的段地址空间由多个段组成<br>例如我们通常将逻辑地址分为堆栈段、数据段、代码段<br>可以看到段的分离是具有意义的，而且一个段的大小也是不一定的<br>作用：更细粒度和灵活的分离和共享（？）</p><h4 id="什么是段">什么是段</h4><p><strong>段（segment）</strong>表示访问方式和存储数据等属性相同的一段地址空间<br>对应一个连续内存的“块”<br>若干个段组成进程的逻辑地址空间<br>段访问：段号：段内偏移地址</p><p>硬件实现：段号-&gt;查段表-&gt;段描述符-&gt;合法性检查-&gt;段基址+偏移地址=物理地址</p><h3 id="页式存储">页式存储</h3><h4 id="固定大小">固定大小</h4><p>如果说段解决了我们对代码分门别类的需要<br>段内连续，段间不连续<br>而一个段的大小是不固定的，那么很容易造成连续内存管理中的碎片问题<br>有没有可能让段内地址也不连续呢？把它们也分开来？</p><p>当然可以！如果将内存分成一个个<strong>固定大小</strong>的抽屉<br>然后把段内地址空间塞到一个个抽屉里，那就可以把段内的地址空间页拆开了<br>若是要寻找实际的物理地址，只需要在维护一张目录就可以了（即每个部分放在第几号抽屉）<br>这就是<strong>页</strong></p><h4 id="什么是页">什么是页</h4><p>进程内逻辑地址空间被划分为大小相等的<strong>页（page）</strong><br>物理内存被划分为大小相等（与页大小相等）的<strong>帧（Frame）</strong><br>页是逻辑地址的概念，而帧是物理地址的概念<br>页内偏移地址 = 帧内偏移地址</p><p>页-&gt;帧<br>页号-&gt;页表-&gt;帧号-&gt;帧号+偏移地址=物理地址</p><h4 id="存储页的索引或目录页表page-table">存储页的索引或目录——页表（Page Table）</h4><p>每个进程都维护着一个页表<br>每个页面对应一个页表项（或者页描述符）<br>随进程的运行状态而动态变化<br>页表项中可能有以下标志位（取决于具体硬件）：</p><ol type="1"><li>存在位：分配时根据该标志位来决定是否分配</li><li>修改位</li><li>引用位</li></ol><h4 id="快表与多级页表">快表与多级页表</h4><p>页式存储带来的问题：</p><ol type="1"><li>性能问题，二次访问：先访问页表，再访问实际内存</li><li>页表本身也需要占用存储空间</li></ol><h5 id="快表translation-look-aside-buffer-tlb">快表（Translation Look-aside Buffer, TLB）</h5><p>对于问题1，将上一次的访问页表项缓存下来<br>TLB使用关联存储（硬件实现，具有并行、速度快、功耗高、容量小的特定）来实现<br>TLB就类似于CPU中的cache</p><h5 id="多级页表">多级页表</h5><p>对于问题2，间接访问（再建一个目录，目录的目录），即多级页表<br>对于k级页表，要访问k+1次<br>如80386就是二级页表机制<br>之所以可以减少空间的浪费，拿二级页表为例，若一级页表某个页表项存在位为0<br>那么对应的二级页表也就不需要维护了</p><h5 id="反置页表">反置页表</h5><p>对于问题2，除了多级页表的解决方法，还可以改进<br>显然多级页表需要增加访问次数，降低效率</p><h4 id="section"></h4><h3 id="段页式存储">段页式存储</h3><h3 id="虚拟内存">虚拟内存</h3><h4 id="外存">外存</h4><p>传统内存：一次性、驻留性</p><p>内存不够，有时需要短暂的将进程移到外存中去</p><h4 id="覆盖和交换">覆盖和交换</h4><ol type="1"><li>覆盖：通过进程中的各模块的调用顺序来节省空间</li></ol><p></p><pre><code class=" mermaid">graph LRA--&gt;BA--&gt;CB--&gt;DC--&gt;EC--&gt;F</code></pre><p></p><ol start="2" type="1"><li>交换</li></ol><h4 id="局部性原理">局部性原理</h4><p>时间局部性：某个指令或数据被执行或访问过，那么近期很可能还会在执行或访问</p><p>空间局部性：程序访问了某个存储单元，那么很可能会访问该存储单元附近的存储单元</p><p>快表（TLB）是局部性原理的应用之一。</p><h4 id="容量">容量</h4><p>虚拟内存的最大容量：寻址范围</p><p>实际容量：min(内存与外存的容量之和, 寻址范围)。</p><h4 id="特性">特性</h4><p>多次性：允许数据多次调如内存</p><p>对换性：作业运行时，无需一直常驻内存</p><p>虚拟性：对于用户来说，内存的虚拟容量提升</p><h4 id="虚拟页式存储">虚拟页式存储</h4><p>功能：请求调页、页面置换</p><h3 id="请求调页">请求调页</h3><h4 id="页表机制">页表机制</h4><p>状态位：调入内存？</p><p>访问字段：访问次数？上一次访问时间？</p><p>修改位：修改过？写指令，才修改，并且只修改快表中的内容，快表项删除时，再写回</p><p>外存地址：存在哪块？</p><h4 id="缺页中断机构">缺页中断机构</h4><p>产生缺页中断（内中断），故障（fault）</p><p>可能产生多次中断，因为一条指令可能访问多个存储的单元</p><p>缺页进程被阻塞：</p><ol type="1"><li><p>若内存有空闲块，则为进程分配一个空闲块</p></li><li><p>若无，则使用<strong>页面置换算法</strong>，淘汰一个页面</p></li></ol><p>若有快表：</p><p>查询快表-&gt;缺页-&gt;查慢表-&gt;调页至内存-&gt;复制到快表</p><h4 id="地址变换机构">地址变换机构</h4><p>请求调页：先进行判断，是否存在</p><p>页面置换：页面置换</p><p>是否修改：。。只有写指令才需要改变修改位</p><p>先在快表中查，若快表没有，再在慢表中查</p><p>某个页面调出外存，则应删除快表中的内容</p><h3 id="页面置换算法">页面置换算法</h3><h4 id="置换算法的评价">置换算法的评价</h4><p>置换过程中，缺页的次数</p><p>如访问顺序为a, b, a, c, b, d, c, a...</p><p>在访问过程中缺页的次数</p><p>缺页率=缺页次数/访问次数</p><h4 id="算法分类">算法分类</h4><h5 id="局部页面置换算法">局部页面置换算法</h5><p>仅限当前进程占用的物理页面</p><ul><li><p>最优算法、先进先出、最近最久未使用</p></li><li><p>时钟算法、最不常用算法</p></li></ul><h5 id="全局页面置换算法">全局页面置换算法</h5><p>范围是所有可换出的物理页面</p><ul><li>工作集算法、缺页率算法</li></ul><h4 id="局部页面置换详解">局部页面置换详解</h4><h5 id="最优算法opt">最优算法（OPT）</h5><p>选择未来最长时间不访问的页面进行置换</p><p>第一次使用离目前时间最远的</p><p>显然这无法实现，因为无法预知未来</p><p>该算法的意义是作为baseline，评估其他的优劣</p><h5 id="先进先出fifo">先进先出（FIFO）</h5><p>实现简单，但性能较差</p><p>很少单独使用</p><h5 id="最近最久未使用lru">最近最久未使用（LRU）</h5><p>Leat Recently Used</p><p>选择过去最久未访问的页面置换，是OPT的近似</p><p>OPT是往后，LRU是往前</p><p>记录过去访问此处最少的页面，进行置换</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">序号 <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br>假设访问次数为 c <span class="hljs-selector-tag">a</span> d <span class="hljs-selector-tag">b</span> e <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c d<br>最开始的物理存储顺序为  <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c d<br>在访问e时缺页<br><span class="hljs-selector-tag">a</span> = <span class="hljs-number">2</span> (数字就是最近访问的序号)<br><span class="hljs-selector-tag">b</span> = <span class="hljs-number">4</span><br>c = <span class="hljs-number">1</span><br>d = <span class="hljs-number">3</span><br>选择最小的d<br>物理存储顺序改为 <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c e<br></code></pre></td></tr></tbody></table></figure><ul><li><p>可能的实现方法</p><ul><li><p>维护一个按最近一次访问时间排序的链表</p></li><li><p>活动页面栈，压入栈后，把相同的页号抽出来</p><p><img src="D:\ZJUT\OS\Notes\notes.assets\image-20211210104231984.png" alt="image-20211210104231984" style="zoom:33%;"></p></li></ul></li><li><p>时间空间开销都太大，算法复杂</p></li></ul><h5 id="时钟算法clock">时钟算法（Clock）</h5><p>对页面访问的情况进行大致统计</p><p>页表项中增加<strong>访问位</strong>，各页面组织成一个<strong>环形链表</strong>，指针指向最先调入的页面</p><p>缺页时<strong>从指针开始处（从头开始？）顺序查找未被访问的页面</strong>进行置换</p><p><img src="D:\ZJUT\OS\Notes\notes.assets\image-20211210104931119.png" alt="image-20211210104931119" style="zoom:33%;"></p><p>对FIFO和LRU做了折中</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">序号<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 5 </span>6<span class="hljs-number"> 7 </span>8<span class="hljs-number"> 9 </span>10<br>假设访问次数为 c a d b e b a b c d<br>最开始的物理存储顺序为  a b c d<br>在访问到e时，此时<br>a =<span class="hljs-number"> 1 </span>b =<span class="hljs-number"> 1 </span>c =<span class="hljs-number"> 1 </span>d =<span class="hljs-number"> 1 </span><br>缺页后，会从指针开始处a（为啥是从头开始？）<br>a =<span class="hljs-number"> 0 </span>b =<span class="hljs-number"> 0 </span>c =<span class="hljs-number"> 0 </span>d = 0<br>一句话概括缺页情况：遇1则0，遇0则换，换则置1<br></code></pre></td></tr></tbody></table></figure><ul><li><p>改进的Clock算法</p><p>四轮扫描版</p><p>第一轮：(0, 0) 不改变</p><p>第二轮：(0, 1) 访问帧-&gt;0</p><p>第三轮：(0, 0) 不改变</p><p>第四轮：(0, 1)</p><p>二轮扫描版</p><p>考虑到对于修改过的部分，若要置换则要写回到缓冲区、磁盘中去，这也是一个开销</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">序号<span class="hljs-number"> 1 </span>2  <span class="hljs-number"> 3 </span>4  <span class="hljs-number"> 5 </span>6<span class="hljs-number"> 7 </span> <span class="hljs-number"> 8 </span>9 10<br>假设访问次数为 c a_w d b_w e b a_w b c d<br>最开始的物理存储顺序为  a b c d<br>在访问到e时，此时<br>xx表示 访问位 修改位<br>a =<span class="hljs-number"> 11 </span>b =<span class="hljs-number"> 11 </span>c =<span class="hljs-number"> 10 </span>d =<span class="hljs-number"> 10 </span><br>缺页后，会从指针开始处a（为啥是从头开始？）<br>a =<span class="hljs-number"> 01 </span>b =<span class="hljs-number"> 01 </span>c =<span class="hljs-number"> 00 </span>d = 00<br>a =<span class="hljs-number"> 00 </span>b =<span class="hljs-number"> 00 </span>置换c<br>一句话概括缺页情况：遇11则01，遇01则00，遇00则换，换则置10/11<br></code></pre></td></tr></tbody></table></figure></li></ul><h5 id="最不常用算法lfu">最不常用算法（LFU）</h5><p>Least Frequency Used</p><p>与LRU的区别在于，它统计的是访问次数</p><p><img src="D:\ZJUT\OS\Notes\notes.assets\image-20211210110941976.png" alt="image-20211210110941976" style="zoom:33%;"></p><h5 id="belady现象">Belady现象</h5><p>使用FIFO等算法时，物理页面数增加，缺页次数也增加的现象</p><p>哪些算法可能出现Belady现象？</p><p>FIFO。</p><h5 id="算法的比较">算法的比较</h5><p>LRU、FIFO本质都是先进先出的思路</p><p>LRU可退化成FIFO</p><p>Clock是二者的折中</p><h4 id="全局页面置换详解">全局页面置换详解</h4><p><img src="D:\ZJUT\OS\Notes\notes.assets\image-20211210112136928.png" alt="image-20211210112136928" style="zoom:33%;"><img src="D:\ZJUT\OS\Notes\notes.assets\image-20211210112152550.png" alt="image-20211210112152550" style="zoom:33%;"></p><p>如上图所示，页面增加1个，缺页率大大下降</p><p>全局页面置换算法要考虑的是<strong>给进程分配可变数目的物理页面</strong>。</p><p>进程在执行过程中，内存的需求是变化的，如何动态给进程分配物理页面</p><p>对换区，连续分配，读写速度更快；文件区，离散分配</p><p>unix方式：第一次调入，空间不够调入对换区，再使用的话再从对换区调入内存</p><p>不存在固定分配全局置换的方式。</p><h5 id="抖动和负载控制">抖动和负载控制</h5><p>抖动：刚换入内存，又要换出外存</p><h5 id="工作集算法">工作集算法</h5><p>驻留集：请求分页存储管理中给进程分配的物理块的集和</p><p>工作集：某段时间（窗口）内，进程实际访问的页面集合</p><p>驻留集不能小于工作集的大小</p><h2 id="调度">调度</h2><h3 id="评价指标">评价指标</h3><p><img src="https://img-blog.csdnimg.cn/20190808150452263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5MDE4Mjc3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 33%;"></p><p>等待时间=周转时间-运行时间-(I/O时间)</p><h3 id="fcfs">FCFS</h3><h4 id="简述">简述</h4><p>First-Come-First-Served. 先来先服务。</p><h4 id="特点">特点</h4><ul><li>简单且垃圾</li></ul><h3 id="spnsjf">SPN(SJF)</h3><h4 id="简述-1">简述</h4><p>Short Process Next. 短进程优先算法。若一个进程正在执行，然后又来一个进程，该进程的<strong>预期时间</strong>要比正在运行的进程<strong>预期剩余时间</strong>要短，则允许其抢占（<strong>SRT</strong>，短剩余时间优先）。至于<strong>预期时间</strong>，一是可询问用户，二可以通过过去预测未来。对于后者，<span class="math inline">\(\tau_{n+1}=\alpha t_n + (1-\alpha)\tau_n = \alpha t_n + (1-\alpha)\alpha t_n+(1-\alpha)(1-\alpha)t_{n-2}+\dots\)</span></p><p>选择<strong>当前已经到达</strong>的<strong>等待时间最短</strong>的进程</p><h4 id="优点">优点</h4><ul><li><p>最优平均周转时间（所有进程几乎同时到达的情况下）</p><ul><li><p>证明：</p><figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+-----------------------------------------------------------+</span><br><span class="hljs-section">| c1 |   c2   |c3 |c4|</span><br><span class="hljs-section">+-----------------------------------------------------------+</span><br>0  r1      r2             r3   r4<br>平均周转时间为(r1<span class="hljs-code">+r2+</span>r3+r4)/4<br><span class="hljs-section">任意调换2个进程</span><br><span class="hljs-section">+-----------------------------------------------------------+</span><br><span class="hljs-section">| c1 |c4|   c2   |c3    |</span><br><span class="hljs-section">+-----------------------------------------------------------+</span><br>0r1r3-c2-c3<span class="hljs-code">+c4r2+</span>c4r4<br>平均周转时间为(r1<span class="hljs-code">+r2+</span>r3<span class="hljs-code">+r4+</span>2<span class="hljs-strong">*c4-c2-c3)</span><br><span class="hljs-strong">又c4&gt;c2,c4&gt;c3，所以2*</span>c4-c2-c3&gt;0，调换之后时间更长。<br></code></pre></td></tr></tbody></table></figure></li></ul></li></ul><h4 id="缺点">缺点</h4><ul><li>饥饿<ul><li>长进程持续得不到执行</li></ul></li><li>预期时间不好预测</li></ul><h3 id="hrrn">HRRN</h3><h4 id="简述-2">简述</h4><p>Highest Response Ratio Next. 最高响应比优先算法。相应比R=(w+s)/s。s: 执行时间；w: 等待时间。<strong>不允许抢占</strong>。SPN的一种改进。<strong>不会导致饥饿</strong></p><p>响应比： 响应比=1+S/T （S：等待时间；T：运行时间） a. ex:有三个作业，在9:40开始响应三个作业，在单道运行且采用响应比优先调度算法（HRRN：Highest Response Ratio Next）的情况下，求： （1）三个作业的执行次序； （2）三个作业被选中时的响应比</p><p><img src="https://img-blog.csdnimg.cn/20210601155400267.jpg#pic_center" alt="在这里插入图片描述" style="zoom: 67%;"></p><p>解： （1）在9:40开始响应三个作业，此时，三个作业均已到达。 先把运行时间（计算时间）转换为分钟。 再考虑它们的到达时间与9:40的间隔： J1：100分钟 J2：70分钟 J3：10分钟 有： J1响应比=1+100/120=11/6 J2响应比=1+70/60=13/6 J3响应比=1+10/15=5/3 所以，三个作业的执行次序：J2、J1、J3 （2）一开始先由（1）的结果来进行判断，此时可以看出，是J2先开始，J1、J3等待。 需要注意的是，因为是单道运行，所以J2运行的时候，J1、J3是不运行的，此时，它们的等待时间会延长，延长的时间等于J2运行的时间（J2运行时间=60），所以接下来： J1响应比=1+（100+60）/120=7/3 J3响应比=1+（10+60）/15=17/3 之后的执行顺序变为了：J3、J1 同理： J1响应比=1+（100+60+15）/120=59/24 之后依次列出三个作业最终的响应比即可。</p><h3 id="rr">RR</h3><h4 id="简述-3">简述</h4><p>Round Robin. 时间片轮转算法，时间片+FCFS。假定：时间片=20，进程P1=53，P2=8，P3=68，P4=24。时间片选择：经验规则为，维持上下文开销为1%左右。</p><figure class="highlight coq"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq">+---------------------------------------------------------------+<br>|<span class="hljs-type">P1</span>|<span class="hljs-type">P2</span>|<span class="hljs-type">P3</span>|<span class="hljs-type">P4</span>|<span class="hljs-type">P1</span>|<span class="hljs-type">P3</span>|<span class="hljs-type">P4</span>|<span class="hljs-type">P1</span>|<span class="hljs-type">P3</span>|<span class="hljs-type">P3</span>|<br><span class="hljs-type">+---------------------------------------------------------------+</span><br><span class="hljs-type">0</span><span class="hljs-number">20</span> <span class="hljs-number">28</span>   <span class="hljs-number">48</span><span class="hljs-number">68</span><span class="hljs-number">88</span><span class="hljs-number">108</span> <span class="hljs-number">112</span><span class="hljs-number">125</span><span class="hljs-number">145</span> <span class="hljs-number">153</span><br></code></pre></td></tr></tbody></table></figure><h4 id="优点-1">优点</h4><ul><li>交互性强</li></ul><h4 id="缺点-1">缺点</h4><ul><li>额外的上下文开销</li><li>时间片大小不好确定，太长则退化成FCFS，太短则加大切换上下文时间开销。</li></ul><h3 id="srtn">SRT(N)</h3><p>Shortset Remaining Time (Next)</p><p><strong>抢占式</strong>的SPN。当有新进程加入时，重新执行调度。</p><p>具有最短的平均周转时间、平均等待时间。</p><h3 id="mlfq">MLFQ</h3><h4 id="简述-4">简述</h4><p>MultiLevel Feedback Queue. 多级反馈队列。多种算法的集成。</p><h3 id="fss">FSS</h3><h4 id="简述-5">简述</h4><p>公平共享调度算法。</p><h3 id="总结">总结</h3><p><img src="D:\ZJUT\OS\Notes\notes.assets\image-20211213111615507.png" alt="image-20211213111615507" style="zoom: 50%;"></p><p><img src="D:\ZJUT\OS\Notes\notes.assets\image-20211213113003434.png" alt="image-20211213113003434" style="zoom:50%;"></p><p><img src="D:\ZJUT\OS\Notes\notes.assets\image-20211213113037695.png" alt="image-20211213113037695" style="zoom:50%;"></p><h3 id="实时系统">实时系统</h3><h4 id="简述-6">简述</h4><p>指定时间完成指定任务</p><ul><li>实时任务：完成任务所需的时间，定时参数</li><li>周期实时任务：任务有规律性地重复<ul><li>周期</li><li>执行时间 = 最大执行时间</li><li>使用率</li></ul></li><li>硬时限，软时限</li><li>可调度性<ul><li>一个实时系统，能够满足任务时限的要求</li><li>静态调度算法<ul><li>速率单调调度算法（RM）<ul><li>通过周期安排优先级</li><li>周期越短优先级越高</li><li>执行周期最短的任务</li></ul></li></ul></li><li>动态调度算法<ul><li>最早截止时间任务（EDF）<ul><li>截止时间越早的任务先执行</li></ul></li></ul></li></ul></li></ul><h3 id="多处理机调度">多处理机调度</h3><h4 id="进程分配">进程分配</h4><h5 id="静态进程分配">静态进程分配</h5><p>开始到结束都被分配到一个固定的处理</p><p>每个处理机有自己的就绪队列</p><p>调度开销小</p><p>各处理机可能忙闲不均</p><h5 id="动态进程分配">动态进程分配</h5><p>进程在执行中可分配到任意空闲处理机执行</p><p>所有处理机共享一个公共的就绪队列</p><p>调度开销大</p><p>各处理机的负载是均衡的</p><h2 id="同步互斥">同步互斥</h2><h3 id="问题">问题</h3><ul><li>保证并发进程的正确性<ul><li>独立进程<ul><li>不和其他进程共享资源</li><li>确定性，输入状态决定结果</li><li>可重现，能够重现起始条件</li><li>调度顺序不重要</li></ul></li><li>并发进程<ul><li>在多个进程有资源共享</li><li>不确定性</li><li>不可重现</li><li>程序错误可能是间歇性发生的</li></ul></li></ul></li><li>并发进程很好啊<ul><li>资源共享</li><li>加速</li><li>模块化</li></ul></li><li>新进程分配标识中的可能错误<ul><li>原子操作：不存在任何中断或失败的操作</li></ul></li></ul><h3 id="实现方法">实现方法</h3><ul><li><p>临界区</p><ul><li>共享的资源</li></ul></li><li><p>中断法</p><ul><li>仅限于单处理器</li></ul></li><li><p>软件法</p><ul><li><p>共享变量</p></li><li><p>Peterson算法（互相谦让）</p><ul><li><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span>{<br>flag[i] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示进程是否准备好进入临界区</span><br>    turn = j;<span class="hljs-comment">// 表示该谁进入临界区</span><br>    <span class="hljs-keyword">while</span>(flag[j] &amp;&amp; turn == j); <span class="hljs-comment">// 如果对方准备好了，那就给对方，等待，即谦让</span><br>    Critical Section;<br>    flag[i] = <span class="hljs-literal">false</span>;<br>    Remainder Section;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>Dekker's算法（举手回答）</p><ul><li><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">do</span>{<br>    flag[i] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(flag[j] == <span class="hljs-literal">true</span>){<span class="hljs-comment">// 如果对方准备好了（也可能正在Critical Section）</span><br><span class="hljs-keyword">if</span>(turn != i){<span class="hljs-comment">// 看turn指向谁</span><br>flag[i] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 不是指向我，那就放弃，防止死锁</span><br>            <span class="hljs-keyword">while</span>(turn != i); <span class="hljs-comment">// busy waiting</span><br>flag[i] = <span class="hljs-literal">true</span>;<br>        }<br>    }<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    这种似乎也可以？非也</span><br><span class="hljs-comment">    if(flag[j] == true){// 如果对方准备好了</span><br><span class="hljs-comment">if(turn != i){// 看turn指向谁</span><br><span class="hljs-comment">            while(turn != i); // busy waiting</span><br><span class="hljs-comment">        }</span><br><span class="hljs-comment">    }</span><br><span class="hljs-comment">    若本来turn == j, 但是flag[j] == false;</span><br><span class="hljs-comment">    欸，那么i说既然你不来，我就去Critical Section了</span><br><span class="hljs-comment">    执行到一半flag[j] == true, 虽然j看到flag[i] == true</span><br><span class="hljs-comment">    那也无妨，因为turn == j, 所以j也就进去了。</span><br><span class="hljs-comment">    */</span><br>    Critical section;<br>    turn = j;<br>    flag[i] = <span class="hljs-literal">false</span>;<br>    Remainder Section;<br>}<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>对于多个线程</p><ul><li><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">对于Dekker's算法</span><br><span class="hljs-comment">turn:</span><br><span class="hljs-comment">    0 -&gt; 1 -&gt; 2 -&gt; ... -&gt; i -&gt; i+1 -&gt; ... -&gt; j -&gt; ... -&gt; n -&gt; 0</span><br><span class="hljs-comment">                            t</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>软件法的缺陷：忙等待，占用CPU资源，复杂。</p></li></ul></li><li><p>锁</p><ul><li><p>原子操作指令</p><ul><li>test-and-set<ul><li>从内存中读取值-&gt;测试是否为1，返回true or false-&gt;设置内存为1</li></ul></li><li>compare-and-swap<ul><li>交换内存的两个值</li></ul></li></ul></li><li><p>自旋锁（Spinlock）</p><ul><li><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//--------------忙等待版---------------</span><br>Lock{<br>    <span class="hljs-type">bool</span> value;<br>    Aquire(){<br><span class="hljs-keyword">while</span>(test-and-<span class="hljs-built_in">set</span>(value)); <span class="hljs-comment">// spin</span><br>        <span class="hljs-comment">// 若为0，则加锁 </span><br>        <span class="hljs-comment">// 若为1，则等待对方释放锁再加锁</span><br>    }<br>    Release(){<br>value = <span class="hljs-number">0</span>;<br>    }<br>};<br><br><span class="hljs-comment">//--------------无忙等待版--------------</span><br>Lock{<br><span class="hljs-type">bool</span> value;<br>    Aquire(){<br><span class="hljs-keyword">while</span>(test-and-<span class="hljs-built_in">set</span>(value)){<br>add this TCB to wait <span class="hljs-built_in">queue</span> q;<br>            schedule();<br>        }<br>    }<br>    Release(){<br>value = <span class="hljs-number">0</span>;<br>        remove one thread t from q;<br>        wakeup(t)<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>优点：适用于多处理器、多临界区</p></li><li><p>缺点：可能导致饥饿，可能导致死锁</p></li></ul></li></ul><h3 id="信号量">信号量</h3><h4 id="问题-1">问题</h4><p>信号量（semaphore）的引入，和<strong>锁</strong>类似，也是一种在并发编程中为解决不同资源对临界区的访问的方法</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">并发编程临界区<br>高层抽象信号量锁<br>硬件支持禁用中断原子操作原子<br></code></pre></td></tr></tbody></table></figure><p>信号是一种抽象数据类型</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">classSemaphore{<br>    <span class="hljs-type">int</span> sem; <span class="hljs-comment">// 信号量</span><br>    WaitQueue q;<br>    P(){<br>  sem--;<br>        <span class="hljs-keyword">if</span>(sem &lt; <span class="hljs-number">0</span>){<br>            Add this thread t to q;<br>            block(p);<br>        }<br>}<br>    V(){<br>        sem++;<br>        <span class="hljs-keyword">if</span>(sem&lt;=<span class="hljs-number">0</span>){<br>Remove a thread t from q;<br>            wakeup(t);<br>        }<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>PV由操作系统支持，是原子操作</strong></p><h4 id="使用">使用</h4><h5 id="互斥访问">互斥访问</h5><p>PV操作必须成对使用，不可颠倒重复</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">mutex = new classSemaphore(<span class="hljs-number">1</span>);<br>mutex -&gt; P();<span class="hljs-comment">// 若第1个线程来了，那就sem--，第二个线程来，sem--，由于sem&lt;0，所以等待</span><br>Critical Section;<br>mutex -&gt; V();<span class="hljs-comment">// 恢复</span><br></code></pre></td></tr></tbody></table></figure><h5 id="条件同步">条件同步</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">condition = new classSemaphore(<span class="hljs-number">0</span>);<br>---------------------------------------------<br>Thread A|Thread B<br>Module M|<br>condition -&gt; P()       |<br>Module N|<br>waiting    |X<br>waiting|condition -&gt; V()<br>Module N    |Y<br></code></pre></td></tr></tbody></table></figure><h4 id="生产者与消费者问题">生产者与消费者问题</h4><p>生产者-&gt;缓冲区-&gt;消费者</p><p>缓冲区只允许一个生产者或消费者进行操作。所以缓冲区是一种临界区。</p><ul><li>任何时刻只允许由一个线程进行操作（互斥访问） -----mutex</li><li>缓冲区为空时，消费者必须等待生产者（条件同步）-----fullBuffer</li><li>缓冲区为满时，生产者必须等待消费者（条件同步）-----emptyBuffer</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">Class BoundedBuffer{<br>mutex = new Semaphore(<span class="hljs-number">1</span>);<br>    fullBuffers = new Semaphore(<span class="hljs-number">0</span>);<br>    emptyBuffers = new Semaphore(n);<br>    Deposit(c){<span class="hljs-comment">// 生产者</span><br>        emptyBuffers -&gt; P();<span class="hljs-comment">// 是否有空余空间</span><br>        mutex -&gt; P();<br>Add c to the Buffer;<br>        mutex -&gt; V();<br>        fullBuffers -&gt; V();<br>    }<br>Remove(c){<br>        fullBuffers -&gt; P();<br>        mutex -&gt; P();<br>Remove c to the Buffer;<br>        mutex -&gt; V();<br>        emptyBuffers -&gt; V();<br>    }<br>}<br><span class="hljs-comment">// PV顺序不要随意调换，否则很容易发生死锁</span><br></code></pre></td></tr></tbody></table></figure><h4 id="读者写者问题">读者/写者问题</h4><h4 id="缺陷">缺陷</h4><p>编程复杂，容易构成死锁</p><h3 id="管程">管程</h3><p>管程（Monitor），一种并发程序的编程方法</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">并发编程临界区管程<br>高层抽象信号量锁条件变量<br>硬件支持禁用中断原子操作原子<br></code></pre></td></tr></tbody></table></figure><p>管程是一种用于多线程互斥访问的共享资源的程序结构。</p><ul><li>采取面向对象的方法</li><li>任意时刻最多只有一个线程执行管程代码</li><li>正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时的恢复（<strong>与临界区的重要区别</strong>）</li></ul><p>比如我在临界区执行时，需要等某个数据，那就可以暂时放弃临界区，让其他代码进行访问。</p><h2 id="文件系统">文件系统</h2><h3 id="基本概念">基本概念</h3><h4 id="属性">属性</h4><p>文件名 标识符 类型 位置 大小 文件所有者 保护信息 上次修改时间</p><h4 id="类型">类型</h4><p>无结构：流式文件</p><p>有结构：数据库，有数据项。。</p><h4 id="组织">组织</h4><p>根目录-&gt;子目录-&gt;文件</p><h4 id="系统调用-1">系统调用</h4><p>create open read write close delete</p><h4 id="外存管理">外存管理</h4><p>磁盘块</p><h4 id="共享和保护">共享和保护</h4><p>多个用户、权限</p><h3 id="逻辑结构">逻辑结构</h3><p>对于一个文件</p><h4 id="堆文件">堆文件</h4><p>数据按先来后到的次序组织，每个记录由一串数据组成，是串结构的顺序文件</p><p>目的是积累大量数据并保存，不适合大多数应用</p><h4 id="顺序文件">顺序文件</h4><p>主要对于有结构文件</p><p>文件的记录一个跟着一个顺序排列</p><p>顺序文件常用于批处理应用，适用于对所有记录的处理，对于查询或更新某个记录的请求的处理性能不佳（需要遍历）</p><h5 id="顺序存储">顺序存储</h5><p>逻辑相邻-&gt;物理相邻</p><p>变长记录：不可随机存取</p><p>定长记录：可随机存取</p><h4 id="索引文件">索引文件</h4><p>主要对于有结构文件</p><p>索引表本身是一个定长记录的顺序文件</p><p>每个记录都索引，那开销太大了，可能一个索引都比一条记录大</p><p>常用于实时处理环境中</p><h4 id="索引顺序文件">索引顺序文件</h4><p>主要对于有结构文件</p><p>对索引表进行瘦身，记录进行分组-&gt;每组建立索引-&gt;组内顺序存储</p><p>索引顺序文件既适用于交互方式应用，也适用于批处理方式应用。</p><h5 id="多级索引顺序文件">多级索引顺序文件</h5><h4 id="直接文件或散列文件">直接文件或散列文件</h4><p>检索时给出记录编号（关键域），通过哈希函数（散列函数）计算出该记录在文件中的相对位臵</p><p>常用于需要高速访问文件且每次访问一条记录的应用中。</p><h3 id="目录">目录</h3><p>目录文件是一个有结构文件</p><h4 id="文件控制块fcb">文件控制块（FCB）</h4><p>目录的一条一条记录</p><p>为了实现<strong>按名存取</strong></p><p>一般成分：</p><ul><li>基本属性：文件名、文件的物理位置、文件的逻辑结构、文件的物理结构</li><li>存取控制信息：文件存储权限等</li><li>使用信息：文件建立时间、修改时间等</li></ul><h4 id="单级目录">单级目录</h4><p>不可重名</p><h4 id="两级目录结构">两级目录结构</h4><p>主文件目录（MFD）、用户文件目录（UFD）</p><h4 id="多级目录结构">多级目录结构</h4><p>不同目录下的文件名可以重名</p><p><strong>当前目录</strong>：相对路径，不必从根目录开始一层一层往下找，提高效率</p><p>树形结构不便于文件共享</p><h4 id="无环图目录结构">无环图目录结构</h4><p>有向无环图</p><p>共享计数器：计数器减少至0时，才删除</p><p>其中一个用户进行更改，其他用户也可以看到</p><h4 id="索引节点fcb的改进">索引节点（FCB的改进）</h4><p>FCB太大了，I/O操作费时</p><p>文件名+索引节点指针</p><p>也就是说，每次找文件，不必把文件信息都调进来</p><p>先把文件名找到，再根据指针调入索引节点</p><p>就是说 文件名和文件信息分开，取而代之的是文件信息的指针</p><h3 id="物理结构">物理结构</h3><p>要考虑的是在外存的组织形式</p><p>文件地址空间被划分为一个一个文件的块</p><p>逻辑块号-&gt;物理块号</p><h4 id="连续分配">连续分配</h4><p>物理块号=起始块号+逻辑块号；验证长度</p><p>顺序读写时非常快（对于磁盘来说）</p><p>数据拓展非常不方便；磁盘碎片</p><h4 id="链接分配">链接分配</h4><h5 id="隐式链接默认">隐式链接（默认）</h5><p>一个一个块调入</p><p>先调入一个块，读取指针，再读下一个块</p><p>查找效率很低；方便拓展，不会有碎片问题</p><h5 id="显式链接">显式链接</h5><p>FAT（文件分配表）</p><p>FAT存放 物理块号+下一块块号</p><p>一个磁盘仅设置一个FAT</p><p>将FAT读入内存，并常驻内存</p><p>从文件表项查找起始块号-&gt;从FAT依次查找所有块号</p><p>方便拓展，不会有碎片问题；没有频繁的I/O操作；FAT需要空间啊</p><h4 id="索引分配">索引分配</h4><p>每个文件建立一张索引表</p><p>每个文件设置一个索引块号，根据索引块号读入索引表</p><p>索引表的块号一般占4B，定长，可随机访问</p><p>但是一个磁盘块可能放不下呀</p><h5 id="链接方案">链接方案</h5><p>多个索引块链接</p><p>同样低效</p><h5 id="索引方案套娃">索引方案（套娃）</h5><p>一级索引-&gt;二级索引</p><p>都要k+1次访问</p><h5 id="混合索引">混合索引</h5><p>直接地址</p><p>一级地址</p><p>二级地址</p><h4 id="存储空间管理">存储空间管理</h4><h5 id="划分与初始化">划分与初始化</h5><p>文件卷(分区)-&gt;[目录区 文件区]</p><h5 id="空闲表法">空闲表法</h5><p>适用于连续分配的方式</p><p>首次适应、最佳适应、最坏适应之类的</p><p>合并问题</p><h5 id="空心链表法">空心链表法</h5><p>空闲盘块链</p><p>空闲盘区链</p><p>链头、链尾指针</p><h5 id="位示图法">位示图法</h5><p>(字号, 位号)</p><p>顺序扫描，找到连续的0（非连续分配则不需要）</p><h5 id="成组链接">成组链接</h5><p>超级块：空闲块好，下一组空闲盘块号（指针），和各个空闲盘块块号</p><p>先检查第一组，如果改组满了，记得把下一组的链接信息复制回去</p><h4 id="文件操作">文件操作</h4><ul><li><p>create</p><p>所需空间大小，存放路径，文件名</p><p>为文件分配存储空间</p><p>在目录表中插入目录项</p></li><li><p>delete</p><p>文件存放路径，文件名</p><p>找到文件名对用的目录项</p><p>回收文件占用的磁盘块</p><p>删除目录项</p></li><li><p>open</p><p>存放路径，文件名，文件操作类型（读/写）</p><p>找到文件名对应的目录项，检查操作权限</p><p>对应的目录项，复制到内存的打开文件表中</p><p>系统的打开文件表（全局，仅一张）,文件偏移量，访问权限，索引节点指针</p><p>进程的打开文件表，指向系统的打开文件表</p><p>打开计数器+1</p></li><li><p>close</p><p>。。。</p></li><li><p>read</p></li><li><p>write</p></li></ul><h4 id="文件共享">文件共享</h4><ul><li>硬链接<ul><li></li></ul></li><li>软链接（类似于win的快捷方式）<ul><li>根据路径信息去找到</li><li>删除一个文件，其对应的软链接去查找会失败</li><li>更慢</li></ul></li></ul><h4 id="文件保护">文件保护</h4><ul><li>口令保护<ul><li>请求时须提供口令</li><li>口令一般存于FCB或者索引节点中</li><li>不安全，存在于系统内部</li></ul></li><li>加密保护<ul><li>保密性强，不需要在系统中存储密码</li><li>编码/译码费时</li></ul></li><li>访问控制<ul><li>rwx</li><li>u g o su</li></ul></li></ul><h4 id="层次结构">层次结构</h4><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">用户接口-系统调用</span><br><span class="hljs-code">文件目录系统-文件目录</span><br><span class="hljs-code">存取控制模块-文件保护</span><br><span class="hljs-code">逻辑文件系统与文件信息缓存区-逻辑结构</span><br><span class="hljs-code">物理文件系统-物理结构</span><br><span class="hljs-code">辅助分配模块-存储管理设备管理模块-磁盘管理</span><br><span class="hljs-code"></span><br></code></pre></td></tr></tbody></table></figure><ol type="1"><li>通过系统调用发送请求</li><li>在系统中一层层查找，找到对应的目录项</li><li>根据目录项（FCB）验证权限</li><li>将记录号转变为对应的逻辑地址</li><li>将逻辑地址转化为物理地址</li><li>对磁盘设备发送请求，存储空间管理</li></ol><h2 id="io设备管理">I/O设备管理</h2><h3 id="缓冲区">缓冲区</h3><h4 id="单缓冲">单缓冲</h4><p>初始状态：工作区满，缓冲区空</p><p>缓冲区-&gt;工作区：M</p><p>工作区-&gt;CPU: C</p><p>设备-&gt;缓冲区: T</p><p>max(T, C)+M</p><h4 id="双缓冲">双缓冲</h4><p>初始状态：一个缓冲区满，一个为空</p><p>max(M+C, T)</p><h2 id="question">QUESTION</h2><ol type="1"><li>GDT</li><li></li></ol><h3 id="section-1"></h3>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
